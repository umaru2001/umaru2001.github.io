<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>海祇岛的珊瑚森林</title>
  
  <subtitle>海星来来の人云亦云</subtitle>
  <link href="https://blog.pengdonglai.com/atom.xml" rel="self"/>
  
  <link href="https://blog.pengdonglai.com/"/>
  <updated>2025-02-22T06:59:33.120Z</updated>
  <id>https://blog.pengdonglai.com/</id>
  
  <author>
    <name>海星来来</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CS144 Lab（2）：TCP 的发送和接收</title>
    <link href="https://blog.pengdonglai.com/2025/02/15/stanford-cs144-2/"/>
    <id>https://blog.pengdonglai.com/2025/02/15/stanford-cs144-2/</id>
    <published>2025-02-15T14:32:28.000Z</published>
    <updated>2025-02-22T06:59:33.120Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>前景提要<br>在 lab0 中，我们实现了流控制字节流 <code>ByteStream</code>。<br>在 lab1 中，我们创建了一个模块 <code>StreamReassembler</code>，该模块接受一系列从同一字节流中提取的子字符串，并将它们重新填充回 <code>ByteStream</code>，同时将其内存消耗限制在给定的容量 capacity。</p></blockquote><p>现在，在 lab2 中，你将实现 TCP 中处理入站字节流的部分：<code>TCPReceiver</code>。在编写<code>StreamReassembler</code> 和 <code>ByteStream</code> 时，你已经完成了其中大部分的「算法」工作。<code>TCPReceiver</code> 主要的逻辑是如何将这些类连接到 TCP 格式。</p><p>在 lab3 中，你将实现连接的另一端 <code>TCPSender</code>：一个将出站字节流转换为不可靠数据报中发送段的工具。它负责读取 <code>ByTestStream</code>（由某些发送方应用程序创建并写入），并将流转换为一系列传出 TCP Segment。</p><h2 id="lab2-TCPReceiver"><a href="#lab2-TCPReceiver" class="headerlink" title="lab2: TCPReceiver"></a>lab2: TCPReceiver</h2><h3 id="1-1-序列号"><a href="#1-1-序列号" class="headerlink" title="1.1 序列号"></a>1.1 序列号</h3><h4 id="1-1-1-概念"><a href="#1-1-1-概念" class="headerlink" title="1.1.1 概念"></a>1.1.1 概念</h4><p>实际上我们绝大多数人进入 lab2 就会被这张表格糊脸：</p><table><thead><tr><th>Sequence Numbers</th><th>Absolute Sequence Numbers</th><th>Stream Indices</th></tr></thead><tbody><tr><td>Start at the ISN</td><td>Start at 0</td><td>Start at 0</td></tr><tr><td>Include SYN&#x2F;FIN</td><td>Include SYN&#x2F;FIN</td><td>Omit SYN&#x2F;FIN</td></tr><tr><td>32 bits, wrapping</td><td>64 bits, non-wrapping</td><td>64 bits, non-wrapping</td></tr><tr><td>“seqno”</td><td>“absolute seqno”</td><td>“stream index”</td></tr></tbody></table><h4 id="1-1-2-推导-＆-转换逻辑"><a href="#1-1-2-推导-＆-转换逻辑" class="headerlink" title="1.1.2 推导 ＆ 转换逻辑"></a>1.1.2 推导 ＆ 转换逻辑</h4><p>TCP 的序列号是 32 位的，可能会因为回绕 (wrap around) 的问题，所以需要将其转换为一个更大的数值空间，也就是 absolute_seqno。而 checkpoint 的作用是作为一个参考点，帮助确定最接近的 absolute_seqno 值。也就是说，当多个可能的 absolute_seqno 可能对应同一个 32 位的 seqno 时，选择离 checkpoint 最近的那个。</p><h4 id="1-1-3-与-TCPReceiver-的联系"><a href="#1-1-3-与-TCPReceiver-的联系" class="headerlink" title="1.1.3 与 TCPReceiver 的联系"></a>1.1.3 与 TCPReceiver 的联系</h4><p>那在 TCPReceiver 的 receiver_segment() 中，什么时候需要调用这个 unwrap 函数呢？</p><p>是在处理接收到的 TCP 段的序列号时，需要将其转换为绝对序列号，以便确定数据的位置。例如，当收到一个数据包时，里面的 seqno 是 32 位的，我们需要知道它在整个字节流中的绝对位置，这样才能正确重组数据。</p><p>此时我们已经有了核心方法：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> absolute_seqno <span class="token operator">=</span> <span class="token function">unwrap</span><span class="token punctuation">(</span>seg<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>seqno<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token operator">-></span>_isn<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">/* 未知 checkpoint */</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在调用 unwrap 的时候，应该把第三个参数 checkpoint 设置为什么值？</p><p>我们先明确一个结论：checkpoint 值的设立，是为了确保 <code>segment_received()</code> 获取到的 <code>seqno</code> 转为的 <code>absolute_seqno</code>，符合预期。进一步地说，它能被转为正确的 <code>absolute_seqno</code> 而不是 <code>absolute_seqno - n*2^32</code> 亦或者是 <code>absolute_seqno + n*2^32</code>。因为 checkpoint 值的不同，导致的转化出现不符合预期的情况，就是转化出来的 <code>absolute_seqno</code> 多出或者少了若干个 2^32 的量级。</p><p>我们来直观表示一下。假设我们有三个 2^32 的区间 ，checkpoint 在 (2^32, 2*2^32) 这个区间范围内，我们可以这样表示当前的区间：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">0, ..., 2^32, ..., [checkpoint], ..., 2*2^32, ..., 3*2^32<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>一个 <code>seqno</code> 为 1 的 segment 片段，它有可能被分配到区间内的 <code>1</code>，也有可能被分配到 <code>1+2^32</code> 或者 <code>1+2*2^32</code> 这两个地方。我们站外设计者的视角来看当然希望它转换后的 <code>absolute_seqno</code> 也是 <code>1</code>. 但很可惜，它最终得到的值是 <code>1+2^32</code> 或者 <code>1+2*2^32</code>，因为它们离 checkpoint 更近。具体结果是什么则要取决于它是否离 checkpoint 更加接近了。</p><p>从直观上，离 checkpoint 近的 <code>seqno</code> 才更不容易出错。实际上，它拥有一个十分明确的「边界」，在边界内的 <code>seqno</code> 转换后，一定不会出错。在边界外的 <code>seqno</code> 转换后，一定会出错。我们进一步讨论这个「边界」的范围：</p><p>假定 checkpoint 为 <code>2+2^32</code>，那么它的「边界」是这个样子：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">0, ..., [下边界: 3+2^31], ..., 2^32, ..., [checkpoint: 2+2^32], ..., [上边界: 1+2^32+2^31], ..., 2*2^32, ..., 3*2^32<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>是一个：<strong>以 checkpoint 为中心，大小为 2^32-1 的区间</strong>。</p><p>所以 checkpoint 是什么值，就转化为了：「区间」的中心值是什么值，才能让 <code>seqno</code> 的值尽可能地落在这个区间内。</p><p>也可以等价于，是否能找到一个区间，到达 TCP 接收端的 segment 片段中的 <code>seqno</code> 尽可能落在这个区间。</p><p>当然这个问题实际上我们现在仍然难以证明（笔者写到这里也不知道后续的章节是否会证明这个问题，哈哈哈）所以我们抛出结论：</p><p><strong>checkpoint 的正确取值应为当前接收方期望的下一个字节的绝对序列号，即已成功重组并写入字节流（ByteStream）的字节数量。</strong>具体来说：</p><p>checkpoint 是 <code>stream_out().bytes_written()</code>，即已写入的字节数。</p><ul><li><code>absolute_seqno</code> 从 0 开始计数，每个字节对应一个绝对序列号。例如，第一个字节为 0，第二个为 1，依此类推。</li><li>若已成功重组并写入 k 个字节（<code>stream_out().bytes_written()</code> &#x3D;&#x3D; k），则下一个期望的字节的 <code>absolute_seqno</code> 是 k。</li><li>使用 k 作为 checkpoint，unwrap 会选择最接近 k 的合法 <code>absolute_seqno</code>，确保正确处理序列号回绕。到达 TCP 接收端的 segment 片段中的 <code>seqno</code> 尽可能落在了以 <code>absolute_seqno</code> 为中心，长度为 2^32-1 的区间。</li></ul><p>是不是听着好像也还挺合理的… 和现实中对应，2^32 已经是 4.295GB 大小了。以我们对于 TCP 的控制来说，传输应该不会乱成这个样子吧。康宇的博客也有这样的描述：</p><blockquote><p>但几乎不可能出现相邻到达的两个 segment 序号差值超过 <code>INT32_MAX</code> 的情况，除非延迟以年为单位，或者产生了比特差错（后面的 LAB 可能涉及）。</p></blockquote><p>我们现在不再纠结，然后处理出来应该是这样：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> absolute_seqno <span class="token operator">=</span> <span class="token function">unwrap</span><span class="token punctuation">(</span>seg<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>seqno<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token operator">-></span>_isn<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">stream_out</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bytes_written</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当然在我的项目中，我新增了一个方法获取 <code>StreamReassembler</code> 中的 <code>_first_disassembled_index</code>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">size_t <span class="token class-name">StreamReassembler</span><span class="token double-colon punctuation">::</span><span class="token function">first_disassembled_index</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token operator">-></span>_first_disassembled_index<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>它和 <code>stream_out().bytes_written()</code> 实际上是同一个值。这一点就不再展开。</p><h3 id="1-2-实现"><a href="#1-2-实现" class="headerlink" title="1.2 实现"></a>1.2 实现</h3><p><code>tcp_receiver.hh</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">TCPReceiver</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//! Our data structure for re-assembling bytes.</span>    StreamReassembler _reassembler<span class="token punctuation">;</span>    <span class="token comment">//! The maximum number of bytes we'll store.</span>    size_t _capacity<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>optional<span class="token operator">&lt;</span>WrappingInt32<span class="token operator">></span> _ackno<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>optional<span class="token operator">&lt;</span>WrappingInt32<span class="token operator">></span> _isn<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">_update_ackno</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>tcp_receiver.cc</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">TCPReceiver</span><span class="token double-colon punctuation">::</span><span class="token function">segment_received</span><span class="token punctuation">(</span><span class="token keyword">const</span> TCPSegment <span class="token operator">&amp;</span>seg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token operator">-></span>_isn<span class="token punctuation">.</span><span class="token function">has_value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>seg<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>syn<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token operator">-></span>_isn <span class="token operator">=</span> seg<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>seqno<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token operator">-></span>_reassembler<span class="token punctuation">.</span><span class="token function">push_substring</span><span class="token punctuation">(</span>seg<span class="token punctuation">.</span><span class="token function">payload</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">copy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> seg<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>fin<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token operator">-></span><span class="token function">_update_ackno</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">auto</span> absolute_seqno <span class="token operator">=</span> <span class="token function">unwrap</span><span class="token punctuation">(</span>seg<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>seqno<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token operator">-></span>_isn<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token operator">-></span>_reassembler<span class="token punctuation">.</span><span class="token function">first_disassembled_index</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// absolute_seqno（绝对序列号）已经包含了一个 syn，因此需要 -1 才能得到正确的起始索引</span>    <span class="token comment">// 如果这个地方已经收到 fin 了，并且绝对序列号大于 fin，那么就要 -2</span>    <span class="token comment">// 但我们实际上在绝对序列号大于 fin 的时候在 push_string 内部就会被抛弃掉，因此不必这么做，直接优化成 -1</span>    <span class="token keyword">this</span><span class="token operator">-></span>_reassembler<span class="token punctuation">.</span><span class="token function">push_substring</span><span class="token punctuation">(</span>seg<span class="token punctuation">.</span><span class="token function">payload</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">copy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> absolute_seqno <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> seg<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>fin<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token operator">-></span><span class="token function">_update_ackno</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>optional<span class="token operator">&lt;</span>WrappingInt32<span class="token operator">></span> <span class="token class-name">TCPReceiver</span><span class="token double-colon punctuation">::</span><span class="token function">ackno</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token operator">-></span>_ackno<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>size_t <span class="token class-name">TCPReceiver</span><span class="token double-colon punctuation">::</span><span class="token function">window_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token operator">-></span>_capacity <span class="token operator">-</span> <span class="token keyword">this</span><span class="token operator">-></span>_reassembler<span class="token punctuation">.</span><span class="token function">stream_out</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">buffer_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token class-name">TCPReceiver</span><span class="token double-colon punctuation">::</span><span class="token function">_update_ackno</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-></span><span class="token function">stream_out</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">input_ended</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token operator">-></span>_ackno <span class="token operator">=</span> <span class="token function">wrap</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-></span>_reassembler<span class="token punctuation">.</span><span class="token function">first_disassembled_index</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token operator">-></span>_isn<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-></span>_isn<span class="token punctuation">.</span><span class="token function">has_value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token operator">-></span>_ackno <span class="token operator">=</span> <span class="token function">wrap</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-></span>_reassembler<span class="token punctuation">.</span><span class="token function">first_disassembled_index</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token operator">-></span>_isn<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="lab3-TCPSender"><a href="#lab3-TCPSender" class="headerlink" title="lab3: TCPSender"></a>lab3: TCPSender</h2><h3 id="2-1-理论"><a href="#2-1-理论" class="headerlink" title="2.1 理论"></a>2.1 理论</h3><h4 id="2-1-1-发送数据"><a href="#2-1-1-发送数据" class="headerlink" title="2.1.1 发送数据"></a>2.1.1 发送数据</h4><p>发送数据，就是字面意思…</p><p>当然，我们需要知道两个事情：</p><ul><li>什么时候可以发送数据？</li></ul><p>一种状况是，我们需要判断这些数据我们能完全发送，也就是数据量不能超过我们发送端的承受能力，当然，也不能超过发送端缓冲区的容量（即我们在这一刻时间能拿出多少数据出来发送）。</p><p>另一种情况是，不能超过对方接收端的接收能力。</p><p>因此，需要分两种情况讨论：</p><ol><li>数据量不能超过我们发送端的承受能力</li></ol><p>发送端承受能力，可以用 <code>TCPConfig::MAX_PAYLOAD_SIZE</code> 来表示，这是发送端的一个属性，也是自定义好的，不需要我们为它赋值。</p><p>发送端缓冲区的容量，也就是 <code>this-&gt;_stream.buffer_size()</code>。</p><p>因此，我们可以从这个条件得出发送端的数据条件为：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> sender_max_segment_payload_size <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>TCPConfig<span class="token double-colon punctuation">::</span>MAX_PAYLOAD_SIZE<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token operator">-></span>_stream<span class="token punctuation">.</span><span class="token function">buffer_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>不能超过对方的接收能力</li></ol><p>对方的接收能力，在下一个问题中我们可以知道它是通过唯一的信号 window_size 来通知发送方的。这表示接收端的窗口大小。</p><p>那么，我们可以进一步将 length 表示为：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> segment_payload_size <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>sender_max_segment_payload_size<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token operator">-></span>_window_size<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>发送的时候，也需要有一个特殊条件，那就是对面窗口为 0 的时候，我们需要持续发送数据量为 1 的 Segment，以避免死锁。</p><p>对于这个问题，我们可以在 <code>fill_window()</code> 方法内，设计一个临时参数，欺骗发送端此时对面的 window_size 最小为 1. 这样就可以确保发送端（在对面窗口为 0 的时候）可以一直发送 Segment.payload 为 1 的数据了。</p><p>此时的代码，我们可以这么写：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 为防止死锁，发送数据的时候即便对面窗口为 0，也至少发送 1 单位的数据</span><span class="token keyword">auto</span> window_size <span class="token operator">=</span> <span class="token generic-function"><span class="token function">max</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">uint16_t</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token operator">-></span>_window_size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 中间省略部分逻辑</span><span class="token keyword">auto</span> segment_payload_size <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>sender_max_segment_payload_size<span class="token punctuation">,</span> window_size<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对面窗口为 0 的时候，我们需要持续发送数据量为 1 的 Segment。它还有一个作用，那就是处于这种情况的时候不会触发超时重传窗口翻倍的机制。这个我们在「超时重传」中会说明。</p><h4 id="2-1-2-接收-Ack"><a href="#2-1-2-接收-Ack" class="headerlink" title="2.1.2 接收 Ack"></a>2.1.2 接收 Ack</h4><ul><li>最简单过程理解</li></ul><p>怎么理解呢？假如说有三个 Segment，它们的 seqno 为 1,2,3.</p><p>假设我们把这些 Segment 全都发送了。但是我们要怎么知道接收方拿到了这些数据呢？接收方也必须要同时给发送方发送数据，做「信息同步」，或者用互联网黑化「对齐」。</p><p>「信息同步」的信息，会带一个数据叫做 ackno，它的取值巧不巧也正好是 1,2,3. 我们做一个假设，ackno 为 2. 那么发送方就知道 1 和 2 已经被接收了。</p><p>也就是说，ackno 代表的 seqno 及之前所有的 seqno，全都被接收方接受到了。</p><p>另外，我们把已经发送出去但还未成功确认的数据报称作 outstanding segments。</p><ul><li>实际上，同步的数据还包括了 window_size</li></ul><p>在发送数据的时候，我们通过接收方的「窗口大小」，知道了我们最多一次性往 Segment 中放入多少数据。那么窗口大小也必须要从「接收方」同步给「发送方」。</p><p>因此，我们可以解答什么是「接收 Ack」了：实际上就是接收方发送信息，同步发送方信息。这个信息包含两个标志，一个是 ackno，也就是接收方接收到了哪些数据。另一个则是 window_size，也就是接收方的窗口大小，发送方据此调整下一步发送的 Segment 的大小。</p><ul><li>接收 Ack 之后，需要主动发起一次 <code>fill_window()</code></li></ul><p>这个主要是为了防止死锁。</p><h4 id="2-1-3-状态变化"><a href="#2-1-3-状态变化" class="headerlink" title="2.1.3 状态变化"></a>2.1.3 状态变化</h4><ul><li>发送数据包含了一系列的状态变化</li></ul><div align="center">  <img src="../../../../loading2.svg" data-original="/2025/02/15/stanford-cs144-2/1.png"></div><p>这张图可以说就是每一个学习网络的孩子都会碰到的图了。我们该如何拆解这张图呢？</p><p>首先我们排除 Error，因为细心的你早就可以发现你在 ByteStream 中已经大概知道 Error 是怎么出现的了~ 当然，也会有一些其它因素导致 Error，但直到这里我们仍然还是不讨论的。请放心。</p><p>观察其它的状态，我们首先要了解两个标志位（SYN 和 FIN 标志位）：</p><ul><li><strong>SYN 标志位</strong><ul><li><strong>含义</strong>：即同步（Synchronize）标志位，用于在 TCP 连接建立时进行同步序列号的操作。</li><li><strong>作用</strong>：发送方（其实就是 TCPSender）发送 SYN 标志位置为 1 的 TCP 报文段，<strong>请求建立连接</strong>，同时在报文中携带一个初始序列号（ISN）。</li></ul></li></ul><p>（服务器收到后，会返回一个 SYN&#x3D;1 且 ACK&#x3D;1 的报文段作为响应，其中也包含自己的初始序列号，这样双方就完成了序列号的同步，为后续可靠的数据传输奠定基础，这也是 TCP 三次握手过程中的关键步骤。）</p><p>–以上这一段是八股文，但是是不是已经有一种理论和实践相结合的体验了–</p><p>SYN 被 TCPSender 发送后，进入 SYN_SENT 状态。收到对应的 SYN&#x3D;1 且 ACK&#x3D;1 的报文段作为响应后，进入 SYN_ACKED 状态。</p><ul><li><strong>FIN 标志位</strong><ul><li><strong>含义</strong>：即结束（Finish）标志位，用于表示发送方已经没有数据要发送了，请求关闭连接。</li><li><strong>作用</strong>：当发送方（其实就是 TCPSender）完成数据传输后，会发送 FIN 标志位置为 1 的 TCP 报文段给对方，告知对方自己的数据发送完毕，请求关闭连接。对方收到后会发送确认报文段（ACK），表示已经收到关闭请求。若接收方也没有数据要发送了，也会发送 FIN 报文段给对方，完成连接的关闭过程，这是 TCP 四次挥手过程中的重要操作。</li></ul></li></ul><p>FIN 基本也是同理，发送端 Sender 发送 FIN 后，进入入 FIN_SENT 状态；收到对应的 FIN&#x3D;1 且 ACK&#x3D;1 的报文段作为响应后，进入 FIN_ACKED 状态。</p><p>关于状态的变化，单元测试套件是如何来判断的呢？我们可以去 <code>tcp_helpers/tcp_state.cc</code> 来学习是如何判断，这对我们理解这几个状态到底是怎么回事很有好处。</p><p>这不是一个必选项，我们实际上无需在程序中写明我们是哪个状态，也不用根据我们当前在哪个状态去做状态机之类的逻辑。因此在我们写代码的时候，不用刻意再去抽离 State 模块。</p><h4 id="2-1-4-超时重传"><a href="#2-1-4-超时重传" class="headerlink" title="2.1.4 超时重传"></a>2.1.4 超时重传</h4><p>TCPSender 承担着两项重要任务：</p><p>其一，它会把原始数据流拆分成多个 TCP 报文（其实就是上一节内容的 Segment），并将这些报文发送出去；这个过程我们在前面说过了。重点了解数据「拆分了」就好。</p><p>其二，它会对每一个已发送出去但尚未被接收方接收的报文，记录其发送时间。倘若存在部分已发送报文，在一段特定的时间内都未得到接收方通过确认号（ackno）进行的确认，那么这些数据包就必须进行重传。</p><p>我们来拆解「其二」，首先就是 1「一段特定的时间」应该如何解释，2「重传哪些数据包」。</p><ol><li>重传所需要的一段特定的时间</li></ol><p>TCPSender 在构造时会被给予一个重传超时时间 RTO 的初始值，它的全称叫 Retransmission Timeout，以下如有可能我们尽可能简称它为 RTO。RTO 是在重新发送未完成 TCP 段之前需要等待的毫秒数，实际上就是「重传所需要的一段特定的时间」的别称。</p><ul><li>RTO 会一直变化，因此它一共是有两个值，它的初始值，和它的现在值。</li><li>RTO 值将会随着时间的流逝（或者更应该说是网络环境的变化）而变化，但初始的RTO将始终不变。</li><li>它的初始值是系统设置好的，不需要我们关心。但它的现值需要我们去根据特定的情况去计算，有一套算法。这就是 <strong>RTO 重传算法</strong>。</li></ul><ol start="2"><li>重传的逻辑：RTO 重传算法</li></ol><p>RTO 重传算法一共有很多种，在理论知识里面我们基本都学了。我们在 lab 中使用较为简单的那一种，它具体描述如下：</p><ul><li>（1）从发送数据包的那一刻开始计时。</li><li>（2）经过一个 RTO 后，没有接收到 Ack。</li><li>（3）此时触发重传，<code>RTO = RTO * 2;</code> 数据包被重新发送。</li><li>（3.1）如果一直没有接受到 ack，那么在上一步重复循环。一直到 uint32_t 下的最大值为止不再继续翻倍。</li><li>（3.2）如果此时接受到了 ackno，无论如何都会将此时的 RTO 重置为初始的 RTO。</li><li>（4.1）此时如果仍然有未确认的包等待重传，那么则基于被重置的 RTO 重新开始计时。</li><li>（4.2）此时如果没有未确认的包（也就是对面收到了我们的全部发送的包），那么计时停止。</li></ul><p>另外，在 2.1.1 我们有提到过，</p><blockquote><p>对面窗口为 0 的时候，我们需要持续发送数据量为 1 的 Segment。它还有一个作用，那就是处于这种情况的时候不会触发超时重传窗口翻倍的机制。</p></blockquote><p>因为这个时候，即便是重传，也只能重传 Segment.payload 为 1 的段。此时它正好处于上述步骤中 2、3、3.1 的区间内，它同样也会一直触发重传，但是不会触发 <code>RTO = RTO * 2;</code> 的机制。此时，<code>RTO = RTO</code>。每次重传都会间隔相同的时间段，且这些时间段都为 RTO。</p><p>实际上的 RTO 重传算法更加复杂，一些课本上的重点特性（快重传、慢启动、选择性确认）我列举在这里供参考（但都是《自顶向下》中学过的）：</p><p>它们更像是 RTO 算法的进一步优化。如果能做完 lab3 并且认真弄懂了其中的内容，再来学习这里会有一种更好的感觉。说不定真的有大神可以把这几个优化做进了 Sender 了呢？</p><p>（这里不看也可以，是选择性阅读，和 lab 没有任何关系）</p><h5 id="超时重传算法补充"><a href="#超时重传算法补充" class="headerlink" title="超时重传算法补充"></a>超时重传算法补充</h5><ol><li>快重传</li></ol><p>而快重传机制是在未等到 RTO 超时的情况下，<strong>通过接收方的反馈信息提前触发重传。</strong></p><p>RTO 重传算法的触发条件是定时器超时，而快重传的触发条件是发送方连续收到三个相同的 ACK（确认号）。例如，发送方发送了数据包 1、2、3、4，接收方成功收到了 1、3、4，但 2 号数据包丢失，接收方会因为没有按序收到 2 号包，而在收到 3、4 号包时，重复发送对 1 号包的确认 ACK。当发送方连续收到三个对 1 号包的 ACK 时，就会触发快重传，不等 RTO 超时就重传 2 号数据包。</p><p>二者相互补充，快重传可以在一定程度上减少因 RTO 设置不合理导致的长时间等待，及时重传丢失的数据，提高传输效率；而 RTO 重传算法则作为一种兜底机制，在快重传未能发挥作用时保证数据最终能够被重传。</p><ol start="2"><li>慢启动</li></ol><p>慢启动是 TCP 协议中用于控制数据发送速率，以避免网络拥塞的一种机制。它是在连接建立初期或网络出现拥塞后恢复时，用来逐渐增加发送方发送数据量的算法，目的是让发送方在开始发送数据时，以一种较为保守、缓慢的方式试探网络的承载能力，防止因发送数据过快过多而导致网络拥塞。</p><ul><li><p><strong>初始阶段</strong>：在 TCP 连接刚建立时，发送方会将拥塞窗口（cwnd）初始化为一个较小的值，通常为 1 个最大段长度（MSS）。这意味着发送方在开始时只能发送一个 MSS 大小的数据段。</p></li><li><p><strong>确认回复与窗口增长</strong>：当发送方发送一个数据段后，会等待接收方的确认（ACK）。一旦收到接收方对该数据段的 ACK，发送方就会将拥塞窗口的大小增加。在慢启动阶段，拥塞窗口是以指数方式增长的，即每收到一个 ACK，拥塞窗口就增加一个 MSS。例如，最初拥塞窗口为 1 个 MSS，收到第一个 ACK 后变为 2 个 MSS，收到第二个 ACK 后变为 4 个 MSS，以此类推。</p></li><li><p><strong>阈值判断</strong>：发送方还会维护一个慢启动阈值（ssthresh）。当拥塞窗口的大小达到或超过慢启动阈值时，慢启动阶段结束，进入拥塞避免阶段，此时拥塞窗口的增长方式会发生变化，不再是指数增长，而是线性增长，以更缓慢、更稳定的方式增加发送速率，避免网络拥塞。</p></li></ul><p>在网络状况不明的情况下，通过缓慢增加发送数据量，可以有效避免因发送方发送速度过快，超出网络承载能力，而导致的网络拥塞。</p><p>虽然慢启动的增长方式看似缓慢，但它能够快速地探测到网络的可用带宽。在网络状况良好时，能迅速增加发送数据量，充分利用网络资源，提高数据传输效率。同时，当网络出现拥塞恢复后，慢启动也能帮助发送方快速恢复到合适的发送速率，尽快恢复数据传输。</p><ol start="3"><li>选择性确认（SACK）</li></ol><p>SACK 机制允许接收方在确认信息中告知发送方哪些数据段已经被正确接收，发送方可以根据这些信息，只重传真正丢失的数据段，避免不必要的重传，从而优化了 RTO 重传算法的性能。</p><p>RTO 重传算法主要关注的是何时触发重传，侧重于解决数据丢失后如何重新发送的问题；而 SACK 机制主要关注的是如何精确地告知发送方哪些数据已经被接收，哪些数据丢失，侧重于提供更详细的接收信息，帮助发送方优化重传策略。</p><h3 id="2-2-细节"><a href="#2-2-细节" class="headerlink" title="2.2 细节"></a>2.2 细节</h3><h4 id="2-2-1-固有字段含义"><a href="#2-2-1-固有字段含义" class="headerlink" title="2.2.1 固有字段含义"></a>2.2.1 固有字段含义</h4><p>根据 TCPSender.hh 的成员变量，我这里做了一份它们的梳理。在这个梳理中，我尽量将我的梳理信息和 2.1 理论知识中的部分挂钩起来，让你可以在拥有理论知识的基础上，</p><h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5><ol><li><strong>以下值会自动初始化，我们只用使用就好</strong>：</li></ol><p>  **<code>WrappingInt32 _isn;</code>**：初始序列号（Initial Sequence Number，ISN），用于 TCP 连接建立时的 SYN 段。<code>WrappingInt32</code> 是 32 位包装类型，处理序列号回绕，ISN 是 TCP 连接发送方首字节相对序列号。</p><p>  **<code>std::queue&lt;TCPSegment&gt; _segments_out;</code>**：待发送的 TCP 段队列。<code>TCPSender</code> 将需发送的 <code>TCPSegment</code> 对象放入此队列，由 <code>TCPConnection</code> 取出并发送。<br>何为发送数据？就是把 segment 放进它就好了。后面我们会详细讲到。</p><p>  **<code>unsigned int _initial_retransmission_timeout;</code>**：连接的初始重传超时时间（Retransmission Timeout，RTO）。段发出后，若在此时长内未收到 ACK 确认，则需重传。</p><p>  **<code>ByteStream _stream;</code>**：待发送的字节流，包含未发送的字节数据。<br><code>TCPSender</code> <strong>从此字节流读取数据封装成 TCP 段发送。</strong></p><ol start="2"><li><strong>以下值需要我们主动更新</strong>：</li></ol><p>  **<code>uint64_t _next_seqno&#123;0&#125;;</code>**：下一个要发送的字节的绝对序列号。每次发送 TCP 段后，<code>_next_seqno</code> 会依段长度更新。</p><p>  **<code>uint64_t _acked_seqno&#123;0&#125;;</code>**：已收到 ACK 确认的最大绝对序列号，用于判断哪些段已被对方成功接收。</p><p>  **<code>uint16_t _window_size&#123;1&#125;;</code>**：接收方的窗口大小，表示接收方当前能接收的字节数，初始值为 1。发送方依此窗口大小决定发送数据量。</p><h5 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h5><ol><li><strong>接收 Ack</strong>：</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">ack_received</span><span class="token punctuation">(</span><span class="token keyword">const</span> WrappingInt32 ackno<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">uint16_t</span> window_size<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>功能</strong>：处理接收到的 ACK 确认，依 ACK 号和窗口大小更新 <code>_acked_seqno</code> 和 <code>_window_size</code> 等相关状态，处理未确认段队列。</p><p>是三大核心实现方法之一。用来确认哪些数据已经被接收，（此时发送方不用再维护这些数据，可以抛弃），如果此时仍然保有未接收到的数据，那么启动定时器。（注意不是触发重传！）</p><ol start="2"><li><strong>发送空 Segment</strong>：</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">send_empty_segment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>功能</strong>：生成空负载的 TCP 段（常用于创建空 ACK 段），放入 <code>_segments_out</code> 队列。</p><p>这个直接实现然后发送就好。</p><ol start="3"><li><strong>填充 Receiver 窗口</strong>：</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">fill_window</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>功能</strong>：创建并发送 TCP 段，尽量填满接收方窗口。从 <code>_stream</code> 读取数据，封装成段发送，直到窗口填满或无更多数据可发。</p><p>这个就是实际上的发送方法。也是三大核心实现方法之一。下面我们会着重介绍。</p><ol start="4"><li><strong>时间流逝</strong>：</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">tick</span><span class="token punctuation">(</span><span class="token keyword">const</span> size_t ms_since_last_tick<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>功能</strong>：通知 <code>TCPSender</code> 时间流逝。依流逝时间更新定时器状态，超时则进行重传操作。</p><p>每隔几毫秒，tick 函数将会被调用，其参数声明了过去的时间，是三大核心实现方法之一。因为时间流逝方法中必然要判断当前是否需要触发重传。一旦我们认为需要重传，那么需要重新给定时器设立新的时间，并且从我们暂存的数据结构体中发送最早进入这个暂存数据结构体中的 Segment。</p><p>为什么要这么绕：直接调用 clock 或者 time 将会导致测试套件不可用。</p><ol start="5"><li><strong>访问方法</strong>：</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">size_t <span class="token function">bytes_in_flight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>功能</strong>：返回<strong>已发送但未确认</strong>的字节数，即 <code>_outstanding_seg</code> 队列中所有段占用的序列号数量。</p><p>方法用 <code>fill_window</code> 发出后，对应的 seqno 没有在 <code>receive_ack</code> 中被接收到。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">consecutive_retransmissions</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>功能</strong>：返回连续重传的次数。</p><ol start="6"><li><strong>序列号方法</strong>：</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">uint64_t</span> <span class="token function">next_seqno_absolute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> _next_seqno<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>WrappingInt32 <span class="token function">next_seqno</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">wrap</span><span class="token punctuation">(</span>_next_seqno<span class="token punctuation">,</span> _isn<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>通过这两个方法，用合适的数据类型返回 <code>_next_seqno</code>。</p><hr><p>通过梳理，我们可以知道，主要的三大功能（发送数据、接收 Ack、超时重传）分别由三个主方法完成。我仍然推荐先思考好这三个方法以外的其它方法如何实现，再去一个个推理三个主方法应该怎么写。</p><h4 id="2-2-2-发送-Segment"><a href="#2-2-2-发送-Segment" class="headerlink" title="2.2.2 发送 Segment"></a>2.2.2 发送 Segment</h4><p>发送数据的核心代码实际上就是它：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 发送数据，segments_out 中的数据被发送出去是调用者做的事情，Sender 无需关心</span><span class="token keyword">this</span><span class="token operator">-></span><span class="token function">segments_out</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>segment_to_send<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>fill_window()</code> 方法中，我们可以梳理出它的主要逻辑：</p><ol><li><p>只要「已经被发送出去」的数据量，小于对面 window_size 就必须一直发送。在这个过程中 <code>this-&gt;bytes_in_flight()</code> 和 window_size 都会动态变化：</p><ul><li>每发送一次，<code>this-&gt;bytes_in_flight()</code> 都会增长，两者确实会一直差距缩小。</li><li>但由于 Sender 同时也在 receive_ack，因此 window_size 也会一直增长。</li><li>他们是一个动态的过程，因此需要使用 while 一直循环，直到 <code>this-&gt;bytes_in_flight()</code> 即已发送的数据足够多，预计可以填满 window_size 才会满足。</li><li>window_size 变为 0 时，Sender 仍然会一直发送，这个我们后面再进行补充。</li></ul></li><li></li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 只要还有「预订要发送」但是这些数据还没填满 Receiver 窗口的空间，就从 _stream 中读取数据，然后发出去</span><span class="token comment">// 要读取到的数据需要充分考虑到 window_size，然后有选择性的读取数据的长度</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-></span><span class="token function">bytes_in_flight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> window_size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    TCPSegment segment_to_send<span class="token punctuation">;</span>    <span class="token comment">// 给 segment_to_send 添加 seqno</span>    segment_to_send<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>seqno <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-></span><span class="token function">next_seqno</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 数据是从 _stream 中读取的</span>    <span class="token keyword">auto</span> payload <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-></span>_stream<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>payload_size<span class="token punctuation">)</span><span class="token punctuation">;</span>    segment_to_send<span class="token punctuation">.</span><span class="token function">payload</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">string</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 发送数据，segments_out 中的数据被发送出去是调用者做的事情，Sender 无需关心</span>    <span class="token keyword">this</span><span class="token operator">-></span><span class="token function">segments_out</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>segment_to_send<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 更新序列号和发出但未 ACK 的字节数</span>    <span class="token keyword">this</span><span class="token operator">-></span>_next_seqno <span class="token operator">+=</span> payload_true_size<span class="token punctuation">;</span>  <span class="token comment">// _next_seqno 是 absolute seqno</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><code>std::queue&lt;std::pair&lt;uint64_t, TCPSegment&gt; &gt; _outstanding_seg;</code></strong></p><p>已发出但未收到 ACK 确认的 TCP 段队列。每个元素是 <code>std::pair</code>，<code>uint64_t</code> 表示段的绝对序列号，<code>TCPSegment</code> 是具体段，用于管理未确认段。</p><p>**<code>bool _has_set_fin_flag&#123;false&#125;;</code>**：是否发送了 FIN 标志位的标志。FIN 标志表示发送方无更多数据要发送，请求关闭连接。发送带 FIN 标志的段后，此标志设为 <code>true</code>。</p><p>**<code>bool _has_set_syn_flag&#123;false&#125;;</code>**：是否发送了 SYN 标志位的标志。SYN 标志用于发起 TCP 连接建立。发送带 SYN 标志的段后，此标志设为 <code>true</code>。</p><h4 id="2-2-3-接收-Ack"><a href="#2-2-3-接收-Ack" class="headerlink" title="2.2.3 接收 Ack"></a>2.2.3 接收 Ack</h4><h4 id="2-2-4-超时重传"><a href="#2-2-4-超时重传" class="headerlink" title="2.2.4 超时重传"></a>2.2.4 超时重传</h4><p>一旦我们认为需要重传，那么需要重新给定时器设立新的时间，并且从我们暂存的数据结构体中发送最早进入这个暂存数据结构体中的 Segment。</p><p>**<code>TCPSenderTimer _timer;</code>**：重传定时器，跟踪每个段的发送时间，超时触发重传操作。</p><p>**<code>uint32_t _consecutive_retransmissions_count&#123;0&#125;;</code>**：连续重传的次数。段重传后仍未收到 ACK 确认，继续重传，此计数器记录连续重传次数，用于调整重传超时时间。</p><h3 id="2-3-边界情况"><a href="#2-3-边界情况" class="headerlink" title="2.3 边界情况"></a>2.3 边界情况</h3><h4 id="2-3-1-Test-语句"><a href="#2-3-1-Test-语句" class="headerlink" title="2.3.1 Test 语句"></a>2.3.1 Test 语句</h4><p><code>send_extra.cc</code> 中，助教给了很多用例。这些用例我认为如果可以在编码之前就看的比较明白，就可以帮助我们节省很多时间，也可以帮我们理解 sender 发挥的作用~</p><p>首先我们需要理解这几个 test 语句：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>ExpectSegment<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">with_no_flags</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">with_syn</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">with_payload_size</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">with_seqno</span><span class="token punctuation">(</span>isn<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>TCPSender 发送 SYN 段（序列号为 isn），无数据负载。</p><p><code>ExpectSegment&#123;&#125;</code> 表示的是当前发送了一个 segment，这个 segment 在这个时候已经被 <code>push</code> 到了 <code>this-&gt;_segments_out</code> 中。 </p><p>它表示当前 sender 发送了一个段。发送了一个 segment。</p><p>后面一系列的 with 方法实际上就是验证当前 segment 的属性是否正确，如果不符合预期则会抛出异常。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>ExpectNoSegment<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同理可得，当前没有 segment 被发送。也就是说，test 无法在 <code>this-&gt;_segments_out</code> 中取到新的 segment。</p><p>这里要额外说明一种情况就是：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>ExpectSegment<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">with_no_flags</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">with_syn</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">with_payload_size</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">with_seqno</span><span class="token punctuation">(</span>isn<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>ExpectNoSegment<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>实际上它表示的就是 segment 从 <code>this-&gt;_segments_out</code> 中被取出来之后，<code>this-&gt;_segments_out</code> 里面就再也没有了其他数据。这种情况下适合检查的是，<code>this-&gt;_segments_out</code> 里面有好几个 segment 要连着发送的情况。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token function">WriteBytes</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>TCPSender 将 <code>&quot;abc&quot;</code> 写入发送缓冲区。它实际上会执行一次 <code>sender.fill_window()</code> 这意味着通过写入缓冲区内的数据可以在这个过程中被立马放入 <code>this-&gt;_segments_out</code>。</p><p><code>sender_harness.cc</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">WriteBytes</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">SenderAction</span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>TCPSender <span class="token operator">&amp;</span>sender<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>queue<span class="token operator">&lt;</span>TCPSegment<span class="token operator">></span> <span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>        sender<span class="token punctuation">.</span><span class="token function">stream_in</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>_bytes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>_end_input<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            sender<span class="token punctuation">.</span><span class="token function">stream_in</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">end_input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        sender<span class="token punctuation">.</span><span class="token function">fill_window</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>Tick<span class="token punctuation">&#123;</span>rto <span class="token operator">-</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>时间流逝 RTO-5 个时间单位，未触发超时。</p><p>Tick 都表示当前时间是逐步在流逝的。测试框架会主动触发时间的流逝这一「行为」。和现实世界中的流逝是毫无关系的。</p><p>一般来说，Tick 常常用于测试重传机制相关的内容。如果有如下过程：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>Tick<span class="token punctuation">&#123;</span>rto <span class="token operator">-</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这表示过了 RTO-5 个时间单位后，再过 6 个时间单位。这其中过了一个 RTO 单位，<strong>一般情况下</strong>会触发重传一次，也会触发一次回退。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>AckReceived<span class="token punctuation">&#123;</span>WrappingInt32<span class="token punctuation">&#123;</span>isn <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">with_win</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接收方确认 SYN，ACK 号为 <code>isn+1</code>（表示期望下一个字节是 <code>isn+1</code>）。</p><p>这表示 sender 接受到了一个 Ack，实际上会执行 <code>this-&gt;ack_received()</code> 方法。z之后也会直接开始执行 <code>sender.fill_window();</code> 方法。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">AckReceived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">SenderAction</span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>TCPSender <span class="token operator">&amp;</span>sender<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>queue<span class="token operator">&lt;</span>TCPSegment<span class="token operator">></span> <span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>        sender<span class="token punctuation">.</span><span class="token function">ack_received</span><span class="token punctuation">(</span>_ackno<span class="token punctuation">,</span> _window_advertisement<span class="token punctuation">.</span><span class="token function">value_or</span><span class="token punctuation">(</span>DEFAULT_TEST_WINDOW<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sender<span class="token punctuation">.</span><span class="token function">fill_window</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>ExpectState<span class="token punctuation">&#123;</span>TCPSenderStateSummary<span class="token double-colon punctuation">::</span>SYN_ACKED<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个就真的是顾名思义了，它需要检查你当前的 sender 处于哪个状态。</p><p>你可以通过 <code>tcp_helpers/tcp_state.cc</code> 来得知 test 框架判断 sender 处于哪个状态的依据。</p><h4 id="2-3-2-初始情况"><a href="#2-3-2-初始情况" class="headerlink" title="2.3.2 初始情况"></a>2.3.2 初始情况</h4><p>一般来说，测试环境都会有一个 SYN —&gt; ACK 的过程，其实就是我们熟悉的三次握手。它大概可以用以下过程来描述：</p><ol><li><p>发送 SYN 段（建立连接）<br>TCPSender 发送 SYN 段（序列号为 isn），无数据负载。</p></li><li><p>接收 SYN-ACK 确认<br>接收方确认 SYN，ACK 号为 isn+1（表示期望下一个字节是 isn+1）。窗口大小设为 1000，允许发送方传输数据。</p></li></ol><p>对应代码为：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>ExpectSegment<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">with_no_flags</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">with_syn</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">with_payload_size</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">with_seqno</span><span class="token punctuation">(</span>isn<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>AckReceived<span class="token punctuation">&#123;</span>WrappingInt32<span class="token punctuation">&#123;</span>isn <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">with_win</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>ExpectState<span class="token punctuation">&#123;</span>TCPSenderStateSummary<span class="token double-colon punctuation">::</span>SYN_ACKED<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="2-3-3-情况-1"><a href="#2-3-3-情况-1" class="headerlink" title="2.3.3 情况 1"></a>2.3.3 情况 1</h4><p>过程描述：<br>验证当 TCPSender 已启动且定时器在运行时，发送新数据段是否会干扰现有定时器。<br>根据测试名称，正确行为是：定时器应继续运行，不会被新发送的段重置，从而保证超时重传的可靠性。</p><p>详细过程：<br>(从初始情况开始)</p><ol><li><p>写入数据 <code>&quot;abc&quot;</code> 并发送</p><ul><li>将 <code>&quot;abc&quot;</code> 写入发送缓冲区。</li><li>发送数据段，序列号为 <code>isn + 1</code>，负载为 3 字节的 <code>&quot;abc&quot;</code>。此时启动重传定时器（RTO 初始值）。</li></ul></li><li><p>时间流逝</p><ul><li>时间流逝 <code>RTO - 5</code> 个时间单位，未触发超时。</li><li>确认没有重传发生，即没有新的数据段被发送。</li></ul></li><li><p>写入新数据 <code>&quot;def&quot;</code> 并发送</p><ul><li>将 <code>&quot;def&quot;</code> 写入发送缓冲区。</li><li>发送新数据段 <code>&quot;def&quot;</code>，序列号从 <code>isn + 1 + 3</code> 开始（这里代码未显式体现序列号，默认按照顺序）。<strong>新数据发送后，原有定时器仍在运行，未被重置。</strong></li></ul></li><li><p>时间流逝</p><ul><li>时间流逝 200 个时间单位，假设 <code>RTO - 5 + 200 &gt; RTO</code>，超过 RTO 触发超时。</li><li>重传最早的未确认段 <code>&quot;abc&quot;</code>，序列号为 <code>isn + 1</code>，证明定时器未被新数据段重置。</li><li>确认没有其他段被发送（如 <code>&quot;def&quot;</code> 尚未超时）。</li></ul></li></ol><p>关键结论：</p><ul><li><strong>定时器独立性</strong>：TCPSender 在发送新数据时，不会重置已有的重传定时器。定时器始终跟踪最早未确认的段（此处为 “abc”）。</li><li><strong>重传优先级</strong>：超时后优先重传最早的未确认数据，确保可靠性，避免旧数据丢失导致传输中断。</li><li><strong>窗口管理与多段处理</strong>：新数据 “def” 在窗口允许下被发送，但其确认与否不影响 “abc” 的定时器逻辑。</li></ul><h4 id="2-3-2-情况-2"><a href="#2-3-2-情况-2" class="headerlink" title="2.3.2 情况 2"></a>2.3.2 情况 2</h4><p><strong>过程描述</strong>：验证 <code>fill_window()</code> 方法是否能正确填充一个较大的窗口。根据测试名称，正确行为是：<code>fill_window()</code> 方法应根据窗口大小和数据量，合理地将数据分段发送，确保每个数据段的大小符合配置要求，且序列号连续，以充分利用窗口空间。</p><p>这个过程比较清晰的描述了一次 <code>fill_window()</code> 最大可发送量为：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> size_t expected_size <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>TCPConfig<span class="token double-colon punctuation">::</span>MAX_PAYLOAD_SIZE<span class="token punctuation">,</span> <span class="token function">min</span><span class="token punctuation">(</span>bigstring<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> window_size<span class="token punctuation">)</span> <span class="token operator">-</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>假设此时发送端缓冲区很长，超出 expected_size 的部分仍然不能发送。</p><p><strong>详细过程</strong>：<br>(从初始情况开始)</p><ol><li><strong>循环发送数据段</strong>：<ul><li>开始一个循环，循环条件是 <code>i + TCPConfig::MAX_PAYLOAD_SIZE &lt; min(bigstring.size(), window_size)</code>，其中 <code>i</code> 是当前已经处理的数据偏移量。</li><li>在每次循环中，计算期望的数据段大小 <code>expected_size</code>，取 <code>TCPConfig::MAX_PAYLOAD_SIZE</code> 和剩余可发送数据量（<code>min(bigstring.size(), window_size) - i</code>）中的较小值。</li><li>发送一个数据段，该数据段没有额外标志，负载大小为 <code>expected_size</code>，数据为 <code>bigstring</code> 从偏移量 <code>i</code> 开始长度为 <code>expected_size</code> 的子串，序列号为 <code>isn + 1 + i</code>。</li></ul></li></ol><p><strong>关键结论</strong>：</p><ul><li><strong>窗口填充正确性</strong>：<code>fill_window()</code> 方法能够根据窗口大小和数据量，正确地将数据分段发送，确保每个数据段的大小不超过配置的最大负载大小，充分利用了窗口空间。</li><li><strong>序列号连续性</strong>：每个数据段的序列号是连续的，保证了接收方能够正确地按顺序接收和重组数据，维护了数据传输的有序性。</li><li><strong>数据完整性</strong>：通过循环发送数据段，将整个 <code>bigstring</code> 数据按要求分段发送，确保了数据的完整性，避免了数据丢失或错误传输。</li></ul><h4 id="2-3-3-情况-3"><a href="#2-3-3-情况-3" class="headerlink" title="2.3.3 情况 3"></a>2.3.3 情况 3</h4><p>一句话：FIN 和 SYN 标志位都同样需要重传机制。含有 FIN 标志位的 segment 中，无论是否携带了其它数据，也都需要有重传机制。</p><p><strong>过程描述</strong>：验证包含 FIN 标志的数据段是否能像其他数据段一样进行重传。根据测试名称，正确行为是：当包含 FIN 标志的数据段未被确认且超时发生时，应像普通数据段一样进行重传，以确保连接的正常关闭。</p><p><strong>详细过程</strong>：<br>(从初始情况开始)</p><ol><li><strong>写入数据并发送含 FIN 的数据段</strong>：<ul><li>将 <code>&quot;abc&quot;</code> 写入发送缓冲区，并标记输入结束（<code>with_end_input(true)</code>）。</li><li>发送一个数据段，负载为 3 字节的 <code>&quot;abc&quot;</code>，序列号为 <code>isn + 1</code>，同时带有 FIN 标志，表示连接关闭请求。</li></ul></li><li><strong>时间流逝（未触发超时）</strong>：<ul><li>时间流逝 <code>RTO - 1</code> 个时间单位，未触发超时。</li><li>确认没有重传发生，即没有新的数据段被发送。</li></ul></li><li><strong>时间继续流逝（触发超时）</strong>：<ul><li>时间再流逝 2 个时间单位，此时总时间超过了 RTO，触发超时。</li><li>重传之前带有 FIN 标志的数据段，负载为 3 字节的 <code>&quot;abc&quot;</code>，序列号为 <code>isn + 1</code>，FIN 标志保持为 <code>true</code>。</li></ul></li></ol><p><strong>关键结论</strong>：</p><ul><li><strong>FIN 段重传机制</strong>：包含 FIN 标志的数据段在未被确认且超时发生时，会像普通数据段一样进行重传。这确保了即使在连接关闭阶段，数据的可靠传输也能得到保障。</li><li><strong>可靠性保障</strong>：通过重传 FIN 段，保证了连接关闭请求能够被接收方正确收到，避免因丢包导致连接无法正常关闭，维护了 TCP 连接的可靠性。</li><li><strong>定时器一致性</strong>：对包含 FIN 标志的数据段使用与普通数据段相同的定时器和重传逻辑，体现了 TCPSender 重传机制的一致性和稳定性。</li></ul><h4 id="2-3-4-情况-4"><a href="#2-3-4-情况-4" class="headerlink" title="2.3.4 情况 4"></a>2.3.4 情况 4</h4><p>什么情况下需要添加 FIN 标志位？</p><p><strong>过程描述</strong>：<br>验证在发送数据段时，如果添加 FIN 标志会使数据段超出接收方窗口大小，是否不会添加 FIN 标志。根据测试名称，正确行为是：当添加 FIN 标志会导致数据段大小超过接收方窗口时，不添加 FIN 标志，直到窗口大小足够容纳含 FIN 标志的数据段。<br>验证当接收方窗口已满时，是否不会单独发送仅含 FIN 标志的数据段。根据测试名称，正确行为是：在窗口空间不足的情况下，不会单独发送 FIN 段，直到窗口有足够空间，以保证数据传输的合理性和可靠性。</p><p><strong>详细过程 1</strong>：<br>(从初始情况开始)</p><ol><li><strong>写入数据并准备关闭连接</strong>：<ul><li>将 <code>&quot;abc&quot;</code> 写入发送缓冲区，并标记输入结束（<code>with_end_input(true)</code>），表示有关闭连接的需求（即要添加 FIN 标志）。</li></ul></li><li><strong>接收 ACK 并发送普通数据段</strong>：<ul><li>模拟接收到对 SYN 段的 ACK，确认号为 <code>isn + 1</code>，窗口大小为 3。</li><li>发送一个数据段，负载为 3 字节的 <code>&quot;abc&quot;</code>，序列号为 <code>isn + 1</code>，无 FIN 标志，因为此时添加 FIN 可能会使数据段超出窗口大小。</li></ul></li><li><strong>多次接收 ACK 但不发送新段</strong>：<ul><li>模拟接收到确认号为 <code>isn + 2</code>，窗口大小为 2 的 ACK，此时窗口大小不足以添加 FIN 标志，确认没有新的数据段被发送。</li><li>模拟接收到确认号为 <code>isn + 3</code>，窗口大小为 1 的 ACK，同样窗口大小不够，确认没有新的数据段被发送。</li></ul></li><li><strong>接收合适 ACK 并发送含 FIN 段</strong>：<ul><li>模拟接收到确认号为 <code>isn + 4</code>，窗口大小为 1 的 ACK，此时窗口大小足够容纳一个仅含 FIN 标志（无数据负载）的数据段。</li><li>发送一个仅含 FIN 标志、无数据负载的数据段，序列号为 <code>isn + 4</code>。</li></ul></li></ol><p><strong>详细过程 2</strong>：<br>(从初始情况开始)</p><ol><li><strong>写入数据但不发送</strong>：<ul><li>将 <code>&quot;abc&quot;</code> 写入发送缓冲区，但由于此时还未收到合适的 ACK 来确定窗口大小，所以没有数据段被发送。</li></ul></li><li><strong>接收 ACK 并发送普通数据段</strong>：<ul><li>模拟接收到对 SYN 段的 ACK，确认号为 <code>isn + 1</code>，窗口大小为 3。</li><li>检查 TCPSender 状态，期望状态为 <code>SYN_ACKED</code>。</li><li>发送一个数据段，负载为 3 字节的 <code>&quot;abc&quot;</code>，序列号为 <code>isn + 1</code>，无特殊标志。</li></ul></li><li><strong>请求关闭连接但不发送 FIN 段</strong>：<ul><li>调用 <code>Close</code> 操作，表示要关闭连接，即需要发送含 FIN 标志的数据段。</li><li>但由于此时窗口空间可能不足以单独发送 FIN 段，确认没有新的数据段被发送。</li></ul></li><li><strong>多次接收 ACK 仍不发送 FIN 段</strong>：<ul><li>模拟接收到确认号为 <code>isn + 2</code>，窗口大小为 2 的 ACK，窗口空间仍不足，确认没有新的数据段被发送。</li><li>模拟接收到确认号为 <code>isn + 3</code>，窗口大小为 1 的 ACK，窗口空间还是不足，确认没有新的数据段被发送。</li></ul></li><li><strong>接收合适 ACK 并发送含 FIN 段</strong>：<ul><li>模拟接收到确认号为 <code>isn + 4</code>，窗口大小为 1 的 ACK，此时窗口有足够空间容纳一个仅含 FIN 标志（无数据负载）的数据段。</li><li>发送一个仅含 FIN 标志、无数据负载的数据段，序列号为 <code>isn + 4</code>。</li></ul></li></ol><p><strong>关键结论</strong>：</p><ul><li><strong>窗口限制机制</strong>：TCPSender 会根据接收方的窗口大小来决定是否添加 FIN 标志。当添加 FIN 会使数据段超出窗口大小时，会等待窗口大小足够，体现了窗口管理对数据段发送的限制作用。</li><li><strong>窗口限制下的 FIN 发送策略</strong>：TCPSender 会根据接收方的窗口大小来决定是否单独发送 FIN 段。当窗口已满或空间不足时，不会单独发送 FIN 段，避免不必要的数据段发送，体现了窗口管理对数据传输的控制作用。</li><li><strong>可靠性与效率平衡</strong>：通过不添加 FIN 避免数据段溢出窗口，保证了数据传输的可靠性，同时在窗口允许时及时发送含 FIN 段，实现了连接关闭的高效性。</li><li><strong>ACK 与窗口管理协同</strong>：ACK 的接收不仅更新了确认号，还影响了窗口大小，从而决定了数据段的发送策略，体现了 ACK 处理与窗口管理的协同工作。</li></ul><h4 id="2-3-5-情况-5"><a href="#2-3-5-情况-5" class="headerlink" title="2.3.5 情况 5"></a>2.3.5 情况 5</h4><p><code>TCPConfig::MAX_PAYLOAD_SIZE</code> 仅对数据段的负载部分起限制作用，SYN 和 FIN 标志不受此限制。以确保数据段的正常发送和连接的正确关闭。</p><p><strong>过程描述</strong>：验证 <code>MAX_PAYLOAD_SIZE</code> 仅对数据段的负载部分起限制作用。根据测试名称，正确行为是：在发送数据段时，数据段的负载大小应受 <code>MAX_PAYLOAD_SIZE</code> 限制，但其他标志（如 FIN 标志）不受此限制，以确保数据段的正常发送和连接的正确关闭。</p><p><strong>详细过程</strong>：<br>(从初始情况开始)</p><ol><li><strong>写入大量数据并准备关闭连接</strong>：<ul><li>将一个较大的字符串 <code>bigstring</code> 写入发送缓冲区，并标记输入结束（<code>with_end_input(true)</code>），表示要关闭连接（添加 FIN 标志）。</li></ul></li><li><strong>接收 ACK 并发送数据段</strong>：<ul><li>模拟接收到对 SYN 段的 ACK，确认号为 <code>isn + 1</code>，窗口大小为 40000。</li><li>发送一个数据段，负载大小为 <code>TCPConfig::MAX_PAYLOAD_SIZE</code>，数据为 <code>bigstring</code>，序列号为 <code>isn + 1</code>，同时带有 FIN 标志。这表明即使数据量较大，但负载大小被 <code>MAX_PAYLOAD_SIZE</code> 限制，而 FIN 标志正常添加。</li></ul></li><li><strong>检查状态</strong>：<ul><li>检查 TCPSender 状态，期望状态为 <code>FIN_SENT</code>，确认包含 FIN 标志的数据段已成功发送。</li></ul></li><li><strong>接收 ACK 并再次检查状态</strong>：<ul><li>模拟接收到确认号为 <code>isn + 2 + TCPConfig::MAX_PAYLOAD_SIZE</code> 的 ACK。</li><li>检查 TCPSender 状态，期望状态为 <code>FIN_ACKED</code>，确认包含 FIN 标志的数据段已被正确确认，连接关闭流程正常完成。</li></ul></li></ol><p><strong>关键结论</strong>：</p><ul><li><strong><code>MAX_PAYLOAD_SIZE</code> 限制作用</strong>：<code>MAX_PAYLOAD_SIZE</code> 仅对数据段的负载部分起限制作用，确保负载大小不会超过设定值，维护了数据段的合理大小。</li><li><strong>标志独立性</strong>：FIN 标志等控制标志不受 <code>MAX_PAYLOAD_SIZE</code> 的限制，可以正常添加到数据段中，保证了连接关闭等控制功能的正常实现。</li><li><strong>状态转换正确性</strong>：通过正确的 ACK 接收和状态检查，验证了 TCPSender 在发送和确认含 FIN 标志数据段过程中的状态转换是正确的，确保了连接管理的可靠性。</li></ul><h4 id="2-3-6-情况-6"><a href="#2-3-6-情况-6" class="headerlink" title="2.3.6 情况 6"></a>2.3.6 情况 6</h4><p>验证在填充窗口时，将窗口大小为 <code>0</code> 的情况视为窗口大小为 <code>1</code> 进行处理。</p><p><strong>过程描述</strong>：验证在填充窗口时，将窗口大小为 <code>0</code> 的情况视为窗口大小为 <code>1</code> 进行处理，同时不进行重传超时时间（RTO）的回退操作。根据测试名称，正确行为是：当窗口大小为 <code>0</code> 时，仍能按顺序发送数据段，且每次超时后重传未确认的数据段，RTO 保持不变。</p><p>但是，非 0 窗口则需要严格限制，一旦 flight 中的 data 容量大于窗口容量，这个时候必须处于停止发送的状态中。</p><p><strong>详细过程</strong>：<br>(从初始情况开始)</p><ol><li><strong>接收窗口大小为 0 的 ACK 并发送数据段</strong>：<ul><li>模拟接收到对 SYN 段的 ACK，确认号为 <code>isn + 1</code>，窗口大小为 <code>0</code>。</li><li>检查 TCPSender 状态，期望状态为 <code>SYN_ACKED</code>。</li><li>发送一个负载大小为 1 字节、数据为 <code>&quot;a&quot;</code>、序列号为 <code>isn + 1</code> 的数据段，无其他特殊标志，体现了将窗口大小 <code>0</code> 视为 <code>1</code> 来发送数据。</li></ul></li><li><strong>请求关闭连接但不发送新段</strong>：<ul><li>调用 <code>Close</code> 操作，表示要关闭连接，但由于窗口大小限制，此时没有新的数据段被发送。</li></ul></li><li><strong>对 <code>&quot;a&quot;</code> 数据段进行多次超时重传</strong>：<ul><li>进行 5 次循环，每次先让时间流逝 <code>RTO - 1</code> 个时间单位，期间没有数据段发送。</li><li>再让时间流逝 1 个时间单位，触发超时，重传负载为 <code>&quot;a&quot;</code>、序列号为 <code>isn + 1</code> 的数据段，且每次重传的 RTO 没有回退。</li></ul></li><li><strong>接收新 ACK 并发送 <code>&quot;b&quot;</code> 数据段及重传</strong>：<ul><li>模拟接收到确认号为 <code>isn + 2</code>、窗口大小为 <code>0</code> 的 ACK。</li><li>发送一个负载大小为 1 字节、数据为 <code>&quot;b&quot;</code>、序列号为 <code>isn + 2</code> 的数据段。</li><li>同样进行 5 次循环，每次先让时间流逝 <code>RTO - 1</code> 个时间单位，无数据段发送，再流逝 1 个时间单位触发超时，重传 <code>&quot;b&quot;</code> 数据段，RTO 保持不变。</li></ul></li><li><strong>接收新 ACK 并发送 <code>&quot;c&quot;</code> 数据段及重传</strong>：<ul><li>模拟接收到确认号为 <code>isn + 3</code>、窗口大小为 <code>0</code> 的 ACK。</li><li>发送一个负载大小为 1 字节、数据为 <code>&quot;c&quot;</code>、序列号为 <code>isn + 3</code> 的数据段。</li><li>进行 5 次循环，每次先让时间流逝 <code>RTO - 1</code> 个时间单位，无数据段发送，再流逝 1 个时间单位触发超时，重传 <code>&quot;c&quot;</code> 数据段，RTO 不回退。</li></ul></li><li><strong>接收新 ACK 并发送含 FIN 段及重传</strong>：<ul><li>模拟接收到确认号为 <code>isn + 4</code>、窗口大小为 <code>0</code> 的 ACK。</li><li>发送一个负载大小为 0 字节、序列号为 <code>isn + 4</code>、带有 FIN 标志的数据段。</li><li>进行 5 次循环，每次先让时间流逝 <code>RTO - 1</code> 个时间单位，无数据段发送，再流逝 1 个时间单位触发超时，重传含 FIN 标志的数据段，RTO 保持不变。</li></ul></li></ol><p><strong>关键结论</strong>：</p><ul><li><strong>窗口大小处理策略</strong>：当接收方窗口大小为 <code>0</code> 时，TCPSender 将其视为窗口大小为 <code>1</code> 来处理，能够按顺序发送数据段，保证了数据的持续传输。</li><li><strong>RTO 稳定性</strong>：在多次超时重传过程中，RTO 没有进行回退操作，保持了定时器的稳定性，确保了重传机制的可靠性。</li><li><strong>数据和控制信息传输</strong>：无论是普通数据段（如 <code>&quot;a&quot;</code>、<code>&quot;b&quot;</code>、<code>&quot;c&quot;</code>）还是含 FIN 标志的控制数据段，都能在窗口大小为 <code>0</code> 的情况下正常发送和重传，保证了数据和连接管理的正常进行。</li></ul><h4 id="2-3-7-情况-7"><a href="#2-3-7-情况-7" class="headerlink" title="2.3.7 情况 7"></a>2.3.7 情况 7</h4><p><strong>过程描述</strong>：验证重复的 ACK 和过时的 ACK 对 TCPSender 的正常工作没有影响。根据测试名称，正确行为是：发送方在接收到重复或过时的 ACK 时，不会产生异常行为，仍能按照正常逻辑处理数据发送和连接关闭操作。</p><p><strong>详细过程</strong>：<br>(从初始情况开始)</p><ol><li><strong>写入数据并发送数据段</strong>：<ul><li>将 <code>&quot;abcdefg&quot;</code> 写入发送缓冲区。</li><li>发送一个负载大小为 7 字节、数据为 <code>&quot;abcdefg&quot;</code>、序列号为 <code>isn + 1</code> 的数据段。</li></ul></li><li><strong>接收正确 ACK 及重复 ACK</strong>：<ul><li>模拟接收到确认号为 <code>isn + 8</code> 的 ACK，窗口大小为 1000，表明 <code>&quot;abcdefg&quot;</code> 已被正确接收。</li><li>多次重复接收确认号为 <code>isn + 8</code> 的 ACK，期间没有新的数据段被发送，确认重复 ACK 不影响发送方。</li></ul></li><li><strong>接收过时 ACK</strong>：<ul><li>多次接收确认号为 <code>isn + 1</code> 的过时 ACK，没有新的数据段被发送，说明过时 ACK 不会干扰发送方的正常状态。</li></ul></li><li><strong>写入新数据并发送含 FIN 段</strong>：<ul><li>将 <code>&quot;ijkl&quot;</code> 写入发送缓冲区，并标记输入结束（<code>with_end_input(true)</code>）。</li><li>发送一个负载大小为 4 字节、数据为 <code>&quot;ijkl&quot;</code>、序列号为 <code>isn + 8</code> 且带有 FIN 标志的数据段。</li></ul></li><li><strong>多次接收各种 ACK</strong>：<ul><li>多次接收确认号为 <code>isn + 1</code>、<code>isn + 8</code>、<code>isn + 12</code> 的 ACK，包括重复和过时的 ACK，发送方未产生异常。</li></ul></li><li><strong>超时重传</strong>：<ul><li>时间流逝 <code>5 * RTO</code>，触发超时，重传负载为 <code>&quot;ijkl&quot;</code>、序列号为 <code>isn + 8</code> 且带有 FIN 标志的数据段。</li><li>之后确认没有新的数据段被发送。</li></ul></li><li><strong>接收最终 ACK 并检查状态</strong>：<ul><li>模拟接收到确认号为 <code>isn + 13</code> 的 ACK，以及再次接收确认号为 <code>isn + 1</code> 的过时 ACK。</li><li>时间流逝 <code>5 * RTO</code>，没有新的数据段被发送。</li><li>检查 TCPSender 状态，期望状态为 <code>FIN_ACKED</code>，确认连接正常关闭。</li></ul></li></ol><blockquote><p>多次接收确认号为 <code>isn + 1</code>、<code>isn + 8</code>、<code>isn + 12</code> 的 ACK，包括重复和过时的 ACK，发送方未产生异常。如何验证？</p></blockquote><ol><li>多次接收确认号为 <code>isn + 8</code> 的 ACK 时的验证</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>AckReceived<span class="token punctuation">&#123;</span>WrappingInt32<span class="token punctuation">&#123;</span>isn <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">with_win</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>ExpectNoSegment<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>AckReceived<span class="token punctuation">&#123;</span>WrappingInt32<span class="token punctuation">&#123;</span>isn <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">with_win</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>AckReceived<span class="token punctuation">&#123;</span>WrappingInt32<span class="token punctuation">&#123;</span>isn <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">with_win</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>AckReceived<span class="token punctuation">&#123;</span>WrappingInt32<span class="token punctuation">&#123;</span>isn <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">with_win</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>ExpectNoSegment<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里先接收了一次确认号为 <code>isn + 8</code> 的 ACK，然后使用 <code>ExpectNoSegment&#123;&#125;</code> 确认没有新的数据段被发送。之后又多次接收确认号为 <code>isn + 8</code> 的 ACK，最后再次使用 <code>ExpectNoSegment&#123;&#125;</code> 确认在这一系列重复 ACK 接收过程中没有异常的数据段发送。</p><ol start="2"><li>多次接收确认号为 <code>isn + 1</code> 的 ACK 时的验证</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>AckReceived<span class="token punctuation">&#123;</span>WrappingInt32<span class="token punctuation">&#123;</span>isn <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">with_win</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>AckReceived<span class="token punctuation">&#123;</span>WrappingInt32<span class="token punctuation">&#123;</span>isn <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">with_win</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>AckReceived<span class="token punctuation">&#123;</span>WrappingInt32<span class="token punctuation">&#123;</span>isn <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">with_win</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>ExpectNoSegment<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这里多次接收确认号为 <code>isn + 1</code> 的过时 ACK，最后使用 <code>ExpectNoSegment&#123;&#125;</code> 确认在接收这些过时 ACK 期间没有异常的数据段发送。</p><ol start="3"><li>后续多次接收不同 ACK 时的验证</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>AckReceived<span class="token punctuation">&#123;</span>WrappingInt32<span class="token punctuation">&#123;</span>isn <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">with_win</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>AckReceived<span class="token punctuation">&#123;</span>WrappingInt32<span class="token punctuation">&#123;</span>isn <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">with_win</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>AckReceived<span class="token punctuation">&#123;</span>WrappingInt32<span class="token punctuation">&#123;</span>isn <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">with_win</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>AckReceived<span class="token punctuation">&#123;</span>WrappingInt32<span class="token punctuation">&#123;</span>isn <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">with_win</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>AckReceived<span class="token punctuation">&#123;</span>WrappingInt32<span class="token punctuation">&#123;</span>isn <span class="token operator">+</span> <span class="token number">12</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">with_win</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>AckReceived<span class="token punctuation">&#123;</span>WrappingInt32<span class="token punctuation">&#123;</span>isn <span class="token operator">+</span> <span class="token number">12</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">with_win</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>AckReceived<span class="token punctuation">&#123;</span>WrappingInt32<span class="token punctuation">&#123;</span>isn <span class="token operator">+</span> <span class="token number">12</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">with_win</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>AckReceived<span class="token punctuation">&#123;</span>WrappingInt32<span class="token punctuation">&#123;</span>isn <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">with_win</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 这里虽然没有紧跟 ExpectNoSegment&#123;&#125;，但后续通过超时重传等操作的正常执行也侧面验证没有异常</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这一系列多次接收不同确认号（包括重复和过时的）的 ACK 过程中，后续代码里的超时重传等操作正常执行，也从侧面验证了发送方在接收这些 ACK 时没有产生异常。例如后续的超时重传：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>Tick<span class="token punctuation">&#123;</span><span class="token number">5</span> <span class="token operator">*</span> rto<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>ExpectSegment<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">with_payload_size</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">with_data</span><span class="token punctuation">(</span><span class="token string">"ijkl"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">with_seqno</span><span class="token punctuation">(</span>isn <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">with_fin</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>ExpectNoSegment<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果在接收那些 ACK 时发送方产生了异常，这里的超时重传可能就无法正常执行。</p><p>综上所述，通过 <code>ExpectNoSegment&#123;&#125;</code> 以及后续操作的正常执行，验证了发送方在接收多次 ACK（包括重复和过时的 ACK）时未产生异常。 </p><p><strong>关键结论</strong>：</p><ul><li><strong>ACK 处理的健壮性</strong>：TCPSender 能够正确处理重复的 ACK 和过时的 ACK，不会因为这些异常 ACK 而产生错误的行为，保证了系统的健壮性。</li><li><strong>重传机制正常</strong>：在超时情况下，发送方能够正常重传未确认的数据段，确保了数据传输的可靠性。</li><li><strong>连接关闭正常</strong>：即使在接收到各种异常 ACK 的情况下，发送方仍能正确处理连接关闭请求，最终达到 <code>FIN_ACKED</code> 状态，完成连接的正常关闭。</li></ul><h3 id="2-4-具体实现"><a href="#2-4-具体实现" class="headerlink" title="2.4 具体实现"></a>2.4 具体实现</h3><p>我的具体实现基本上借鉴了大佬的实现… 所以思路看上去很像那确实是我太菜了。</p><p><code>fill_window()</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">TCPSender</span><span class="token double-colon punctuation">::</span><span class="token function">fill_window</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-></span>_has_set_fin_flag<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 为防止死锁，发送数据的时候即便对面窗口为 0，也至少发送 1 单位的数据</span>    <span class="token keyword">auto</span> window_size <span class="token operator">=</span> <span class="token generic-function"><span class="token function">max</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">uint16_t</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token operator">-></span>_window_size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 只要还有「预订要发送」但是这些数据还没填满 Receiver 窗口的空间，就从 _stream 中读取数据，然后发出去</span>    <span class="token comment">// 要读取到的数据需要充分考虑到 window_size，然后有选择性的读取数据的长度</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-></span><span class="token function">bytes_in_flight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> window_size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        TCPSegment segment_to_send<span class="token punctuation">;</span>        <span class="token comment">// 给 segment_to_send 添加 seqno</span>        segment_to_send<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>seqno <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-></span><span class="token function">next_seqno</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token operator">-></span>_has_set_syn_flag<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            segment_to_send<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>syn <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token operator">-></span>_has_set_syn_flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// MAX_PAYLOAD_SIZE 只限制字符串长度并不包括 SYN 和 FIN，但是 window_size 包括 SYN 和 FIN</span>        <span class="token keyword">auto</span> payload_size <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>TCPConfig<span class="token double-colon punctuation">::</span>MAX_PAYLOAD_SIZE<span class="token punctuation">,</span>                                <span class="token function">min</span><span class="token punctuation">(</span>window_size <span class="token operator">-</span> <span class="token keyword">this</span><span class="token operator">-></span><span class="token function">bytes_in_flight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> segment_to_send<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>syn<span class="token punctuation">,</span>                                    <span class="token keyword">this</span><span class="token operator">-></span>_stream<span class="token punctuation">.</span><span class="token function">buffer_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 数据是从 _stream 中读取的</span>        <span class="token keyword">auto</span> payload <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-></span>_stream<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>payload_size<span class="token punctuation">)</span><span class="token punctuation">;</span>        segment_to_send<span class="token punctuation">.</span><span class="token function">payload</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">string</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 如果读到 EOF 了且 window_size 还有空位，那就把 fin 给放进去</span>        <span class="token comment">// 注意这里有一个细节，那就是这里不需要检查 TCPConfig::MAX_PAYLOAD_SIZE，因为即便是它满了，那也可以放入 FIN</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token operator">-></span>_has_set_fin_flag <span class="token operator">&amp;&amp;</span> _stream<span class="token punctuation">.</span><span class="token function">eof</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>            <span class="token keyword">this</span><span class="token operator">-></span><span class="token function">bytes_in_flight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> segment_to_send<span class="token punctuation">.</span><span class="token function">length_in_sequence_space</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> window_size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            segment_to_send<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>fin <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token operator">-></span>_has_set_fin_flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// payload_true_size 包含了 fin 和 syn 后的大小</span>        <span class="token keyword">uint64_t</span> payload_true_size <span class="token operator">=</span> segment_to_send<span class="token punctuation">.</span><span class="token function">length_in_sequence_space</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 空数据报就不发送了</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>payload_true_size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 发送数据，segments_out 中的数据被发送出去是调用者做的事情，Sender 无需关心</span>        <span class="token keyword">this</span><span class="token operator">-></span><span class="token function">segments_out</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>segment_to_send<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 如果定时器关闭，则启动定时器</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token operator">-></span>_timer<span class="token punctuation">.</span><span class="token function">is_running</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token operator">-></span>_timer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 保存备份，重发时可能会用</span>        <span class="token keyword">this</span><span class="token operator">-></span>_outstanding_seg<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-></span>_next_seqno<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>segment_to_send<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 更新序列号和发出但未 ACK 的字节数</span>        <span class="token keyword">this</span><span class="token operator">-></span>_next_seqno <span class="token operator">+=</span> payload_true_size<span class="token punctuation">;</span>  <span class="token comment">// _next_seqno 是 absolute seqno</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>ack_received()</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">TCPSender</span><span class="token double-colon punctuation">::</span><span class="token function">ack_received</span><span class="token punctuation">(</span><span class="token keyword">const</span> WrappingInt32 ackno<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">uint16_t</span> window_size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 和接收方原理一样，checkpoint 为 next_seqno_absolute</span>    <span class="token keyword">auto</span> abs_ackno <span class="token operator">=</span> <span class="token function">unwrap</span><span class="token punctuation">(</span>ackno<span class="token punctuation">,</span> _isn<span class="token punctuation">,</span> <span class="token function">next_seqno_absolute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 传入的 ACK 是不可靠的，直接丢弃</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>abs_ackno <span class="token operator">></span> <span class="token keyword">this</span><span class="token operator">-></span><span class="token function">next_seqno_absolute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 在接受到 ack 的时候如果收到窗口为 0，窗口大小发送方仍将其视为 1，允许发送 1 字节的数据。</span>    <span class="token comment">// 但是这个时候，未采用 TCP 标准的 指数退避策略（即 RTO 不翻倍）</span>    <span class="token keyword">this</span><span class="token operator">-></span>_window_size <span class="token operator">=</span> window_size<span class="token punctuation">;</span>    <span class="token comment">// 用于标记是否有 segment 是否成功</span>    <span class="token keyword">bool</span> some_seg_ack_successful <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token comment">// 处理已经收到的包（序列号空间要小于 ACK）</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token operator">-></span>_outstanding_seg<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">auto</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span>abs_seq<span class="token punctuation">,</span> segment<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-></span>_outstanding_seg<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>abs_seq <span class="token operator">+</span> segment<span class="token punctuation">.</span><span class="token function">length_in_sequence_space</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&lt;</span> abs_ackno<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            some_seg_ack_successful <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token operator">-></span>_acked_seqno <span class="token operator">+=</span> segment<span class="token punctuation">.</span><span class="token function">length_in_sequence_space</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token operator">-></span>_outstanding_seg<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 有成功 ACK 的包，则重置定时器（触发 RTO），清零连续重传次数</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>some_seg_ack_successful<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token operator">-></span>_consecutive_retransmissions_count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token operator">-></span>_timer<span class="token punctuation">.</span><span class="token function">set_time_out</span><span class="token punctuation">(</span>_initial_retransmission_timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token operator">-></span>_timer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 没有等待 ACK 的包了，则关闭定时器</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-></span><span class="token function">bytes_in_flight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token operator">-></span>_timer<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 尝试继续填满窗口发送</span>    <span class="token function">fill_window</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Timer 类则是完全照搬，这里不再做赘述。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="装逼" scheme="https://blog.pengdonglai.com/categories/%E8%A3%85%E9%80%BC/"/>
    
    <category term="CS144" scheme="https://blog.pengdonglai.com/categories/%E8%A3%85%E9%80%BC/CS144/"/>
    
    
    <category term="Network" scheme="https://blog.pengdonglai.com/tags/Network/"/>
    
    <category term="Lab" scheme="https://blog.pengdonglai.com/tags/Lab/"/>
    
  </entry>
  
  <entry>
    <title>CS144 Lab（1）：启动</title>
    <link href="https://blog.pengdonglai.com/2025/02/04/stanford-cs144/"/>
    <id>https://blog.pengdonglai.com/2025/02/04/stanford-cs144/</id>
    <published>2025-02-04T07:32:28.000Z</published>
    <updated>2025-02-15T05:53:35.336Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>CS144 是斯坦福大学的经典计算机网络课程（全称 Introduction to Computer Networks）以动手实现网络协议著称，实验项目包括：</p><ol><li><p>网络调试工具：使用 <code>tcpdump</code> 和 <code>Wireshark</code> 分析网络流量。</p></li><li><p>可靠数据传输协议：实现滑动窗口协议（类似 TCP 的简化版）。</p></li><li><p>路由协议模拟：编写路由算法模拟器（如距离向量算法）。</p></li><li><p>完整 TCP 协议栈：在用户态实现 TCP 的可靠传输、拥塞控制等功能，与真实操作系统协议栈交互。</p></li></ol><p>CS144 的 Lab 截止 2025 年初有两个大版本，一个是 Sponge 版本，一个是 Minnow，Sponge 是旧版本，也就是所谓「8 个 Project 带你实现整个 TCP&#x2F;IP 协议栈」的版本。而 Minnow 是 2023 年春季新上线的版本。</p><p>课程主页: <a href="https://cs144.github.io/">https://cs144.github.io/</a></p><p>GitHub: <a href="https://github.com/CS144/minnow">https://github.com/CS144/minnow</a></p><p>24 Winter 的课程主页 (archived by Wayback Machine): <a href="https://web.archive.org/web/20241209004804/https://cs144.github.io/">https://web.archive.org/web/20241209004804/https://cs144.github.io/</a></p><h3 id="0-1-准备条件"><a href="#0-1-准备条件" class="headerlink" title="0.1 准备条件"></a>0.1 准备条件</h3><ul><li><p>对于 C++ 的要求：非常适合 C++ 初学者来学，不需要你会写很「艰深&#x2F;炫酷」的魔法代码，你只需要稍微在你已经知道的语法基础上再学一点点，就可以完成所有的 labs。当然 0 小白肯定是完全不行，至少得会 C++ 语法，然后让你写几个 LeetCode 啥的应该也得要是会的。</p><ul><li><p>你应当具备一定的调试代码的能力。在这个 lab 中，能一次性写对这几个方法的人少之又少，因此调试就成了必不可少的一环。本文档也会介绍一下 Clion 环境下如何对这个项目进行断点调试。如果觉得断点调试有难度，也可以通过打印 log 来调试。</p></li><li><p>不止一个朋友反映这个 lab 的单元测试给的不够。一旦 lab1-2 有边界条件没有考虑好，会严重影响到 lab3-4 的开发体验——不少朋友发现 3-4 无法编译通过其实出在 lab1-2 的内容没有写好导致。因此，适当补充 lab1-2 模块的单元测试很重要，并且你也要知道单元测试的基本概念，以及 C++ 下怎么玩转它们。</p></li></ul></li><li><p>对于计算机网络的要求：强烈建议学完《自顶向下》这本书后再来做这个 lab。虽然说对于大神自然是不需要，但是有了理论基础后，再来做可以大幅缩减「抽象感」——至少你会明白你在做什么。</p></li><li><p>对于 Linux 基本功的要求：Git、至少你得操作过 Linux 命令行。这方面如果经验为 0 则会被搭建环境那一步就劝退了。虽然这种状况下确实也还是能读代码，但是会少了自己参与实现的乐趣。</p></li></ul><h2 id="lab0：热身"><a href="#lab0：热身" class="headerlink" title="lab0：热身"></a>lab0：热身</h2><h3 id="1-1-搭建环境"><a href="#1-1-搭建环境" class="headerlink" title="1.1 搭建环境"></a>1.1 搭建环境</h3><p>Windows 下建议使用 WSL，你可以参考我的 WSL 环境进行配置。<a href="https://blog.pengdonglai.com/2025/02/03/env-book-1/">https://blog.pengdonglai.com/2025/02/03/env-book-1/</a></p><p>在 linux 环境下，运行如下命令，就可以愉快地进行实验了。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt-get</span> <span class="token function">install</span> g++ <span class="token function">git</span> clang-tidy clang-format libpcap-dev <span class="token punctuation">\</span>    iptables mininet tcpdump telnet wireshark socat netcat-openbsd <span class="token punctuation">\</span>    doxygen graphviz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果使用 IDE，那么确保 IDE 在 Linux 的环境下运行，可以参考我的环境配置中关于 Clion 的部分~</p><p>随后，我们可以将代码拷贝下来，我用的是 <a href="https://github.com/vikshanker/sponge">https://github.com/vikshanker/sponge</a>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 你可以使用其他源，不一定要和我这个一样</span><span class="token function">git</span> clone https://github.com/vikshanker/sponge<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Stanford 推荐我们使用 Git 来进行分支管理。但实际上不用 Git，我们将很难把实验进行下去。而且找遍了全互联网也没有看见几个不用 Git 完成的例子。因此我们在安装环境的时候，也请务必在 Linux&#x2F;WSL 环境下把 Git 给搭建好（我的环境搭建指南中也有），并且可以正常连接到 Github。</p><p>原因很简单：那就是因为我们只是负责在已经搭建好的、工程实现很好的框架上做代码填空题，把关键的几个组件 (e.g., <code>TCPSender/TCPReceiver</code>, <code>NetworkInterface</code>, etc.) 中的某几个函数实现&#x2F;完善了而已。</p><p>但实际上，cs144 的 lab 是一个十分典型的现代 C++ 工程，不管是代码规范，工程实现，测试框架，还是现代 C++ 的各种语法，写的都非常优雅且规范。对于还不太熟悉 C++ 的同学们来说，尤其是现代 C++ 的各种语言特性用法，这门课是非常好的入门课。</p><p>可以说，相比于学校只教语法，这个 lab 更是教会了我们什么是「现代工程」，它的「落地感」是非常强的。从这个意义来说，使用 Git 进行版本管理，本身也是「现代代码工程」的一部分。</p><h3 id="1-2-整体认知"><a href="#1-2-整体认知" class="headerlink" title="1.2 整体认知"></a>1.2 整体认知</h3><p>这里就涉及到了一个棘手的问题，万一哪天作者删库跑路了（你斯坦福爸爸已经做过一遍了，笑死，<code>sponge</code> 早就被删的一干二净），我们从一个不知名的地方拷贝了代码。亦或者，你回退了其他人的代码例如我的，这个时候你该如何辨别你可以开始做实验了呢？</p><p>编程作业从 checkpoint 0 (network warmup) 到最后的 checkpoint 7: putting it all together) 一共分成了八个 checkpoint。</p><p>所以在我们拷贝 Github 的时候，需要首先观察它的 commit 是不是如下图所示：</p><div align="center">  <img src="../../../../loading2.svg" data-original="/2025/02/04/stanford-cs144/3.png"></div><p>这个 commit 中的代码，就是 lab0 所需要的基座代码。我们需要做的就是在它的基础之上进行填补和<s>修复 bug，这代码确实是有点问题的</s>，之后我们会通过测试程序和跑动单元测试，来验证我们写的内容是否正确。</p><p>重点来啦，<strong>只有这个 commit 的仓库是不应该被选择的</strong>。这里我们开一个天眼：后续的 lab1 一直到最后，都会有代码被补充进来。我们都必须要从远端来合并代码到我们的开发分支。这么说可能会有些抽象，我们来看一个例子。</p><p>除了我们当前的提交，我们记作 commit0。我们的开发记作 my-commit0。我们此时的分支的提交顺序为：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">commit0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后我们完成了 lab0 的开发，此时的分支提交顺序为：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">commit0 --> my-commit0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>助教准备了这些分支：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">1. lab1：commit0 --> commit12. lab2：commit0 --> commit1 --> commit2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>那么在开始 lab1 前，我们都必须将助教的 lab1 分支合并到我们的分支。合并之后，我们将会得到这样的一个分支提交顺序：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">commit0 --> commit1 --> my-commit0 --> merged branch lab1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个时候我们才能开始 lab1 的开发工作。</p><p>所以我们得出了结论：我们 fork 的代码仓库，也必须同时含有助教的几个分支才可以进行开发。不然 lab0 写完我们就要抓瞎了。在 Github 上截图大概就是这样的：</p><div align="center">  <img src="../../../../loading2.svg" data-original="/2025/02/04/stanford-cs144/4.png"></div><p>当我们确认了仓库本身含有这几个 startercode 分支，我们才能意识到，这恰恰就是我们想要的仓库。</p><p>我们可以通过以下 Git 命令行来实现代码的 merge 操作：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> fetch origin lab2-startercode<span class="token function">git</span> checkout lab2-startercode<span class="token function">git</span> checkout <span class="token punctuation">[</span>*Your branch here*<span class="token punctuation">]</span><span class="token function">git</span> merge lab2-startercode<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这样子我们也可以在本地查看 lab2-startercode 分支。如果你不需要，也可以直接一步到位：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> merge origin/lab2-startercode<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果有报错说分支不存在，那么请检查你使用的仓库是否符合我们的要求（远端是否有对应 startcode 分支）</p><p>我们现在已经有了基座代码仓库，也有了开发环境。到了这一步其实也已经很不容易了！我们终于可以正式开始做实验了！</p><h3 id="1-3-感性认识"><a href="#1-3-感性认识" class="headerlink" title="1.3 感性认识"></a>1.3 感性认识</h3><p>首先，请使用浏览器访问 <a href="http://cs144.keithw.org/hello">http://cs144.keithw.org/hello</a>，看看会发生什么？我们看到了一个网站。</p><p>当然，作为一个前端，服务端返回一个 html 文本，浏览器解析它这个过程我们再熟悉不过。只是，我们这个 lab 的重点其实是在于通信的过程，也就是使用 http 协议，从服务端传输 html 文本的过程。</p><p>接下来让我们使用工具 telnet，手动来访问这个网站吧。</p><p>在终端输入如下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">telnet cs144.keithw.org http<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个命令告诉 telnet，你要和 <code>cs144.keithw.org</code> 建立一个可靠的字节传输流，使用的协议是 http（超文本传输协议）。</p><p>当然，你只是这么做，起不到任何作用… 这也是这个 lab 中的一个坑点，我们必须要快速输入以下三行命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">telnet cs144.keithw.org http<span class="token comment"># 输入上面一行启动字节传输流后，快速输入以下三行内容：</span>GET /hello HTTP/1.1Host: cs144.keithw.orgConnection: close<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我试的时候我死活试不出来，笑死&#x3D;&#x3D;（应该是收到魔法的影响了 0.0 不过我就没深究了）。我看了其他人的解法，大概你会得到这样的返回结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">HTTP/1.1 <span class="token number">200</span> OKDate: Thu, <span class="token number">16</span> Jun <span class="token number">2022</span> 05:17:15 GMTServer: ApacheLast-Modified: Thu, <span class="token number">13</span> Dec <span class="token number">2018</span> <span class="token number">15</span>:45:29 GMTETag: <span class="token string">"e-57ce93446cb64"</span>Accept-Ranges: bytesContent-Length:14Connection: closeContent-Type: text/plainHello, CS144<span class="token operator">!</span>Connection closed by foreign host.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它实际上就表示了我们和服务端进行 http 协议通信的过程。我们这个 lab 要实现的，实际上也是这个过程，我们最终呈现的效果，也是返回一个 <code>Hello, CS144!</code></p><p>那么我们如何用代码来描述这个过程呢？我们接下来 1.3 就将实现这个 <code>Webget</code> 程序！</p><blockquote><p>（什么？你问我双工通信和发送邮件？不重要的东西直接忽略不就好了吗。抓重点！你完全可以通过看视频来学习这两个步骤，照着做就 OK 了~）<br>（发送邮件需要斯坦福邮箱，一般人做不了）</p></blockquote><h3 id="1-4-Webget-程序"><a href="#1-4-Webget-程序" class="headerlink" title="1.4 Webget 程序"></a>1.4 Webget 程序</h3><p>这个程序实际上就帮我们用代码在 Linux 环境下，完成了刚刚 telnet 所做的事情：功能为向指定 IP 地址发送 HTTP GET 请求，然后输出所有响应。</p><p>要求调用 Linux kernel 自带的 TCP&#x2F;IP 协议栈实现即可，Sponge 已经将 C-Style 的 Socket 封装成了几个 C++ 类：FileDescriptor, Socket, TCPSocket, and Address classes。</p><div align="center">  <img src="../../../../loading2.svg" data-original="/2025/02/04/stanford-cs144/1.png"></div><p>官方文档已经 RIP 了… 根据这几个类，我们不难发现其中包含了 TCPSocket，于是到了我们喜闻乐见的、使用无封装的原始代码发送 http 请求过程！</p><p>我们打开项目，找到 webget.cc 文件。之后我们填充 get_URL 函数，以下是一种可能的解法：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">get_URL</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>host<span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span>path<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// Your code here.</span>    <span class="token comment">// You will need to connect to the "http" service on</span>    <span class="token comment">// the computer whose name is in the "host" string,</span>    <span class="token comment">// then request the URL path given in the "path" string.</span>    <span class="token comment">// Then you'll need to print out everything the server sends back,</span>    <span class="token comment">// (not just one call to read() -- everything) until you reach</span>    <span class="token comment">// the "eof" (end of file).</span>    TCPSocket sock<span class="token punctuation">;</span>    sock<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token function">Address</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> <span class="token string">"http"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    sock<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"GET "</span> <span class="token operator">+</span> path <span class="token operator">+</span> <span class="token string">" HTTP/1.1\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    sock<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"Host: "</span> <span class="token operator">+</span> host <span class="token operator">+</span> <span class="token string">"\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    sock<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"Connection: close\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    sock<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    sock<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span>SHUT_WR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>sock<span class="token punctuation">.</span><span class="token function">eof</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> sock<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    sock<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"Function called: get_URL("</span> <span class="token operator">&lt;&lt;</span> host <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> <span class="token operator">&lt;&lt;</span> path <span class="token operator">&lt;&lt;</span> <span class="token string">").\n"</span><span class="token punctuation">;</span>    <span class="token comment">// cerr &lt;&lt; "Warning: get_URL() has not been implemented yet.\n";</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码的主要功能是使用 TCP 套接字（TCPSocket）向指定的 HTTP 服务器发送一个简单的 HTTP GET 请求，然后读取并输出服务器返回的响应数据，最后关闭套接字连接。</p><p><code>sock.write(&quot;\r\n&quot;);</code> 发送一个空行，表示 HTTP 请求头的结束。HTTP 协议规定，请求头和请求体之间需要用一个空行分隔。</p><p><code>sock.shutdown(SHUT_WR);</code> 关闭套接字的写端。SHUT_WR 表示只关闭写操作，即客户端不再向服务器发送数据，但仍然可以接收服务器的响应数据。</p><p><code>sock.eof()</code> 使用一个循环来读取服务器的响应数据，直到套接字的输入流结束（即服务器关闭连接）。<code>sock.eof()</code> 用于检查套接字的输入流是否已经结束。</p><p>我们进入 build 文件夹，重新 make 后，运行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./apps/webget cs144.keithw.org /hello<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>它的行为应该和上述我们使用 telnet 的行为保持一致。</p><p>最后它应该能够通过测试：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> check_webget<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><div align="center">  <img src="../../../../loading2.svg" data-original="/2025/02/04/stanford-cs144/2.png"></div><p>在测试的时候，有可能会碰到 <code>t_webget.sh</code> 文件不存在的报错，这块可以先不用管，后面会一起修复。</p><h3 id="1-5-ByteStream"><a href="#1-5-ByteStream" class="headerlink" title="1.5 ByteStream"></a>1.5 ByteStream</h3><p>上一节我们使用了 <code>TCPSocket</code>，调用了 <code>read</code> 和 <code>write</code> 方法，这一节就来实现一个这样的类管道：一个运行在内存的有序可靠字节流（An in-memory reliable byte stream）</p><h4 id="1-5-1-是实现什么？"><a href="#1-5-1-是实现什么？" class="headerlink" title="1.5.1 是实现什么？"></a>1.5.1 是实现什么？</h4><p>它是一个数据结构，也是一个对象类。它应该具备一个 <code>write</code> 方法，以便于我们可以往这个对象内<strong>写入数据</strong>。我们也可以使用 <code>read</code> 方法从它身上读取数据。</p><p>它应该具备一个容量大小，因为我们不能一味的只存入数据而不读取数据。容量已经满的时候，多出来的内容应该被直接丢弃。</p><p>写入端也必须告知这个数据结构它写完了。我们通过一个对外暴露的函数从写入端那边获取到这一信息。</p><p>详细说明，它具有以下要求：</p><ol><li>字节流可以从写入端写入，并以相同的顺序，从读取端读取</li><li>字节流是有限的，写者可以终止写入。而读者可以在读取到字节流末尾时，产生 EOF 标志，不再读取</li><li>所实现的字节流必须支持流量控制，以控制内存的使用。当所使用的缓冲区爆满时，超过缓冲区容量的内容直接丢弃。字节流会返回成功写入的字节数</li><li>写入的字节流可能会很长，必须考虑到字节流大于缓冲区大小的情况。即便缓冲区只有1字节大小，所实现的程序也必须支持正常的写入读取操作</li><li>在单线程环境下执行，因此不用考虑各类条件竞争问题</li></ol><h4 id="1-5-2-如何设计它？"><a href="#1-5-2-如何设计它？" class="headerlink" title="1.5.2 如何设计它？"></a>1.5.2 如何设计它？</h4><p>具体的实现，在 <code>libsponge/byte_stream.hh</code> <code>libsponge/byte_stream.cc</code> </p><p>阅读头文件我们已经可以知道 byte_stream 的系统类设计了：</p><ol><li><p>创建的时候，传入一个 int 代表管道的「容量」。</p></li><li><p>对于写管道，实现相关的函数 <code>write</code>、<code>remain_capacity</code>、<code>end_input</code>、<code>set_error</code>：</p><ul><li>写入数据：使用 <code>write</code> 方法将一段测试数据写入字节流，并打印实际写入的字节数。</li><li>检查剩余容量：使用 <code>remaining_capacity</code> 方法检查字节流还能容纳多少字节，并打印结果。</li><li>标记输入结束：使用 <code>end_input</code> 方法标记输入结束，再次检查输入是否结束并打印结果。</li><li>记流出现错误：使用 <code>set_error</code> 方法标记流出现错误，使用 <code>error</code> 方法检查流是否有错误并打印结果。</li></ul></li><li><p>对于读管道，实现 <code>pop_output</code>、<code>read</code>、<code>input_ended</code>、<code>eof</code>、<code>error</code>、<code>buf_size</code>、<code>buf_empty</code>、<code>bytes_written</code>、<code>bytes_read</code>。</p><ul><li>查看数据：使用 <code>peek_output</code> 方法查看缓冲区中的前 x 个字节，不将它们从缓冲区中移除，并打印结果。</li><li>读取并移除数据：使用 <code>read</code> 方法读取并移除缓冲区中的前 y 个字节，并打印结果。</li><li>手动移除数据：使用 <code>pop_output</code> 方法手动移除缓冲区中的 x 个字节，并打印提示信息。</li><li>检查输入是否结束：使用 <code>input_ended</code> 方法检查输入是否已经结束，并打印结果。</li><li>检查缓冲区是否为空：使用 <code>buffer_empty</code> 方法检查缓冲区是否为空，并打印结果。</li><li>检查是否到达输出结尾：使用 <code>eof</code> 方法检查是否到达输出结尾，并打印结果。</li><li>获取已写入的字节数：使用 <code>bytes_written</code> 方法获取已经写入的总字节数，并打印结果。</li><li>获取已读取的字节数：使用 <code>bytes_read</code> 方法获取已经读取的总字节数，并打印结果。</li><li>获取当前缓冲区大小：使用 <code>buffer_size</code> 方法获取当前缓冲区的大小，并打印结果。</li></ul></li></ol><p>通过系统设计分析，我们可知：</p><ol><li>毫无疑问我们需要一个 _capacity 来保存容量。</li><li>我们需要一个 _count_written 保存</li></ol><h4 id="1-5-3-如何实现？"><a href="#1-5-3-如何实现？" class="headerlink" title="1.5.3 如何实现？"></a>1.5.3 如何实现？</h4><p>我们使用双端队列实现，这是因为双端队列可以实现「前进后出」：</p><p><code>byte_stream.hh</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>deque<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> _buffer_deque<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">//!&lt; The data of this stream</span>size_t _count_written<span class="token punctuation">;</span> <span class="token comment">//!&lt; The written count of the input</span>size_t _count_read<span class="token punctuation">;</span> <span class="token comment">//!&lt; The read count of the input</span>size_t _capacity<span class="token punctuation">;</span> <span class="token comment">//!&lt; The capacity of this stream</span><span class="token keyword">bool</span> _error<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token comment">//!&lt; Flag indicating that the stream suffered an error.</span><span class="token keyword">bool</span> _input_finished_flag<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">//!&lt; Flag indicating that the input has been overed.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>byte_stream.cc</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token class-name">ByteStream</span><span class="token double-colon punctuation">::</span><span class="token function">ByteStream</span><span class="token punctuation">(</span><span class="token keyword">const</span> size_t capacity<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">_count_written</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_count_read</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">_capacity</span><span class="token punctuation">(</span>capacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>size_t <span class="token class-name">ByteStream</span><span class="token double-colon punctuation">::</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">auto</span> _safe_len <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token operator">-></span><span class="token function">remaining_capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> _safe_len<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token operator">-></span>_buffer_deque<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token operator">-></span>_count_written<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> _safe_len<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//! \param[in] len bytes will be copied from the output side of the buffer</span>string <span class="token class-name">ByteStream</span><span class="token double-colon punctuation">::</span><span class="token function">peek_output</span><span class="token punctuation">(</span><span class="token keyword">const</span> size_t len<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">auto</span> _safe_len <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>len<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token operator">-></span>_buffer_deque<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    string _str<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> _safe_len<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        _str <span class="token operator">+=</span> <span class="token keyword">this</span><span class="token operator">-></span>_buffer_deque<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> _str<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//! \param[in] len bytes will be removed from the output side of the buffer</span><span class="token keyword">void</span> <span class="token class-name">ByteStream</span><span class="token double-colon punctuation">::</span><span class="token function">pop_output</span><span class="token punctuation">(</span><span class="token keyword">const</span> size_t len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">auto</span> _safe_len <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>len<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token operator">-></span>_buffer_deque<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> _safe_len<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token operator">-></span>_buffer_deque<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token operator">-></span>_count_read<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//! Read (i.e., copy and then pop) the next "len" bytes of the stream</span><span class="token comment">//! \param[in] len bytes will be popped and returned</span><span class="token comment">//! \returns a string</span>string <span class="token class-name">ByteStream</span><span class="token double-colon punctuation">::</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token keyword">const</span> size_t len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    string _str <span class="token operator">=</span> <span class="token function">peek_output</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token operator">-></span><span class="token function">pop_output</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> _str<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token class-name">ByteStream</span><span class="token double-colon punctuation">::</span><span class="token function">end_input</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token operator">-></span>_input_finished_flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">bool</span> <span class="token class-name">ByteStream</span><span class="token double-colon punctuation">::</span><span class="token function">input_ended</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token operator">-></span>_input_finished_flag<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>size_t <span class="token class-name">ByteStream</span><span class="token double-colon punctuation">::</span><span class="token function">buffer_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token operator">-></span>_count_written <span class="token operator">-</span> <span class="token keyword">this</span><span class="token operator">-></span>_count_read<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token keyword">bool</span> <span class="token class-name">ByteStream</span><span class="token double-colon punctuation">::</span><span class="token function">buffer_empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">buffer_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token keyword">bool</span> <span class="token class-name">ByteStream</span><span class="token double-colon punctuation">::</span><span class="token function">eof</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token operator">-></span>_input_finished_flag <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token operator">-></span><span class="token function">buffer_empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>size_t <span class="token class-name">ByteStream</span><span class="token double-colon punctuation">::</span><span class="token function">bytes_written</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token operator">-></span>_count_written<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>size_t <span class="token class-name">ByteStream</span><span class="token double-colon punctuation">::</span><span class="token function">bytes_read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token operator">-></span>_count_read<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>size_t <span class="token class-name">ByteStream</span><span class="token double-colon punctuation">::</span><span class="token function">remaining_capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token operator">-></span>_capacity <span class="token operator">-</span> <span class="token keyword">this</span><span class="token operator">-></span><span class="token function">buffer_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Lab0 我们实现了 ByteStream 这样一个双向字节流。在接下来的实验里，你会实现两个ByteStream：</p><ul><li>一个出向（outbound）ByteStream，本地应用可以通过 socket 向里面写数据，你的TCP可以把数据传输到远端；</li><li>一个入向（inbound）ByteStream，你的 TCP 会接收从远端发来的数据，然后被本地应用所读取。</li></ul><h3 id="1-6-调试"><a href="#1-6-调试" class="headerlink" title="1.6 调试"></a>1.6 调试</h3><p>我们的调试会使用位于 <code>tests</code> 文件夹下的文件，里面正是一个个单元测试。在项目原理篇中，我会详细说明项目是如何进行单元测试的。</p><p>在进行了 lab1 代码的 merge 操作后，我们可以看到 stream 相关的单元测试已经在对应文件夹下了：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">// testsbyte_stream_capacity.ccbyte_stream_construction.ccbyte_stream_many_writes.ccbyte_stream_one_writes.cc// 其它不再一一列举<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 build 文件夹内执行 make 操作后，它们会在 <code>build/tests</code>（或者 Clion 默认配置的 <code>cmake-build-debug/tests</code>）下生成对应的二进制文件：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">// cmake-build-debug/testsbyte_stream_capacitybyte_stream_constructionbyte_stream_many_writesbyte_stream_one_writes// 其它不再一一列举<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们 lab1 中实现的是 byte_stream，项目中它所有的单元测试名字前缀都是它。它们当中的每一个都可以被执行。</p><p>我们在执行 <code>make check_lab1</code> 命令的时候，实际上执行的是 makefile target，在这个过程中实际上就是会跑这几个二进制程序。所以我们执行 <code>make check_lab1</code> 命令走单元测试的时候，你至少要学会看单元测试的输出，以便于让它告诉你你是「错在了哪个单元测试」和「哪个单元测试步骤」，之后你要去找到对应的二进制文件来执行。</p><h4 id="1-6-1-Clion-调试"><a href="#1-6-1-Clion-调试" class="headerlink" title="1.6.1 Clion 调试"></a>1.6.1 Clion 调试</h4><p>由于我使用的 IDE 为 Clion，所以会这个过程会比 VSCode 描述的相对更细致一些。</p><p>我会假定你是在 WSL2 中进行的实验，并且按照我的教程配置好了实验环境（其它环境只要能 make 成功大概率也能跑动 Clion 调试，只是不敢做这个保证）。</p><p>在 Clion 右上角调试，选择好对应的调试程序：</p><div align="center">  <img src="../../../../loading2.svg" data-original="/2025/02/04/stanford-cs144/6.png"></div><p>假设我选择了 byte_capacity，然后我在 byte_stream.cc 中觉得有问题的地方打上断点。大概如图所示：</p><div align="center">  <img src="../../../../loading2.svg" data-original="/2025/02/04/stanford-cs144/7.png"></div><p>之后，点击旁边的那个虫子，就进入了调试的过程。如果程序成功暂停，就说明我们成功了。</p><div align="center">  <img src="../../../../loading2.svg" data-original="/2025/02/04/stanford-cs144/8.png"></div><h4 id="1-6-2-VSCode-调试"><a href="#1-6-2-VSCode-调试" class="headerlink" title="1.6.2 VSCode 调试"></a>1.6.2 VSCode 调试</h4><h2 id="lab1：Reassembler"><a href="#lab1：Reassembler" class="headerlink" title="lab1：Reassembler"></a>lab1：Reassembler</h2><p>在 Lab1 中，需要实现一个流重组器：将传入的没一份打乱的字节流重新组合形成原来的有序的字节流。即实现 StreamReassembler 类。</p><blockquote><p>为什么要这样做？TCP 对处理乱序和重复包的健壮性来自于它能将字节流的任意摘录拼接回原始流的能力。在离散的可测试模块中实现这一功能将使处理传入段变得更加容易。</p></blockquote><p>merge 完 lab1 的代码后，你会看到我们本节需要实现的文件：<code>stream_reassembler.cc</code> 和 <code>stream_reassembler.hh</code></p><h3 id="2-1-是实现什么？"><a href="#2-1-是实现什么？" class="headerlink" title="2.1 是实现什么？"></a>2.1 是实现什么？</h3><p>基于 ByteStream，实现一个流重组器。</p><div align="center">  <img alt="从 Up 主那边偷来的图，诶嘿" src="../../../../loading2.svg" data-original="/2025/02/04/stanford-cs144/5.png"></div><p><a href="https://www.bilibili.com/video/BV1mt4y177AJ?spm_id_from=333.788.videopod.sections&amp;vd_source=afe81fa0acec03a62c58fe0fc394ca5b">https://www.bilibili.com/video/BV1mt4y177AJ?spm_id_from=333.788.videopod.sections&amp;vd_source=afe81fa0acec03a62c58fe0fc394ca5b</a></p><p>（原 Up 主视频链接，也是主讲 CS144 的。讲的很通俗易懂，但是我并没有采纳他对于 lab1 的解法）</p><p>我们需要使用到 ByteStream，主要是为了<strong>写入它，然后让它帮我们进行缓存</strong>。除此以外的功能，都是 Reassembler 自己实现的。</p><p>从我们需要使用的文件 <code>stream_reassembler.cc</code> 可以知道，我们和 ByteStream 共享同一个 capacity。从这里我们已经可以感觉出来项目的第一个要求了：</p><blockquote><p>如果我们在 Reassembler 新增数据结构，那么这个数据结构一旦需要线性增长，那么不能超过 capacity 容量。至于说需要需要超过线性增长的数据结构，那更是需要被抛弃掉。</p></blockquote><p>根据头文件可知核心方法为 <code>push_substring()</code>，它的参数非常好懂。</p><ul><li><p>data 是写入的数据，还是和 ByteStream 一样，写入的是一个 string 字符串。index 的意思是，当前的 data 在发送方处于的位置。比如说一个数据，它的容量为 1024，那么 index 完全可能是 0-1024 中的任意一个数，表示 data 在这个数据中所起到的位置。</p></li><li><p>根据我们上一个 lab 的知识，最后一个 eof 参数，表示就是到达 <code>push_substring()</code> 的这个 data 是否为处于全数据的末尾。</p></li></ul><h3 id="2-2-Reassembler-核心原理"><a href="#2-2-Reassembler-核心原理" class="headerlink" title="2.2 Reassembler 核心原理"></a>2.2 Reassembler 核心原理</h3><p>除此之外，我们得来首先认识下这个流重组器具体是做了什么事情的：</p><p>如果您了解 TCP 协议的「可靠交付」机制，您可以更好的明白这里的含义。如果实在不明白，那么也还请您再去阅读相关资料，弄懂后才能来做 Reassembler。</p><p>假设我们的初始条件是 capacity 为 5. 这要求我们初始化的空间复杂度需要为 5C。（C 在这里为参数）。</p><p>我们将 Reassembler 中的空间称为「管道」，将 BuffStream 的空间称为「缓冲区」。上文中 <code>push_substring()</code> 的 index 称为「string 起始索引」。当然，这么称呼只是为了好听，实际上它们并不叫这个名字。那么我们可以得到第一个认知：</p><p>「管道」的容量（共 5C） +「缓冲区」的容量（0） &#x3D; 5C</p><h4 id="2-2-1-第一种过程：整体"><a href="#2-2-1-第一种过程：整体" class="headerlink" title="2.2.1 第一种过程：整体"></a>2.2.1 第一种过程：整体</h4><p>（0）我们往空的管道中，string 起始索引为 0 的情况下注入 2 个字符：a b，并且<strong>设置 eof 为 1</strong>。此时管道的容量为 2C</p><p>（管道的容量，只要能放得下它应该要放的数据就够了，比如共 5C {ab 2C}，这个数据就是一个合法的数据。一旦表示为共 1C {ab 2C}，很显然 ab 放不下，所以是非法数据）</p><p>此时可以看到 EOF 的索引为 2，它是由起始索引为 0 + ab 的长度 2 &#x3D; 2 得来的。当然我们现在不需要知道它有什么作用。直观表示为：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">「管道」的容量（共 5C <span class="token punctuation">&#123;</span>ab 2C<span class="token punctuation">&#125;</span>） +「缓冲区」的容量（0） <span class="token operator">=</span> 5Ca（管道） b（管道）--EOF-- <span class="token number">0</span>（管道） <span class="token number">0</span>（管道） <span class="token number">0</span>（管道）<span class="token operator">=</span> 5C<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>（1）之后，我们的「缓冲区」开始从「管道」中读取 ab，此时我们的直观表示为：</p><p>「管道」的容量（共 3C） +「缓冲区」的容量（共 2C {ab 2C}） &#x3D; 5C</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">「管道」的容量（共 5C <span class="token punctuation">&#123;</span>ab 2C<span class="token punctuation">&#125;</span>） +「缓冲区」的容量（0） <span class="token operator">=</span> 5Ca（缓冲区） b（缓冲区）--EOF-- <span class="token number">0</span>（管道） <span class="token number">0</span>（管道） <span class="token number">0</span>（管道）<span class="token operator">=</span> 5C<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>（2）由于此时 EOF 以前的内容全部进入了缓冲区，那么可以认为 reassembler 进入到了「结束态」。</p><p>这样就表示了一个读入「管道」，然后从「管道」中读出来放到「缓冲区」，最后结束的全过程。</p><p>我们这个时候不禁有一个疑问，我们从「管道」中读出来放到「缓冲区」的过程，怎么确定哪些数据要从「管道」中读出来呢？</p><p>我们不妨来看看第二个例子。</p><h4 id="2-2-2-第二种过程：核心"><a href="#2-2-2-第二种过程：核心" class="headerlink" title="2.2.2 第二种过程：核心"></a>2.2.2 第二种过程：核心</h4><p>（0）我们往空的管道中，string 起始索引<strong>为 1</strong> 的情况下注入 2 个字符：a b，并且<strong>设置 eof 为 0</strong>。此时管道的容量为 2C，直观表示为：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">「管道」的容量（共 5C <span class="token punctuation">&#123;</span>ab 2C<span class="token punctuation">&#125;</span>） +「缓冲区」的容量（0） <span class="token operator">=</span> 5C<span class="token number">0</span>（管道） a（管道） b（管道） <span class="token number">0</span>（管道） <span class="token number">0</span>（管道）<span class="token operator">=</span> 5C<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>（1）由于我们还不知道第一个位置上的数据是什么，因此我们还不能读取数据到「缓冲区」中。</p><p>（2）往管道中，string 起始索引<strong>为 0</strong> 的情况下注入 1 个字符：c，并且<strong>设置 eof 为 0</strong>。直观表示为：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">「管道」的容量（共 5C <span class="token punctuation">&#123;</span>cab 3C<span class="token punctuation">&#125;</span>） +「缓冲区」的容量（0） <span class="token operator">=</span> 5Cc（管道） a（管道） b（管道） <span class="token number">0</span>（管道） <span class="token number">0</span>（管道）<span class="token operator">=</span> 5C<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>（3）我们还不知道 eof 的位置。但我们已经能读取数据到「缓冲区」中，读取数据后，直观表示是这个样子：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">「管道」的容量（共 2C） +「缓冲区」的容量（共 3C <span class="token punctuation">&#123;</span>cab 3C<span class="token punctuation">&#125;</span>） <span class="token operator">=</span> 5Cc（缓冲区） a（缓冲区） b（缓冲区） <span class="token number">0</span>（管道） <span class="token number">0</span>（管道）<span class="token operator">=</span> 5C<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>（4）往管道中，string 起始索引<strong>为 3</strong> 的情况下注入 1 个字符：f，并且<strong>设置 eof 为 1</strong>。</p><p>此时我们设置 EOF 为 4（3（起始索引）+ 1（f 的长度））。经过直观表示为：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">「管道」的容量（共 2C <span class="token punctuation">&#123;</span>f 1C<span class="token punctuation">&#125;</span>） +「缓冲区」的容量（共 3C <span class="token punctuation">&#123;</span>cab 3C<span class="token punctuation">&#125;</span>） <span class="token operator">=</span> 5Cc（缓冲区） a（缓冲区） b（缓冲区） f（管道）--EOF-- <span class="token number">0</span>（管道）<span class="token operator">=</span> 5C<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>（5）我们读取 f 到「缓冲区」：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">「管道」的容量（共 1C） +「缓冲区」的容量（4C <span class="token punctuation">&#123;</span>cabf 4C<span class="token punctuation">&#125;</span>） <span class="token operator">=</span> 5Cc（缓冲区） a（缓冲区） b（缓冲区） f（缓冲区）--EOF-- <span class="token number">0</span>（管道）<span class="token operator">=</span> 5C<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>（6）由于此时 EOF 以前的内容全部进入了缓冲区，那么可以认为 reassembler 进入到了「结束态」。</p><p>通过以上过程，我们总结，一般来说我们有两个条件促成这一点：</p><ol><li><p>我们读取到了 eof，且这个 eof 表示的「string 起始索引」+ data.length() 被我们记录下来称为「EOF 的索引」。</p></li><li><p>缓冲区从 0 到「EOF 的索引」中，索引对应的所有字符，均「存在」能被有效读取（在直观表示中，它们必须全都不为 0）。然后从索引 0 开始，一路读取所有能读的字符，读到 eof 的 index 为止。</p></li></ol><p>至此我们回答了从「管道」中读出来放到「缓冲区」的过程，怎么确定哪些数据要从「管道」中读出来的问题。</p><h4 id="2-2-3-第三种过程：异常"><a href="#2-2-3-第三种过程：异常" class="headerlink" title="2.2.3 第三种过程：异常"></a>2.2.3 第三种过程：异常</h4><p>接过程二的（3），从（4）开始我们设置新的过程。（3）后，直观表示大概是这个样子：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">「管道」的容量（共 2C） +「缓冲区」的容量（共 3C <span class="token punctuation">&#123;</span>cab 3C<span class="token punctuation">&#125;</span>） <span class="token operator">=</span> 5Cc（缓冲区） a（缓冲区） b（缓冲区） <span class="token number">0</span>（管道） <span class="token number">0</span>（管道）<span class="token operator">=</span> 5C<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>（4.1）往管道中，string 起始索引<strong>为 3</strong> 的情况下<strong>注入 3 个字符</strong>：fgh，并且<strong>设置 eof 为 1</strong>。</p><p>这个时候我们发现了一个问题，那就是我们注入的容量会超过总的 capacity 设定。想要完全存储，需要 3C（现有 cab）+ 3C（新数据 fgh）。这个时候，<strong>超出 capacity 的部分会被直接抛弃。</strong>，但是 eof 仍然会被记作 6（这是由「string 起始索引」+ data.length() 即 3 + 3 &#x3D; 6 决定好的）。</p><p>执行完注入管道的逻辑后，我们可以看到这样的直观表示：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">「管道」的容量（共 2C） +「缓冲区」的容量（共 3C <span class="token punctuation">&#123;</span>cab 3C<span class="token punctuation">&#125;</span>） <span class="token operator">=</span> 5Cc（缓冲区） a（缓冲区） b（缓冲区） f（管道） g（管道）--EOF--（6）<span class="token operator">=</span> 5C<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们可以看到，由于 capacity 已经放不下了，h 被直接丢弃。</p><p>这种情况下，需要等缓冲区的内容被释放腾出空间以便于重新记录下来 h，亦或者 EOF 的位置被更新到 5，不然不会进入到「结束态」即（超时前）永远不会完成这次的连接过程。</p><p>（4.2）回到 3 结束的位置。设想另一种场景：往管道中，string 起始索引<strong>为 2</strong> 的情况下<strong>注入 3 个字符</strong>：bfg，并且<strong>设置 eof 为 1</strong>。</p><p>这种情况下，我们可以看到，已经在缓冲区的 b，又被注入到了管道中。这个时候 reassembler 会判断 b 当前 index 位置的字符已经被 reassembled（其实就是等效于它进入了缓冲区），因此 b 实际上不会被处理，会从 f 开始进行逻辑上的处理，并按照之前的逻辑设置好 EOF 为 5：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">「管道」的容量（共 2C） +「缓冲区」的容量（共 3C <span class="token punctuation">&#123;</span>cab 3C<span class="token punctuation">&#125;</span>） <span class="token operator">=</span> 5Cc（缓冲区） a（缓冲区） b（缓冲区） f（管道） g（管道）--EOF--（5）<span class="token operator">=</span> 5C<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这种之后会转到上一个步骤的（5）中进行处理且进入「结束态」。</p><p>（4.3）回到 3 结束的位置。设想另一种场景：往管道中，string 起始索引<strong>为 2</strong> 的情况下<strong>注入 3 个字符</strong>：cfg，并且<strong>设置 eof 为 1</strong>。</p><p>这种情况下，我们可以看到，已经在缓冲区的 b，和重新注入的 c 存在冲突。这个时候我们应当认为是发布侧存在问题，所以在这个 lab 中，要么不作处理，要么抛出 runtime 异常。会从 f 开始进行逻辑上的处理，这一步和（4.2）一致，并按照之前的逻辑设置好 EOF 为 5：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">「管道」的容量（共 2C） +「缓冲区」的容量（共 3C <span class="token punctuation">&#123;</span>cab 3C<span class="token punctuation">&#125;</span>） <span class="token operator">=</span> 5Cc（缓冲区） a（缓冲区） b（缓冲区） f（管道） g（管道）--EOF--（5）<span class="token operator">=</span> 5C<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>通过这个步骤可以知道，产生冲突的时候，我们遵循「先来后到」的原则，因为我们认为 TCP 就是可靠交付，所以我们就是会假设最开始传输的内容是正确的。</p><h4 id="2-2-4-第四种过程：空碎片"><a href="#2-2-4-第四种过程：空碎片" class="headerlink" title="2.2.4 第四种过程：空碎片"></a>2.2.4 第四种过程：空碎片</h4><p>（4.4）回到 3 结束的位置。设想另一种场景：往管道中，string 起始索引<strong>为 3</strong> 的情况下<strong>注入 0 个字符</strong>，并且<strong>设置 eof 为 1</strong>。</p><p>这种情况下，我们直接设置 EOF 即可：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">「管道」的容量（共 2C） +「缓冲区」的容量（共 3C <span class="token punctuation">&#123;</span>cab 3C<span class="token punctuation">&#125;</span>） <span class="token operator">=</span> 5Cc（缓冲区） a（缓冲区） b（缓冲区）--EOF-- <span class="token number">0</span>（管道） <span class="token number">0</span>（管道）<span class="token operator">=</span> 5C<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这种之后会转到上一个步骤的（5）中进行处理且进入「结束态」。</p><p>（4.5）回到 3 结束的位置。设想另一种场景：往管道中，string 起始索引<strong>为 3</strong> 的情况下<strong>注入 0 个字符</strong>，并且<strong>设置 eof 为 0</strong>。</p><p>这种情况下，我们什么也不做，直接返回。</p><p>（只要同时满足注入字符为空，eof 也为 0，起始索引是什么都无所谓，都是直接返回）</p><p>（4.6）回到 3 结束的位置。设想另一种场景：往管道中，string 起始索引<strong>为 2</strong> 的情况下<strong>注入 0 个字符</strong>，并且<strong>设置 eof 为 1</strong>。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">「管道」的容量（共 2C） +「缓冲区」的容量（共 3C <span class="token punctuation">&#123;</span>cab 3C<span class="token punctuation">&#125;</span>） <span class="token operator">=</span> 5Cc（缓冲区） a（缓冲区）--EOF-- b（缓冲区） <span class="token number">0</span>（管道） <span class="token number">0</span>（管道）<span class="token operator">=</span> 5C<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这种之后会转到上一个步骤的（5）中进行处理且进入「结束态」。</p><h3 id="2-3-数据结构-＆-算法实现"><a href="#2-3-数据结构-＆-算法实现" class="headerlink" title="2.3 数据结构 ＆ 算法实现"></a>2.3 数据结构 ＆ 算法实现</h3><p>我们来定义一次 <code>push_string()</code> 为「一次操作」。</p><p>这个时候你会发现，每一次操作可能会包括以下过程：</p><ol><li>向「管道」中注入数据和 eof 信息，当然也有可能是一个空的数据。</li><li>将「管道」中，前一部分「连续的」数据，读取到「缓冲区」中。</li><li>更新 eof 信息，并且检查当前是否达到了 eof 的状态。</li></ol><p>好的，通过文字描述，和 2.2 部分对于过程的描述，是不是想到了<strong>双指针</strong>？即，读取到的缓冲区的 index1，和管道中的 eof index2。index1 是为了区分哪些数据进入了缓冲区，index2 是为了区分当前是否到达了 eof 状态。而 index1 &#x3D;&#x3D; index2 一旦形成，则向缓冲区注入 <code>end_input()</code>，是不是一个完整的过程就出来了？</p><p>观察实现文件 <code>stream_reassembler.cc</code>，我们注意到还有这两个方法等着我们实现，通过对 empty 的描述我们可以知道就是管道还没有进缓冲区的容量是否为空，因此我们完成 <code>empty()</code> 方法，并且最简单的不就是设置一个私有成员变量表示 <code>unassembled_bytes</code> 吗？（先不管怎么算，直接设置这个变量然后返回不香吗）</p><p>所以我们实现了这些，并且此时已有 index1 记作 <code>size_t _reassembled_index</code>，<code>unassembled_bytes</code> 记作 <code>_disassembled_count</code>。此时我们加上 index2，记作 <code>_eof_index</code>。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">size_t <span class="token class-name">StreamReassembler</span><span class="token double-colon punctuation">::</span><span class="token function">unassembled_bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token operator">-></span>_disassembled_count<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token keyword">bool</span> <span class="token class-name">StreamReassembler</span><span class="token double-colon punctuation">::</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token operator">-></span><span class="token function">unassembled_bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>最后我们还有一个问题，我们目前是只有「缓冲区」的（这部分项目已经写好）也就是 <code>_output</code>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ByteStream _output<span class="token punctuation">;</span>  <span class="token comment">//!&lt; The reassembled in-order byte stream</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但是我们还需要一个数据结构来保存「管道」，而且「管道」也必须要能记录当前特定 index 下的字符是否被 assembled。我们需要一个空间复杂度为 n 的数据结构，当然能满足的数据结构有很多，这也就是 lab1 实现方案不止一处的最大原因。</p><p>我们使用最稳妥（因为用的足够多，性能也有保障）的 vector，里面用 pair 存两个数据 {当前 char，是否被 assembled}。于是我们有了这些成员变量：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">private</span><span class="token operator">:</span>  <span class="token comment">// Your code here -- add private members as necessary.</span>  ByteStream _output<span class="token punctuation">;</span>  <span class="token comment">//!&lt; The reassembled in-order byte stream</span>  size_t _capacity<span class="token punctuation">;</span>    <span class="token comment">//!&lt; The maximum number of bytes</span>  std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>pair<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">>></span> _reassembler_stream<span class="token punctuation">;</span> <span class="token comment">//!&lt; The current part of the reassembled byte stream</span>  size_t _eof_index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//!&lt; The index of Eof char</span>  size_t _disassembled_count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//!&lt; The count of char has not been reassembled</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后我们按照对应的流程实现，就好了。我这里先用文字简单描述下我的过程：</p><ol><li>首先计算 <code>reassembler_stream</code> 存储的开头和结尾 index。根据两边的 index <code>reassembler_stream</code>：</li></ol><ul><li>1.1 已经被 reassembled 的 index 就不必再重新 assemble 一遍，因此需要设置一个变量 <code>first_disassembled</code>，并且从 index 和 <code>first_disassembled</code> 中，选一个大的，作为开头 index，即 <code>_start_index</code>。</li><li>1.2 大于 eof 的不必 assemble；大于 capacity 的不能 assemble。因此我们计算此时剩余的 capacity <code>this-&gt;_first_disassembled_index + this-&gt;_capacity - this-&gt;_output.buffer_size();</code>，并且和 <code>eof</code>、<code>data.length()</code> 做对比，得到结尾 index，即 <code>_end_index</code>。</li><li>1.3 结尾 index 比实际遍历到的最后一个 index 大 1. 所以遍历实际上是左闭右开区间，符合国际惯例。</li></ul><ol start="2"><li><p>更新 eof。执行 1 中对 <code>reassembler_stream</code> 的 assemble 操作。这个操作实际上就是去更新 <code>_reassembler_stream</code> 的 <code>false</code> 值为 true。如果某个字符进入到了 代表着进入了 <code>_reassembler_stream</code> 则意味着它进入了 reassembler 的窗口。</p></li><li><p>接下来需要处理已经在缓冲区的新元素，<code>reassembled_index</code> 在 <code>_reassembler_stream</code>「一路向前」，直到碰到没有 assembled 的元素为止。在实际操作中，没有 assembled 的元素在 <code>_reassembler_stream</code> 中仍然对应则 <code>false</code> 值。</p></li><li><p>当我们收集了一定的 _str 后，向 ByteStream 中写入这些字符串：<code>this-&gt;_output.write(_str);</code></p></li><li><p>最后，如果 <code>reassembled_index</code>「追上了」<code>eof_index</code>，则表明当前当前读取完毕。执行 <code>_output</code> 中停止写入的方法。</p></li></ol><p>如果看的比较迷茫（不得不承认描述代码就是这么枯燥），结合下方的代码一起看，也许会更容易理解。</p><h3 id="2-4-具体实现"><a href="#2-4-具体实现" class="headerlink" title="2.4 具体实现"></a>2.4 具体实现</h3><p><code>stream_reassembler.hh</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">StreamReassembler</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span><span class="token operator">:</span>    <span class="token comment">// Your code here -- add private members as necessary.</span>    ByteStream _output<span class="token punctuation">;</span>  <span class="token comment">//!&lt; The reassembled in-order byte stream</span>    size_t _capacity<span class="token punctuation">;</span>    <span class="token comment">//!&lt; The maximum number of bytes</span>    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>pair<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">>></span> _reassembler_stream<span class="token punctuation">;</span> <span class="token comment">//!&lt; The current part of the reassembled byte stream</span>    <span class="token keyword">bool</span> _eof <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">//!&lt; Eof</span>    size_t _eof_index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//!&lt; The index of Eof char</span>    size_t _first_disassembled_index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//!&lt; The first index of char not yet reassembled</span>    size_t _disassembled_count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//!&lt; The count of char has not been reassembled</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>stream_reassembler.cc</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">StreamReassembler</span><span class="token double-colon punctuation">::</span><span class="token function">push_substring</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>data<span class="token punctuation">,</span> <span class="token keyword">const</span> size_t index<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">bool</span> eof<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 1. 首先计算 reassembler_stream 存储的开头和结尾 index。根据两边的 index 更新 reassembler_stream</span>    <span class="token comment">// 1.1 已经被 reassembled 的 index 就不必再重新 assemble 一遍</span>    <span class="token keyword">auto</span> _start_index <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token operator">-></span>_first_disassembled_index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 1.2 大于 eof 的不必 assemble；大于 capacity 的不能 assemble</span>    <span class="token comment">// 根据上面两条规则，计算两边的 index</span>    <span class="token keyword">auto</span> _index_of_remain_buffer_capacity <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-></span>_first_disassembled_index <span class="token operator">+</span> <span class="token keyword">this</span><span class="token operator">-></span>_capacity <span class="token operator">-</span> <span class="token keyword">this</span><span class="token operator">-></span>_output<span class="token punctuation">.</span><span class="token function">buffer_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// end 结尾不计算 eof，应该是当前 first_disassembled_index（已经读取到的 index）+ 剩余未进入 BufferStream 缓冲区的容量</span>    <span class="token keyword">auto</span> _end_index <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>index <span class="token operator">+</span> data<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">min</span><span class="token punctuation">(</span>_index_of_remain_buffer_capacity<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token operator">-></span>_eof_index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 2. 更新 eof</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>eof<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token operator">-></span>_eof_index <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-></span>_eof_index<span class="token punctuation">,</span> index <span class="token operator">+</span> data<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 执行 1 中对 reassembler_stream 的 assemble 操作</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> _start_index<span class="token punctuation">,</span> j <span class="token operator">=</span> _start_index <span class="token operator">-</span> index<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> _end_index<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">,</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">auto</span> <span class="token operator">&amp;</span>t <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-></span>_reassembler_stream<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span>i <span class="token operator">%</span> <span class="token keyword">this</span><span class="token operator">-></span>_capacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>second<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 重复进入了缓冲区，代表着重复读取了元素，直接抛弃</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>first <span class="token operator">!=</span> data<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">throw</span> <span class="token function">runtime_error</span><span class="token punctuation">(</span><span class="token string">"StreamReassembler::push_substring: Current char has been written!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 代表着进入了 reassembler 的缓冲区</span>            t <span class="token operator">=</span> <span class="token function">make_pair</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token operator">-></span>_disassembled_count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    string _str<span class="token punctuation">;</span>    <span class="token comment">// 3. 接下来需要处理已经在缓冲区的新元素，first_disassembled_index「一路向前」，直到碰到没有 assembled 的元素为止。</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-></span>_first_disassembled_index <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token operator">-></span>_eof_index <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token operator">-></span>_reassembler_stream<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-></span>_first_disassembled_index <span class="token operator">%</span> <span class="token keyword">this</span><span class="token operator">-></span>_capacity<span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        _str<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-></span>_reassembler_stream<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-></span>_first_disassembled_index <span class="token operator">%</span> <span class="token keyword">this</span><span class="token operator">-></span>_capacity<span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token operator">-></span>_reassembler_stream<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token operator">-></span>_first_disassembled_index <span class="token operator">%</span> <span class="token keyword">this</span><span class="token operator">-></span>_capacity<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token operator">-></span>_first_disassembled_index<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token operator">-></span>_disassembled_count<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 4. 当我们收集了一定的 _str 后，向 ByteStream 中写入这些字符串</span>    <span class="token keyword">this</span><span class="token operator">-></span>_output<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>_str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 5. 最后，如果 first_disassembled_index「追上了」eof_index，则表明当前当前读取完毕</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-></span>_first_disassembled_index <span class="token operator">==</span> <span class="token keyword">this</span><span class="token operator">-></span>_eof_index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token operator">-></span>_eof <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token operator">-></span>_output<span class="token punctuation">.</span><span class="token function">end_input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>size_t <span class="token class-name">StreamReassembler</span><span class="token double-colon punctuation">::</span><span class="token function">unassembled_bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token operator">-></span>_disassembled_count<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token keyword">bool</span> <span class="token class-name">StreamReassembler</span><span class="token double-colon punctuation">::</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token operator">-></span><span class="token function">unassembled_bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zhuanlan.zhihu.com/p/20551290958">https://zhuanlan.zhihu.com/p/20551290958</a></p><p><a href="https://lrl52.top/996/cs144-lablab1/">https://lrl52.top/996/cs144-lablab1/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="装逼" scheme="https://blog.pengdonglai.com/categories/%E8%A3%85%E9%80%BC/"/>
    
    <category term="CS144" scheme="https://blog.pengdonglai.com/categories/%E8%A3%85%E9%80%BC/CS144/"/>
    
    
    <category term="Network" scheme="https://blog.pengdonglai.com/tags/Network/"/>
    
    <category term="Lab" scheme="https://blog.pengdonglai.com/tags/Lab/"/>
    
  </entry>
  
  <entry>
    <title>环境变量配置</title>
    <link href="https://blog.pengdonglai.com/2025/02/03/env-book-1/"/>
    <id>https://blog.pengdonglai.com/2025/02/03/env-book-1/</id>
    <published>2025-02-03T06:51:38.000Z</published>
    <updated>2025-02-04T14:11:33.111Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="WSL"><a href="#WSL" class="headerlink" title="WSL"></a>WSL</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wsl <span class="token parameter variable">--install</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这会默认安装 <code>Ubuntu</code>，可以参照官网介绍（<a href="https://learn.microsoft.com/zh-cn/windows/wsl/install#change-the-default-linux-distribution-installed">https://learn.microsoft.com/zh-cn/windows/wsl/install#change-the-default-linux-distribution-installed</a>）安装其他发行版</p><p>安装完成后重启电脑，在开始菜单中打开 <code>Ubuntu</code>，打开后根据提示输入用户名和密码创建默认管理员用户。</p><p>第一次进入窗口可能会提示如下信息（如果没遇到这个信息可以跳过这一步）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">The WSL optional component is not enabled. Please <span class="token builtin class-name">enable</span> it and try again.See https://aka.ms/wslinstall <span class="token keyword">for</span> details.Error: 0x8007007ePress any key to continue<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>打开控制面板 &#x3D;&#x3D;&#x3D;&gt; 程序 &#x3D;&#x3D;&#x3D;&gt; 启用或关闭windows 功能，</p><p>系统为64位的 需要勾选 适用于 <code>Linux</code> 的 <code>windows</code> 子系统 、<code>Hyper-v</code><br>系统为32位的 需要勾选 适用于 <code>Linux</code> 的 <code>windows</code> 子系统 、虚拟机平台</p><p>完成上面设置之后重启电脑即可</p><h3 id="升级命令包"><a href="#升级命令包" class="headerlink" title="升级命令包"></a>升级命令包</h3><p><code>WSL</code> 默认的软件源列表（<code>/etc/apt/sources.list</code>）可能未更新，导致无法找到最新版本的软件包。</p><p>许多工具（如 <code>mininet</code>、<code>wireshark</code>）位于 <code>Ubuntu</code> 的 <code>Universe</code> 或 <code>Multiverse</code> 仓库中，但 <code>WSL</code> 默认可能未启用这些仓库。启用 <code>Universe</code>&#x2F;<code>Multiverse</code> 仓库：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> update <span class="token operator">&amp;&amp;</span> <span class="token function">sudo</span> <span class="token function">apt</span> upgrade<span class="token function">sudo</span> add-apt-repository universe<span class="token function">sudo</span> add-apt-repository multiverse<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="配置命令行-zsh"><a href="#配置命令行-zsh" class="headerlink" title="配置命令行 zsh"></a>配置命令行 zsh</h3><p>理想当中的命令行：</p><ol><li>好看（配色、字体可以自由设定）；</li><li>支持 UTF-8 字符的输入与显示；</li><li>支持常见的 *NIX 命令行工具（cat、grep、awk 等）；</li><li>自动补全、语法高亮、历史记录；</li><li>完善的复制粘贴支持；</li><li>互操作性（共享文件系统、网络栈，可调用 Win32 程序）；</li><li>支持常用的脚本语言（PHP、Python、Node.js 等）；</li><li>包管理器，以及其他各种常用软件的支持；</li><li>快速呼出（快捷键、右键菜单入口）。</li></ol><p>安装 zsh：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> <span class="token function">zsh</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>设置 zsh 为默认命令行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">chsh <span class="token parameter variable">-s</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">which</span> <span class="token function">zsh</span><span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行后需要输入密码，之后重启终端即可看到设置生效了，也可以通过 <code>echo $SHELL</code> 命令查看当前命令行是否是 <code>/bin/zsh</code></p><h3 id="zsh-配置-Proxy（不在国内可以跳过）"><a href="#zsh-配置-Proxy（不在国内可以跳过）" class="headerlink" title="zsh 配置 Proxy（不在国内可以跳过）"></a>zsh 配置 Proxy（不在国内可以跳过）</h3><blockquote><p>注意：它仅仅只用来配置 zsh，安装了 oh-my-zsh 后就会失效，因为 <code>~/.zshrc</code> 会被覆盖。</p></blockquote><p>如果遇到：「wsl: 检测到 <code>localhost</code> 代理配置，但未镜像到 WSL。<br>NAT 模式下的 WSL 不支持 <code>localhost</code> 代理。」，<br>可以在 <code>C:\Users\[username]</code> 目录下创建 <code>.wslconfig</code> 文件，写入:</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">[experimental]autoMemoryReclaim=gradualnetworkingMode=mirroreddnsTunneling=truefirewall=trueautoProxy=true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在 PowerShell 中用 <code>wsl --shutdown</code> 命令关闭 <code>WSL</code>，再重启终端。</p><p><code>WSL2</code> 的网络是连接自 <code>Windows</code> 的一个单独网络，所以无法直接使用到 <code>Windows</code> 中开启的代理，但是可以通过设置代理为 <code>Windows IP</code> + 代理端口号实现</p><p>首先在代理软件中开启「允许来至局域网的连接」</p><p>「本机 <code>sockets</code> 端口」对应的端口号也就是 <code>Windows</code> 代理的端口号，而一般我们在 <code>Clash</code> 中使用的 <code>http</code> 端口号，则为 <code>sockets</code> 端口 + 1。</p><p>假设我们用到的是 <code>9090</code>.</p><p><code>Windows IP</code> 地址是可能变化的，可以利用上面提到的 <code>WSL</code> 网络连接自 <code>Windows</code> 这一点，从 <code>/etc/resolv.conf</code> 文件中自动获取</p><p>之后通过 <code>code ~/.zshrc</code> 或 <code>vim ~/.zshrc</code> 在 zsh 配置中添加:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">host_ip</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">cat</span> /etc/resolv.conf <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"nameserver"</span> <span class="token operator">|</span> <span class="token function">cut</span> <span class="token parameter variable">-f</span> <span class="token number">2</span> <span class="token parameter variable">-d</span> <span class="token string">" "</span><span class="token variable">)</span></span><span class="token assign-left variable">proxy_port</span><span class="token operator">=</span><span class="token number">10809</span><span class="token builtin class-name">alias</span> <span class="token assign-left variable">proxy</span><span class="token operator">=</span><span class="token string">"all_proxy=http://<span class="token variable">$host_ip</span>:<span class="token variable">$proxy_port</span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>运行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> ~/.zshrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>让配置生效，之后运行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> www.google.com <span class="token comment"># 失败</span>proxy <span class="token function">curl</span> www.google.com <span class="token comment"># 成功</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>你可以看到，当我们在 <code>curl</code> 请求命令前增加 <code>proxy</code>，这就意味着我们使用了 <code>windows</code> 代理进行了访问。随后的 <code>oh-my-zsh</code> 的安装就说明了这一点。</p><p>如果还是无法正常使用代理，可能是因为防火墙的原因，可以在 Windows 命令行中以管理员身份执行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">New-NetFirewallRule <span class="token parameter variable">-DisplayName</span> <span class="token string">"WSL"</span> <span class="token parameter variable">-Direction</span> Inbound  <span class="token parameter variable">-InterfaceAlias</span> <span class="token string">"vEthernet (WSL)"</span>  <span class="token parameter variable">-Action</span> Allow<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>防火墙设置如果遇到：「New-NetFirewallRule : The specified interface was not found on the system.」，需要将命令中的 <code>vEthernet (WSL)</code> 替换为「Windows Defender 防火墙属性 -&gt; 公用配置文件 -&gt; 受保护的网络连接-自定义」中实际的 <code>vEthernet-WSL</code> 名称</p><h3 id="配置-oh-my-zsh"><a href="#配置-oh-my-zsh" class="headerlink" title="配置 oh-my-zsh"></a>配置 oh-my-zsh</h3><p>运行命令安装 oh-my-zsh</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">proxy <span class="token function">curl</span> <span class="token parameter variable">-fsSL</span> https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh <span class="token operator">|</span> <span class="token function">sh</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>随后安装：</p><ul><li>zsh-syntax-highlighting：提供语法高亮功能</li><li>zsh-autosuggestions：根据历史命令提供建议</li></ul><p>运行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/zsh-users/zsh-syntax-highlighting.git <span class="token variable">$&#123;ZSH_CUSTOM<span class="token operator">:-</span>~<span class="token operator">/</span>.oh-my-zsh<span class="token operator">/</span>custom&#125;</span>/plugins/zsh-syntax-highlighting<span class="token function">git</span> clone https://github.com/zsh-users/zsh-autosuggestions <span class="token variable">$&#123;ZSH_CUSTOM<span class="token operator">:-</span>~<span class="token operator">/</span>.oh-my-zsh<span class="token operator">/</span>custom&#125;</span>/plugins/zsh-autosuggestions<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>随后在 <code>~/.zshrc</code> 中，修改主题和插件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">plugins</span><span class="token operator">=</span><span class="token punctuation">(</span>        <span class="token function">git</span>        <span class="token function">sudo</span>        z        zsh-autosuggestions        zsh-syntax-highlighting<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">ZSH_THEME</span><span class="token operator">=</span><span class="token string">"agnoster"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="配置-Git"><a href="#配置-Git" class="headerlink" title="配置 Git"></a>配置 Git</h3><p>注意，以下两种方法，二选一即可。</p><h4 id="通过共享-Windows-的信息"><a href="#通过共享-Windows-的信息" class="headerlink" title="通过共享 Windows 的信息"></a>通过共享 Windows 的信息</h4><p>通过<strong>在 Windows 命令提示符或 PowerShell 中</strong>运行以下命令，在 Windows 上配置凭据管理器：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config <span class="token parameter variable">--global</span> credential.helper wincred<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>配置 WSL 以使用相同的凭据帮助程序，<strong>在 WSL 终端</strong>中运行以下命令（假设您有git&gt;&#x3D; v2.39.0）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config <span class="token parameter variable">--global</span> credential.helper <span class="token string">"/mnt/c/Program\ Files/Git/mingw64/bin/git-credential-manager.exe"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（exe 路径可能需要修改）</p><p>要了解以前版本的路径 git，请参考 <a href="https://learn.microsoft.com/en-us/windows/wsl/tutorials/wsl-git">https://learn.microsoft.com/en-us/windows/wsl/tutorials/wsl-git</a></p><h4 id="通过设置-SSH"><a href="#通过设置-SSH" class="headerlink" title="通过设置 SSH"></a>通过设置 SSH</h4><p>将 Git 更新至适合 WSL 的最新稳定版本。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token function">git</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>设置用户名 (Github ID)</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config <span class="token parameter variable">--global</span> user.name <span class="token string">"your_name"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>设置邮箱 (Github email)</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config <span class="token parameter variable">--global</span> user.email <span class="token string">"your_email"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 WSL 下生成 SSH 公钥—私钥对（将邮箱替换为你的邮箱），此时生成的 SSH 密钥默认位于 <code>~/.ssh</code> 路径下，公钥为 <code>id_rsa.pub</code>，私钥为 <code>id_rsa</code></p><p>执行完后只需一路回车即可</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-keygen <span class="token parameter variable">-t</span> rsa <span class="token parameter variable">-b</span> <span class="token number">4096</span> <span class="token parameter variable">-C</span> <span class="token string">"your_email"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>打开 <code>ssh-agent</code> 使之在后台运行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">eval</span> <span class="token string">"<span class="token variable"><span class="token variable">$(</span>ssh-agent <span class="token parameter variable">-s</span><span class="token variable">)</span></span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将私钥添加到 <code>ssh-agent</code> 之中</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-add ~/.ssh/id_rsa<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看并复制公钥</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> ~/.ssh/id_rsa.pub<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将复制的公钥信息添加到 Github&#x2F;Gitee</p><h3 id="Clion-初始化"><a href="#Clion-初始化" class="headerlink" title="Clion 初始化"></a>Clion 初始化</h3><p><code>C++</code> 一般是用在 <code>linux</code> 下，这里就用 <code>Ubuntu</code> 进行开发，考虑到 <code>window</code> 系统，这里准备用 <code>wsl2</code>.</p><blockquote><p>首先请必须先行完成上述配置后，再进行 Clion 和 WSL 的结合开发。</p></blockquote><p>运行命令，安装必备的工具链（直接从 CS144 的课程里面扒下来的，反正迟早都得安装 0.0）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt-get</span> <span class="token function">install</span> g++ <span class="token function">git</span> clang-tidy clang-format libpcap-dev <span class="token punctuation">\</span>    iptables mininet tcpdump telnet wireshark socat netcat-openbsd <span class="token punctuation">\</span>    doxygen graphviz cmake gdb gcc clang<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>安装完毕后，我们打开 Clion，进入<br>Settings –&gt; Build, Execution, Deployment –&gt; Toolchains. 点击 add</p><div align="center">  <img src="../../../../loading2.svg" data-original="/2025/02/03/env-book-1/1.png"></div><p>之后，Clion 会识别到你刚刚安装好的各种工具，如图所示，就算是成功了。</p><p>这样相关的文件就是 Ubuntu 中，此时编译如果 cmake 版本过低， Clion 会有提示，可以根据提示修改 CMakeLists.txt 中最底的版本，一个建议为：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cmake_minimum_required<span class="token punctuation">(</span>VERSION <span class="token number">3.22</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后我们来到<br>Settings –&gt; Tools –&gt; Terminal</p><p>修改 Shell path：</p><p>替换默认的 PowerShell 路径为 WSL 的 Bash 路径为 <code>C:\Windows\System32\wsl.exe</code></p><p>点击 Apply → OK。</p><p>这些步骤完成后，最好是新建一个 Clion 的 Hello, world! 项目，来验证自己的工具是否完成。</p><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><h2 id="MacOS"><a href="#MacOS" class="headerlink" title="MacOS"></a>MacOS</h2><h2 id="关于-WSL-的介绍"><a href="#关于-WSL-的介绍" class="headerlink" title="关于 WSL 的介绍"></a>关于 WSL 的介绍</h2><p><strong>WSL（Windows Subsystem for Linux）</strong> 是微软为 Windows 系统提供的一种兼容层技术，允许用户在 Windows 上直接运行原生 Linux 二进制文件（无需传统虚拟机或双系统）。以下是 WSL、虚拟机（如 VMware&#x2F;VirtualBox）和原生双系统的核心区别：</p><hr><h3 id="1-WSL（Windows-Subsystem-for-Linux）"><a href="#1-WSL（Windows-Subsystem-for-Linux）" class="headerlink" title="1. WSL（Windows Subsystem for Linux）"></a><strong>1. WSL（Windows Subsystem for Linux）</strong></h3><h4 id="核心特点"><a href="#核心特点" class="headerlink" title="核心特点"></a><strong>核心特点</strong></h4><ul><li><strong>轻量级</strong>：<br>通过子系统（非虚拟化）直接调用 Linux 内核接口（WSL2 基于轻量级 Hyper-V 虚拟化），资源占用低。</li><li><strong>无缝集成</strong>：  <ul><li>可直接访问 Windows 文件系统（如 <code>/mnt/c</code> 对应 <code>C:</code> 盘）。  </li><li>支持在 Windows 终端中运行 Linux 命令，甚至混合使用（如 <code>ls | clip.exe</code>）。</li></ul></li><li><strong>性能</strong>：  <ul><li><strong>文件系统性能</strong>：WSL2 的 Linux 文件系统性能接近原生，但 Windows 文件系统的跨系统访问较慢。  </li><li><strong>计算密集型任务</strong>（如编译）：性能接近原生 Linux。</li></ul></li><li><strong>适用场景</strong>：  <ul><li>开发者需要 Linux 工具链（如 <code>gcc</code>、<code>python</code>）。  </li><li>轻量级 Linux 环境测试或学习 Shell 脚本。</li></ul></li></ul><hr><h3 id="2-虚拟机（VMware-VirtualBox-Hyper-V）"><a href="#2-虚拟机（VMware-VirtualBox-Hyper-V）" class="headerlink" title="2. 虚拟机（VMware&#x2F;VirtualBox&#x2F;Hyper-V）"></a><strong>2. 虚拟机（VMware&#x2F;VirtualBox&#x2F;Hyper-V）</strong></h3><h4 id="核心特点-1"><a href="#核心特点-1" class="headerlink" title="核心特点"></a><strong>核心特点</strong></h4><ul><li><strong>完全隔离</strong>：<br>通过 Hypervisor 虚拟化硬件，运行完整的独立操作系统（包括内核），与宿主机完全隔离。</li><li><strong>资源占用高</strong>：<br>需要分配固定内存、CPU 和磁盘空间，运行时会占用较多资源。</li><li><strong>灵活性</strong>：  <ul><li>可安装任意操作系统（如 macOS、BSD）和发行版。  </li><li>支持快照、克隆等高级功能。</li></ul></li><li><strong>性能损失</strong>：<br>虚拟化层导致计算和 I&#x2F;O 性能有约 10-20% 的损失（尤其是图形密集型任务）。</li><li><strong>适用场景</strong>：  <ul><li>需要完整 Linux 桌面环境（如 GNOME&#x2F;KDE）。  </li><li>多系统兼容性测试或运行 Windows 不支持的软件（如旧版 macOS）。</li></ul></li></ul><hr><h3 id="3-原生双系统（Windows-Linux）"><a href="#3-原生双系统（Windows-Linux）" class="headerlink" title="3. 原生双系统（Windows + Linux）"></a><strong>3. 原生双系统（Windows + Linux）</strong></h3><h4 id="核心特点-2"><a href="#核心特点-2" class="headerlink" title="核心特点"></a><strong>核心特点</strong></h4><ul><li><strong>独立运行</strong>：<br>通过分区安装两个系统，每次启动需选择进入 Windows 或 Linux。</li><li><strong>性能最优</strong>：<br>直接使用硬件资源，无虚拟化或兼容层开销，适合高性能需求（如游戏、科学计算）。</li><li><strong>无互操作性</strong>：  <ul><li>无法同时运行两个系统，文件系统默认不互通（需手动挂载分区）。  </li><li>硬件资源（如 GPU）独占使用。</li></ul></li><li><strong>适用场景</strong>：  <ul><li>需要最大化 Linux 性能（如深度学习、渲染）。  </li><li>长期专注于 Linux 开发或生产环境。</li></ul></li></ul><hr><h3 id="三者的对比总结"><a href="#三者的对比总结" class="headerlink" title="三者的对比总结"></a><strong>三者的对比总结</strong></h3><table><thead><tr><th><strong>维度</strong></th><th><strong>WSL</strong></th><th><strong>虚拟机</strong></th><th><strong>原生双系统</strong></th></tr></thead><tbody><tr><td><strong>性能</strong></td><td>接近原生（计算任务）</td><td>有虚拟化损失</td><td>原生性能</td></tr><tr><td><strong>资源占用</strong></td><td>低（仅需少量内存）</td><td>高（需预分配资源）</td><td>独占硬件</td></tr><tr><td><strong>启动速度</strong></td><td>秒级启动</td><td>分钟级启动</td><td>依赖硬件启动速度</td></tr><tr><td><strong>系统隔离</strong></td><td>部分隔离（共享内核或轻量虚拟化）</td><td>完全隔离</td><td>完全独立</td></tr><tr><td><strong>文件互操作</strong></td><td>直接访问双方文件系统</td><td>需共享文件夹或网络传输</td><td>需手动挂载分区</td></tr><tr><td><strong>适用场景</strong></td><td>开发、轻量级 Linux 任务</td><td>多系统测试、完整 Linux 桌面</td><td>高性能需求、长期 Linux 工作</td></tr></tbody></table><hr><h3 id="选择建议"><a href="#选择建议" class="headerlink" title="选择建议"></a><strong>选择建议</strong></h3><ul><li><strong>日常开发&#x2F;学习 Linux</strong>：优先选择 <strong>WSL</strong>（快速、轻便）。  </li><li><strong>多系统兼容性测试</strong>：使用 <strong>虚拟机</strong>（灵活、安全）。  </li><li><strong>高性能计算&#x2F;游戏</strong>：安装 <strong>原生双系统</strong>（资源独占、无性能损失）。  </li><li><strong>图形化 Linux 需求</strong>：虚拟机或双系统（WSL 对 GUI 支持有限，需额外配置）。</li></ul><p>通过理解这些差异，可以根据需求选择最适合的方案。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="开箱即用" scheme="https://blog.pengdonglai.com/categories/%E5%BC%80%E7%AE%B1%E5%8D%B3%E7%94%A8/"/>
    
    
    <category term="开箱即用" scheme="https://blog.pengdonglai.com/tags/%E5%BC%80%E7%AE%B1%E5%8D%B3%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>海星来来的 2024 总结</title>
    <link href="https://blog.pengdonglai.com/2025/01/30/2024-summary/"/>
    <id>https://blog.pengdonglai.com/2025/01/30/2024-summary/</id>
    <published>2025-01-30T04:48:27.000Z</published>
    <updated>2025-02-03T06:42:43.804Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="海星来来的-2024-总结-´∀-♥"><a href="#海星来来的-2024-总结-´∀-♥" class="headerlink" title="海星来来的 2024 总结 (*´∀&#96;)~♥"></a>海星来来的 2024 总结 (*´∀&#96;)~♥</h1><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;/2024>&lt;2025><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="📑-按照惯例的碎碎念"><a href="#📑-按照惯例的碎碎念" class="headerlink" title="📑 按照惯例的碎碎念"></a>📑 按照惯例的碎碎念</h2><p>2024 年实际上没有什么好说的，因为我一直在打工。打工的时候遭遇过低谷，但走出来后也就云淡风轻了。此时此刻，我有很多想说的东西，可是真的要吐露了，我又觉得这是一件没必要的事情。那就等我想好了，再来补充吧。（也很可能不会补充了）</p><p>2025，希望在保持现有势头的同时，可以多尝试一些新事物。</p><h2 id="💠-年度纪念品"><a href="#💠-年度纪念品" class="headerlink" title="💠 年度纪念品"></a>💠 年度纪念品</h2><blockquote><p>一般来说，选择纪念品作为本年度的代表物，是非常有意义的一件事。当我试图找寻以前的记忆，我发现总是一些纪念品，它们成为了我的「锚点」，和记忆一起成为了心流中印象最深刻的部分。哪怕是有一天不写文字总结了，我也要将这个部分单独写出来，成为我的年度记忆。</p></blockquote><h3 id="1-1-🎶-音乐"><a href="#1-1-🎶-音乐" class="headerlink" title="1.1 🎶 音乐"></a>1.1 🎶 音乐</h3><p>本年度的年初，我偶然找到了一份歌单，它是贝多芬的钢琴奏鸣曲全集。所以，我今年<s>抛弃了肖邦</s>，开始精听贝多芬的交响。毫无疑问，九首交响是它最伟大的交响作品。</p><p>但是，我想把纪念品颁给《第三号钢琴协奏曲》。我把我认为比较好的一个版本（并不是我最喜欢的版本，但这个版本的受众应该会足够多），推荐给你：</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 56.3%; margin: 20px 0"><iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://www.youtube-nocookie.com/embed/MZudOTnSk9k?si=CrDrMvAwP7eXgkl9" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe></div><p>你可以在一些网站和文献中找到对于它普遍的描述：这部作品标志着贝多芬协奏曲创作风格的转折，开始脱离古典主义传统向浪漫主义迈进。在继承莫扎特创作手法的基础上，出现了他个性中追求的戏剧性冲突，钢琴被赋予明显的激情和力量，如第一乐章有浪漫的英雄主义情怀和交响诗韵味，第二乐章有史诗般意境。</p><p>我不是分析乐理的专家，但它之所以得奖，正是因为一般性分析中的「转变时刻」。</p><p>它陪着我度过了 2024 中最为困难的一段时期。年中的时候，我所在的业务发生变动，自己的地盘被逐步蚕食，并且因为各种各样的原因，其它人正在寻找我的替代品。在渡过困境的过程中，如果说我的伙伴是我的第一功臣，那么贝多芬就是第二功臣。如果只是我以前听过的曲目——你让我理性分析它会更有力量，但是音乐欣赏这个东西更多出于感性。所以，正是《第三号钢琴协奏曲》陪伴了我走过工作中的低谷，它也是我在这一年内我印象最深刻的贝多芬，也让我对贝多芬的转变的时刻，有了更深刻的认识。</p><p>古典是严肃的，浪漫主义是富有力量的。严肃虽然会让我们做事拥有更高的准确度，但也容易让我们陷入不思进取的陷阱。浪漫主义有很多类型，但是它的内在是积极的，它的核心正是一颗勇敢之心，和赤诚的热血。</p><h3 id="1-2-🎬️-动漫"><a href="#1-2-🎬️-动漫" class="headerlink" title="1.2 🎬️ 动漫"></a>1.2 🎬️ 动漫</h3><p>说到 2024 年的动漫，纪念品毫无疑问就是：</p><div align="center">  <img alt="我知道你肯定想说的是它.png" src="../../../../loading2.svg" data-original="/2025/01/30/2024-summary/4.png"></div><p>《败犬女主太多了》是一部由 A-1 Pictures 制作的校园恋爱喜剧动画，于 2024 年 7 月 13 日至 9 月 28 日播出，全 12 集。</p><p>这部作品以「败犬女主」为核心，跳出了传统校园恋爱动画中男女主恋爱养成的常规套路。观众看腻了常见的恋爱模式后，这种聚焦于恋爱失败后的女主们如何成长<s>和贡献名场面</s>的故事，带来了全新的观剧体验。它的作画我也非常喜欢，这部作品在画面上精益求精，摄影的实拍感很强，对光线、阴影、色彩的运用都非常巧妙。比如逆光时人物大面积阴影以及下颌线青蓝色的反光处理得自然真实；通过青黄偏青的色彩彰显夏日青春和躁动。</p><p>毫无疑问，兄弟般的女孩子自然很受到我们宅男的喜欢。老八和温水的相遇就已经是非常满足宅男幻想但平时毫无疑问求之不得的情景——在家庭餐厅碰见温水，因没钱让温水代垫，后提出做便当作出赔偿，之后作为败北女主和温水行动。虽然毫无疑问人气最高的是老八，<s>并且老八真是败犬？也不普通好嘛</s>但是看似普通的每一位女主都有大量拥簇且人设都相当好。败犬的喜剧效果自然也贡献了很多名梗，看看 B 站的逆天级别数量的二创自然就能明白。</p><p>总而言之，B 站虽然没引入这一作（仔细想想确实是这样？），但是它毫无疑问是 2024 讨论热度最高的一部作品，也是我最喜欢的作品之一。</p><h3 id="1-3-🎮-游戏"><a href="#1-3-🎮-游戏" class="headerlink" title="1.3 🎮 游戏"></a>1.3 🎮 游戏</h3><p>今年买我了新电脑！！所以我重新回归了 Steam。我玩了黑神话悟空，极限竞速地平线 4 等等，但是首先，我自然是要重新做回一个柚子厨！<code>Ciallo～(∠・ω&lt; )⌒☆</code></p><p>（明年我想把年度游戏给黑神话，所以别问了别问了，但我就是想做柚子厨。）</p><p>（不信？你点点鼠标呀~）</p><p>2024 年内，我补完了柚子 2019 到 2023 的新作品，虽然你大概率也知道它们，但我还是忍不住向你介绍，(≧ω≦)✨ 所以，柚子社的甜蜜时光列车发车咯！</p><ul><li>2019《喫茶ステラと死神の蝶》</li></ul><p>咖啡香气与死神镰刀の奇妙碰撞！🌼 这一作我只玩了夏目线和小希线。柚子社一向是牛逼的设定但是配合了一个平凡的展开，所以说它的剧情确实没有什么可以讲的。四季夏目人设自然是里面最好的那一个，加上平凡的剧情但是不平凡的个人剧情，所以我当即决定第一个就推她。</p><p><s>上班之后我逐渐变得 M，所以我喜欢夏目也丝毫是一个不奇怪的选择。</s>但是一般来说，这种类型的角色其实挺难驾驭的，因为她们天生就会男主没有什么好感。四季夏目一开始就是非常冷冰冰的态度，男主在共通线的努力让大家有目共睹，作为咖啡店的老板夏目有了一个喜欢上主角的理由。但直到进线，我其实都不太能看得出男主是否能成功攻略夏目。</p><p>个人线中，夏目的人设发挥到了极致，柚子社给你她全系列作品中最好的在一起的 CG 之一——凌晨之时，寒冬之下，两个人虽然暂未确认关系，但他们的心早已连接在一起。随着后面我们了解到夏目的信息越来越多，她作为一个弱者的一面也逐渐被我们所了解。男主真正成为她倚靠的同时，他们也已经真正在一起了。</p><div align="center">  <img alt="本作最爱也是第一推：四季夏目" src="../../../../loading2.svg" data-original="/2025/01/30/2024-summary/2.png"></div><ul><li>2023《天使☆騒々 RE-BOOT!》</li></ul><p>这一作纯萌拔作，如果说喫茶ステラと死神の蝶我还可以用比较文艺的口吻来讲述一些过程，这一作我就只记得一些梗了。确实<s>某些部分</s>很有意思也很实用，但确实不适合展开来说。</p><p>人设方面，我喜欢小云雀来海，且我也是第一个推的她。且问，谁会拒绝一个你来教室前就坐在你座位上，大方和你聊天的女孩子呢？</p><div align="center">  <img alt="本作最爱也是第一推：小云雀来海" src="../../../../loading2.svg" data-original="/2025/01/30/2024-summary/1.png"></div><p>但要论年度游戏，作为忠实的柚子厨我确实不想给到上面两作…，我仍然还是想颁给《サノバウィッチ》即（魔女的夜宴）。今年的新作还没出，但我仍然有较大的把我认为魔女的夜宴仍旧是柚子社最好的作品。在我今年想颁发这个纪念品给柚子社的情况下，《魔女的夜宴》一定是要占据一席之地的。</p><p>绫地宁宁用「时间回溯」的剧情温柔刀捅哭所有人！，剧情虽然说老套，但是在玩家的爱意和精心塑造的氛围的影响下，每过一边宁宁的剧情，仍然还是会感觉很难受。除了宁宁，因潘巡、椎叶紬妈妈、学姐的剧情实际上都做的很好，令人印象深刻。</p><p>有时间我还是想做柚子社专题，虽然确实不如 b 站和知乎大神做的好，但我会努力表达自己想写的东西~ Flag++</p><div align="center">  <img alt="平等的爱给到每一位女主~" src="../../../../loading2.svg" data-original="/2025/01/30/2024-summary/3.png"></div><h2 id="🌞-我的足迹"><a href="#🌞-我的足迹" class="headerlink" title="🌞 我的足迹"></a>🌞 我的足迹</h2><p>今年主要在大湾区范围内活动，去了广州和澳门。</p><ul><li>澳门</li></ul><div align="center">  <img alt="赌场夜景" src="../../../../loading2.svg" data-original="/2025/01/30/2024-summary/5.jpg"></div><p>在澳门的时候，被当作小孩子<s>这是借口，实际上是没有带身份证</s>不给进赌场，导致我现在还在疑惑赌场是否真的有免费食物以及免费食物好不好吃。</p><div align="center">  <img alt="葡式餐厅" src="../../../../loading2.svg" data-original="/2025/01/30/2024-summary/6.jpg"></div><p>导游小姐姐给我们介绍澳门风土人情，并且着重强调了澳门的高福利。于是在饭局上我问导游小姐姐怎么入籍澳门…</p><ul><li>广州</li></ul><div align="center">  <img alt="坐上了心心念念的南中珠城际——广州地铁18号线" src="../../../../loading2.svg" data-original="/2025/01/30/2024-summary/7.jpg"></div><p>地铁迷怎么会错过南中珠城际！</p><div align="center">  <img alt="拍了下住的地方" src="../../../../loading2.svg" data-original="/2025/01/30/2024-summary/8.png"></div><p>因为人生地不熟随机找了个看上去视野好的酒店（此时我还不知道这个酒店有多么吊 0.0），但是它确实没让我失望，视野真的超棒！服务也很好。</p><p>实际上我还拍了广州塔的照片，但是实在拍的太差所以就不放了…</p><p>2025 一定要去更多的地方！！最好出国玩。</p><h2 id="📚-2024-目标总结"><a href="#📚-2024-目标总结" class="headerlink" title="📚 2024 目标总结"></a>📚 2024 目标总结</h2><h3 id="🌱-做得好的"><a href="#🌱-做得好的" class="headerlink" title="🌱 做得好的"></a>🌱 做得好的</h3><ul><li>运动量水平，这个确实在慢慢恢复并且开始坚持。皮肤状态相比于以前好了不少~</li><li>理财收益借着 2024 美股的大牛尤其是英伟达和特斯拉超额完成目标，这是理财小白最好的负学费礼物~</li><li>学习了一些日语，渐渐可以看懂一些文字了，也考了 N2。</li><li>工作实现了一定突破，也开始拓展自己的技术栈。</li></ul><h3 id="🥹-做得不太好的"><a href="#🥹-做得不太好的" class="headerlink" title="🥹 做得不太好的"></a>🥹 做得不太好的</h3><ul><li>没有完成一门国外的计算机课程，6.824 甚至都没有去找视频看。</li><li>英语学习没有持之以恒，但这个在 2025 年也不一定能做好，可以给自己找个事情来破局。</li><li>看番剧、看书没有以前多了。</li></ul><h2 id="🚀-2025-目标"><a href="#🚀-2025-目标" class="headerlink" title="🚀 2025 目标"></a>🚀 2025 目标</h2><ul><li>把英语重新捡起来，可以给自己找点事情做，比如在翻译组里面翻译一些高质量英语文章。</li><li>继续尝试不同类型的稳健投资。</li><li>日语更加精进，今年内希望可以慢慢达到啃生肉的水平。</li><li>晋升！！然后继续攒钱。</li><li>静下心来玩更多 Galgame。</li></ul><h2 id="🌈-ONE-MORE-THING"><a href="#🌈-ONE-MORE-THING" class="headerlink" title="🌈 ONE MORE THING"></a>🌈 ONE MORE THING</h2><p>写这篇文章的时候，Nvidia 暴跌了 17%，可谓是开年美股的第一波重大新闻。DeepSeek 早在一个月前就已经有版本被发布出来，但当时被认为只是一个大模型低成本的使用方式（虽然这种模式也已经足够牛逼，在知乎等平台上也已经有了一定讨论量），但是当 R1 模型出来后，可以说是达到了「震撼全球」的效果。所以这个时刻我想给到这一重大新闻。</p><p>适合发布的文章我已经找好了，等到符合预期了，就发布更新~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="碎碎念" scheme="https://blog.pengdonglai.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
    <category term="碎碎念" scheme="https://blog.pengdonglai.com/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>安卓（2）-语法基础：Kotlin 常用库（1）</title>
    <link href="https://blog.pengdonglai.com/2025/01/29/android-2/"/>
    <id>https://blog.pengdonglai.com/2025/01/29/android-2/</id>
    <published>2025-01-29T11:52:36.000Z</published>
    <updated>2025-01-31T15:17:25.748Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>2024 年我开始逐渐介入客户端的研发，因此我开始学习客户端的知识。<br>从服务端开始，转到前端来其实完全代表着我的编码风格的转变。我喜欢 UI 编程那「所见即所得」的惊艳，也喜欢人机交互相关的内容。<br>做 C 端 App，前端技术实际上更多是一种强行「卷」过来的结果：首先，基础肯定是客户端技术 Android&#x2F;iOS，但是前端的作用越来越清晰。当然，目前的大环境下走入前端甚至客户端开发通常被认为是一种开倒车的举动。但这种东西谁又说得好呢——难道做算法调优几个版本实验指标波动，亦或者做服务端大半夜被机器人打电话就能让人兴奋了吗？<br>人总有无知的时候，在已知信息差的时候我们总有一天要为认知买单。所以就让我们为梦想，做出一次不那么受到束缚的选择吧。<br>这是安卓系列的第一期，它包含以下内容：<br><a href="/2025/01/29/android-1/">安卓（1）-语法基础：Kotlin ＆ Java ＆ TS 对比</a><br><a href="/2025/01/29/android-2/">安卓（2）-语法基础：Kotlin 常用库（1）</a><br><a href="/2025/01/29/android-3/">安卓（3）-实用篇：UI（1）</a><br>我使用了 AI 来辅助我创作了一些重复性的工作，第一期内容会以相关知识的罗列为主，所以最好的阅读方式是阅读后进行查漏补缺。<br>希望大家可以喜欢这些教程！</p></blockquote><p>本文是安卓系列的第二个内容，衔接前一篇内容的 Kotlin 基础语法，主要介绍了 Kotlin 常用库的一些基础用法，学习 Kotlin 常用库的用法可以提高开发效率、增强代码可读性、简化复杂任务、获得社区支持，并提升应用性能，从而更好地利用 Kotlin 的优势构建高效、可维护的应用。</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><table><thead><tr><th>特性</th><th>MutableList</th><th>List</th></tr></thead><tbody><tr><td>可变性</td><td>可变，允许添加、删除和修改元素</td><td>不可变，一旦创建，元素不可修改</td></tr><tr><td>使用场景</td><td>当需要对列表中的元素进行频繁的修改操作时，例如动态存储数据集合，并且需要不断地添加、删除或更新元素时，使用 MutableList。</td><td>当需要存储一组固定的数据，不希望在程序运行过程中对其进行修改，仅用于读取元素或传递不可变的数据集合时，使用 List。</td></tr><tr><td>Kotlin 使用：</td><td></td><td></td></tr></tbody></table><p>以下是 <code>MutableList</code> 和 <code>List</code> 在不同操作上的区别和常用方法的表格：</p><table><thead><tr><th>操作</th><th><code>MutableList</code></th><th><code>List</code></th></tr></thead><tbody><tr><td>构造</td><td>- <code>mutableListOf()</code>：创建一个可变列表，可传入初始元素。<br>例如：<code>val mutableList = mutableListOf(1, 2, 3)</code><br>- <code>ArrayList()</code>（Java 风格）：创建一个空的可变列表，后续可添加元素。<br>例如：<code>val mutableList = ArrayList&lt;Int&gt;()</code></td><td>- <code>listOf()</code>：创建一个不可变列表，可传入初始元素。<br>例如：<code>val list = listOf(1, 2, 3)</code><br>- <code>toList()</code>：将其他集合转换为不可变列表。<br>例如：<code>val list = mutableList.toList()</code></td></tr><tr><td>迭代器</td><td>- <code>iterator()</code>：返回一个迭代器，可用于遍历列表。<br>例如：<br><code>kotlin&lt;br&gt;val mutableList = mutableListOf(1, 2, 3)&lt;br&gt;val iterator = mutableList.iterator()&lt;br&gt;while (iterator.hasNext()) &#123;&lt;br&gt;    val element = iterator.next()&lt;br&gt;    println(element)&lt;br&gt;&#125;&lt;br&gt;</code></td><td>- <code>iterator()</code>：返回一个迭代器，可用于遍历列表。<br>例如：<br><code>kotlin&lt;br&gt;val list = listOf(1, 2, 3)&lt;br&gt;val iterator = list.iterator()&lt;br&gt;while (iterator.hasNext()) &#123;&lt;br&gt;    val element = iterator.next()&lt;br&gt;    println(element)&lt;br&gt;&#125;&lt;br&gt;</code></td></tr><tr><td>过滤</td><td>- <code>filter()</code>：返回一个新的 <code>MutableList</code>，包含满足条件的元素。<br>例如：<br><code>kotlin&lt;br&gt;val mutableList = mutableListOf(1, 2, 3, 4)&lt;br&gt;val filteredList = mutableList.filter &#123; it % 2 == 0 &#125;&lt;br&gt;</code></td><td>- <code>filter()</code>：返回一个新的 <code>List</code>，包含满足条件的元素。<br>例如：<br><code>kotlin&lt;br&gt;val list = listOf(1, 2, 3, 4)&lt;br&gt;val filteredList = list.filter &#123; it % 2 == 0 &#125;&lt;br&gt;</code></td></tr><tr><td>加减操作符</td><td>- <code>+</code>：创建一个新的 <code>MutableList</code>，包含原列表和新元素。<br>例如：<code>val newMutableList = mutableList + 4</code><br>- <code>+=</code>：直接在原列表末尾添加元素。<br>例如：<code>mutableList += 4</code><br>- <code>-</code>：创建一个新的 <code>MutableList</code>，不包含指定元素。<br>例如：<code>val newMutableList = mutableList - 2</code><br>- <code>-=</code>：直接从原列表中移除指定元素。<br>例如：<code>mutableList -= 2</code></td><td>- <code>+</code>：创建一个新的 <code>List</code>，包含原列表和新元素。<br>例如：<code>val newList = list + 4</code><br> <code>-</code>：创建一个新的 <code>List</code>，不包含指定元素。<br>例如：<code>val newList = list - 2</code></td></tr><tr><td>取集合的一部分</td><td>- <code>subList()</code>：返回一个新的 <code>MutableList</code>，包含指定范围的元素。<br>例如：<code>val subMutableList = mutableList.subList(1, 3)</code></td><td>- <code>subList()</code>：返回一个新的 <code>List</code>，包含指定范围的元素。<br>例如：<code>val subList = list.subList(1, 3)</code></td></tr><tr><td>取单个元素</td><td>- <code>get()</code> 或 <code>[]</code>：获取指定位置的元素。<br>例如：<code>val element = mutableList[1]</code></td><td>- <code>get()</code> 或 <code>[]</code>：获取指定位置的元素。<br>例如：<code>val element = list[1]</code></td></tr><tr><td>排序</td><td>- <code>sort()</code>：对原列表进行排序。<br>例如：<code>mutableList.sort()</code><br>- <code>sorted()</code>：返回一个新的 <code>MutableList</code>，包含排序后的元素，原列表不变。<br>例如：<code>val sortedMutableList = mutableList.sorted()</code></td><td>- <code>sorted()</code>：返回一个新的 <code>List</code>，包含排序后的元素，原列表不变。<br>例如：<code>val sortedList = list.sorted()</code></td></tr><tr><td>聚合操作</td><td>- <code>sum()</code>：计算列表元素的总和（元素需为数字类型）。<br>例如：<code>val sum = mutableList.sum()</code><br>- <code>max()</code>：获取列表中的最大值。<br>例如：<code>val max = mutableList.max()</code><br>- <code>min()</code>：获取列表中的最小值。<br>例如：<code>val min = mutableList.min()</code></td><td>- <code>sum()</code>：计算列表元素的总和（元素需为数字类型）。<br>例如：<code>val sum = list.sum()</code><br>- <code>max()</code>：获取列表中的最大值。<br>例如：<code>val max = list.max()</code><br>- <code>min()</code>：获取列表中的最小值。<br>例如：<code>val min = list.min()</code></td></tr><tr><td>更改集合内容的操作（添加或删除元素）</td><td>- <code>add()</code>：在列表末尾添加元素。<br>例如：<code>mutableList.add(5)</code><br>- <code>remove()</code>：移除指定元素。<br>例如：<code>mutableList.remove(3)</code><br>- <code>removeAt()</code>：移除指定位置的元素。<br>例如：<code>mutableList.removeAt(1)</code></td><td>不支持，因为 <code>List</code> 是不可变的，尝试添加或删除元素会导致编译错误。</td></tr><tr><td>总结：<code>MutableList</code> 是可变的，可以对其元素进行添加、删除、修改等操作；而 <code>List</code> 是不可变的，一旦创建，其元素不能被修改，只能进行读取、过滤、聚合等不改变原列表的操作。</td><td></td><td></td></tr></tbody></table><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">fun main() &#123;    &#x2F;&#x2F; 构造    &#x2F;&#x2F; MutableList 的构造    val mutableList &#x3D; mutableListOf(1, 2, 3)    val mutableListJavaStyle &#x3D; ArrayList&lt;Int&gt;()    mutableListJavaStyle.add(4)    mutableListJavaStyle.add(5)    println(&quot;MutableList 构造: $mutableList, $mutableListJavaStyle&quot;)    &#x2F;&#x2F; List 的构造    val list &#x3D; listOf(6, 7, 8)    val listFromMutable &#x3D; mutableList.toList()    println(&quot;List 构造: $list, $listFromMutable&quot;)    &#x2F;&#x2F; 迭代器    &#x2F;&#x2F; MutableList 的迭代器    println(&quot;MutableList 迭代器:&quot;)    val mutableIterator &#x3D; mutableList.iterator()    while (mutableIterator.hasNext()) &#123;        val element &#x3D; mutableIterator.next()        println(element)    &#125;    &#x2F;&#x2F; List 的迭代器    println(&quot;List 迭代器:&quot;)    val listIterator &#x3D; list.iterator()    while (listIterator.hasNext()) &#123;        val element &#x3D; listIterator.next()        println(element)    &#125;    &#x2F;&#x2F; 过滤    &#x2F;&#x2F; MutableList 的过滤    val filteredMutableList &#x3D; mutableList.filter &#123; it % 2 &#x3D;&#x3D; 0 &#125;    println(&quot;MutableList 过滤: $filteredMutableList&quot;)    &#x2F;&#x2F; List 的过滤    val filteredList &#x3D; list.filter &#123; it % 2 &#x3D;&#x3D; 0 &#125;    println(&quot;List 过滤: $filteredList&quot;)    &#x2F;&#x2F; 加减操作符    &#x2F;&#x2F; MutableList 的加减操作符    val newMutableListPlus &#x3D; mutableList + 9    println(&quot;MutableList + 操作符: $newMutableListPlus&quot;)    mutableList +&#x3D; 10    println(&quot;MutableList +&#x3D; 操作符: $mutableList&quot;)    val newMutableListMinus &#x3D; mutableList - 2    println(&quot;MutableList - 操作符: $newMutableListMinus&quot;)    mutableList -&#x3D; 3    println(&quot;MutableList -&#x3D; 操作符: $mutableList&quot;)    &#x2F;&#x2F; List 的加减操作符    val newListPlus &#x3D; list + 11    println(&quot;List + 操作符: $newListPlus&quot;)    val newListMinus &#x3D; list - 7    println(&quot;List - 操作符: $newListMinus&quot;)    &#x2F;&#x2F; 取集合的一部分    &#x2F;&#x2F; MutableList 取集合的一部分    val subMutableList &#x3D; mutableList.subList(1, 3)    println(&quot;MutableList 取集合的一部分: $subMutableList&quot;)    &#x2F;&#x2F; List 取集合的一部分    val subList &#x3D; list.subList(1, 3)    println(&quot;List 取集合的一部分: $subList&quot;)    &#x2F;&#x2F; 取单个元素    &#x2F;&#x2F; MutableList 取单个元素    val mutableListElement &#x3D; mutableList[1]    println(&quot;MutableList 取单个元素: $mutableListElement&quot;)    &#x2F;&#x2F; List 取单个元素    val listElement &#x3D; list[1]    println(&quot;List 取单个元素: $listElement&quot;)    &#x2F;&#x2F; 排序    &#x2F;&#x2F; MutableList 的排序    mutableList.sort()    println(&quot;MutableList sort() 排序后: $mutableList&quot;)    val sortedMutableList &#x3D; mutableList.sorted()    println(&quot;MutableList sorted() 排序后: $sortedMutableList&quot;)    &#x2F;&#x2F; List 的排序    val sortedList &#x3D; list.sorted()    println(&quot;List sorted() 排序后: $sortedList&quot;)    &#x2F;&#x2F; 聚合操作    &#x2F;&#x2F; MutableList 的聚合操作    val mutableListSum &#x3D; mutableList.sum()    val mutableListMax &#x3D; mutableList.max()    val mutableListMin &#x3D; mutableList.min()    println(&quot;MutableList 聚合操作: sum&#x3D;$mutableListSum, max&#x3D;$mutableListMax, min&#x3D;$mutableListMin&quot;)    &#x2F;&#x2F; List 的聚合操作    val listSum &#x3D; list.sum()    val listMax &#x3D; list.max()    val listMin &#x3D; list.min()    println(&quot;List 聚合操作: sum&#x3D;$listSum, max&#x3D;$listMax, min&#x3D;$listMin&quot;)    &#x2F;&#x2F; 更改集合内容的操作（添加或删除元素）    &#x2F;&#x2F; MutableList 的更改操作    mutableList.add(12)    println(&quot;MutableList 添加元素后: $mutableList&quot;)    mutableList.remove(10)    println(&quot;MutableList 移除元素后: $mutableList&quot;)    mutableList.removeAt(1)    println(&quot;MutableList 移除指定位置元素后: $mutableList&quot;)    &#x2F;&#x2F; List 不支持更改操作，以下代码会导致编译错误    &#x2F;&#x2F; list.add(13)    &#x2F;&#x2F; list.remove(8)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><table><thead><tr><th>特性</th><th>MutableSet</th><th>Set</th></tr></thead><tbody><tr><td>可变性</td><td>可变，允许添加、删除元素</td><td>不可变，元素一旦确定不能修改</td></tr><tr><td>使用场景</td><td>当需要动态存储一组元素，且不允许重复元素，并且在后续操作中需要对集合元素进行添加、删除等修改操作时，使用 MutableSet。</td><td>当需要存储一组不允许重复的元素，且该集合在创建后不允许修改，仅用于元素的检查、遍历等操作时，使用 Set。</td></tr></tbody></table><p>在 Kotlin 中，以下是它们的使用示例：</p><table><thead><tr><th>操作</th><th><code>MutableSet</code></th><th><code>Set</code></th></tr></thead><tbody><tr><td>构造</td><td>- <code>mutableSetOf()</code>：创建一个可变集合，可传入初始元素。<br>例如：<code>val mutableSet = mutableSetOf(1, 2, 3)</code><br>- <code>HashSet()</code>（Java 风格）：创建一个空的可变集合，后续可添加元素。<br>例如：<code>val mutableSet = HashSet&lt;Int&gt;()</code></td><td>- <code>setOf()</code>：创建一个不可变集合，可传入初始元素。<br>例如：<code>val set = setOf(1, 2, 3)</code><br>- <code>toSet()</code>：将其他集合转换为不可变集合。<br>例如：<code>val set = mutableSet.toSet()</code></td></tr><tr><td>迭代器</td><td>- <code>iterator()</code>：返回一个迭代器，可用于遍历集合。<br>例如：<br><code>kotlin&lt;br&gt;val mutableSet = mutableSetOf(1, 2, 3)&lt;br&gt;val iterator = mutableSet.iterator()&lt;br&gt;while (iterator.hasNext()) &#123;&lt;br&gt;    val element = iterator.next()&lt;br&gt;    println(element)&lt;br&gt;&#125;&lt;br&gt;</code></td><td>- <code>iterator()</code>：返回一个迭代器，可用于遍历集合。<br>例如：<br><code>kotlin&lt;br&gt;val set = setOf(1, 2, 3)&lt;br&gt;val iterator = set.iterator()&lt;br&gt;while (iterator.hasNext()) &#123;&lt;br&gt;    val element = iterator.next()&lt;br&gt;    println(element)&lt;br&gt;&#125;&lt;br&gt;</code></td></tr><tr><td>过滤</td><td>- <code>filter()</code>：返回一个新的 <code>MutableSet</code>，包含满足条件的元素。<br>例如：<br><code>kotlin&lt;br&gt;val mutableSet = mutableSetOf(1, 2, 3, 4)&lt;br&gt;val filteredSet = mutableSet.filter &#123; it % 2 == 0 &#125;&lt;br&gt;</code></td><td>- <code>filter()</code>：返回一个新的 <code>Set</code>，包含满足条件的元素。<br>例如：<br><code>kotlin&lt;br&gt;val set = setOf(1, 2, 3, 4)&lt;br&gt;val filteredSet = set.filter &#123; it % 2 == 0 &#125;&lt;br&gt;</code></td></tr><tr><td>加减操作符</td><td>- <code>+</code>：创建一个新的 <code>MutableSet</code>，包含原集合和新元素。<br>例如：<code>val newMutableSet = mutableSet + 4</code><br>- <code>+=</code>：直接在原集合中添加元素。<br>例如：<code>mutableSet += 4</code><br>- <code>-</code>：创建一个新的 <code>MutableSet</code>，不包含指定元素。<br>例如：<code>val newMutableSet = mutableSet - 2</code><br>- <code>-=</code>：直接从原集合中移除指定元素。<br>例如：<code>mutableSet -= 2</code></td><td>- <code>+</code>：创建一个新的 <code>Set</code>，包含原集合和新元素。<br>例如：<code>val newSet = set + 4</code><br> <code>-</code>：创建一个新的 <code>Set</code>，不包含指定元素。<br>例如：<code>val newSet = set - 2</code></td></tr><tr><td>取集合的一部分</td><td>无直接方法，可先转换为列表操作后再转回集合</td><td>无直接方法，可先转换为列表操作后再转回集合</td></tr><tr><td>取单个元素</td><td>无直接索引获取元素的方法，可通过迭代或查找判断元素是否存在<br>例如：<code>if (mutableSet.contains(2)) &#123;...&#125;</code></td><td>无直接索引获取元素的方法，可通过迭代或查找判断元素是否存在<br>例如：<code>if (set.contains(2)) &#123;...&#125;</code></td></tr><tr><td>排序</td><td>- <code>sorted()</code>：返回一个新的 <code>List</code>（不是 <code>MutableSet</code>），包含排序后的元素，原集合不变。<br>例如：<code>val sortedList = mutableSet.sorted()</code></td><td>- <code>sorted()</code>：返回一个新的 <code>List</code>（不是 <code>Set</code>），包含排序后的元素，原集合不变。<br>例如：<code>val sortedList = set.sorted()</code></td></tr><tr><td>聚合操作</td><td>- <code>sum()</code>：计算集合元素的总和（元素需为数字类型）。<br>例如：<code>val sum = mutableSet.sum()</code><br>- <code>max()</code>：获取集合中的最大值。<br>例如：<code>val max = mutableSet.max()</code><br>- <code>min()</code>：获取集合中的最小值。<br>例如：<code>val min = mutableSet.min()</code></td><td>- <code>sum()</code>：计算集合元素的总和（元素需为数字类型）。<br>例如：<code>val sum = set.sum()</code><br>- <code>max()</code>：获取集合中的最大值。<br>例如：<code>val max = set.max()</code><br>- <code>min()</code>：获取集合中的最小值。<br>例如：<code>val min = set.min()</code></td></tr><tr><td>更改集合内容的操作（添加或删除元素）</td><td>- <code>add()</code>：在集合中添加元素。<br>例如：<code>mutableSet.add(5)</code><br>- <code>remove()</code>：移除指定元素。<br>例如：<code>mutableSet.remove(3)</code></td><td>不支持，因为 <code>Set</code> 是不可变的，尝试添加或删除元素会导致编译错误。</td></tr></tbody></table><p>以下是对应的 Kotlin 代码示例：</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">fun main() &#123;    &#x2F;&#x2F; 构造    &#x2F;&#x2F; MutableSet 的构造    val mutableSet &#x3D; mutableSetOf(1, 2, 3)    val mutableSetJavaStyle &#x3D; HashSet&lt;Int&gt;()    mutableSetJavaStyle.add(4)    mutableSetJavaStyle.add(5)    println(&quot;MutableSet 构造: $mutableSet, $mutableSetJavaStyle&quot;)    &#x2F;&#x2F; Set 的构造    val set &#x3D; setOf(6, 7, 8)    val setFromMutable &#x3D; mutableSet.toSet()    println(&quot;Set 构造: $set, $setFromMutable&quot;)    &#x2F;&#x2F; 迭代器    &#x2F;&#x2F; MutableSet 的迭代器    println(&quot;MutableSet 迭代器:&quot;)    val mutableIterator &#x3D; mutableSet.iterator()    while (mutableIterator.hasNext()) &#123;        val element &#x3D; mutableIterator.next()        println(element)    &#125;    &#x2F;&#x2F; Set 的迭代器    println(&quot;Set 迭代器:&quot;)    val setIterator &#x3D; set.iterator()    while (setIterator.hasNext()) &#123;        val element &#x3D; setIterator.next()        println(element)    &#125;    &#x2F;&#x2F; 过滤    &#x2F;&#x2F; MutableSet 的过滤    val filteredMutableSet &#x3D; mutableSet.filter &#123; it % 2 &#x3D;&#x3D; 0 &#125;.toMutableSet()    println(&quot;MutableSet 过滤: $filteredMutableSet&quot;)    &#x2F;&#x2F; Set 的过滤    val filteredSet &#x3D; set.filter &#123; it % 2 &#x3D;&#x3D; 0 &#125;.toSet()    println(&quot;Set 过滤: $filteredSet&quot;)    &#x2F;&#x2F; 加减操作符    &#x2F;&#x2F; MutableSet 的加减操作符    val newMutableSetPlus &#x3D; mutableSet + 9    println(&quot;MutableSet + 操作符: $newMutableSetPlus&quot;)    mutableSet +&#x3D; 10    println(&quot;MutableSet +&#x3D; 操作符: $mutableSet&quot;)    val newMutableSetMinus &#x3D; mutableSet - 2    println(&quot;MutableSet - 操作符: $newMutableSetMinus&quot;)    mutableSet -&#x3D; 3    println(&quot;MutableSet -&#x3D; 操作符: $mutableSet&quot;)    &#x2F;&#x2F; Set 的加减操作符    val newSetPlus &#x3D; set + 11    println(&quot;Set + 操作符: $newSetPlus&quot;)    val newSetMinus &#x3D; set - 7    println(&quot;Set - 操作符: $newSetMinus&quot;)    &#x2F;&#x2F; 取单个元素    &#x2F;&#x2F; MutableSet 取单个元素    if (mutableSet.contains(2)) &#123;        println(&quot;MutableSet 包含元素 2&quot;)    &#125;    &#x2F;&#x2F; Set 取单个元素    if (set.contains(7)) &#123;        println(&quot;Set 包含元素 7&quot;)    &#125;    &#x2F;&#x2F; 排序    &#x2F;&#x2F; MutableSet 的排序    val sortedMutableList &#x3D; mutableSet.sorted()    println(&quot;MutableSet sorted() 排序后: $sortedMutableList&quot;)    &#x2F;&#x2F; Set 的排序    val sortedSetList &#x3D; set.sorted()    println(&quot;Set sorted() 排序后: $sortedSetList&quot;)    &#x2F;&#x2F; 聚合操作    &#x2F;&#x2F; MutableSet 的聚合操作    val mutableSetSum &#x3D; mutableSet.sum()    val mutableSetMax &#x3D; mutableSet.max()    val mutableSetMin &#x3D; mutableSet.min()    println(&quot;MutableSet 聚合操作: sum&#x3D;$mutableSetSum, max&#x3D;$mutableSetMax, min&#x3D;$mutableSetMin&quot;)    &#x2F;&#x2F; Set 的聚合操作    val setSum &#x3D; set.sum()    val setMax &#x3D; set.max()    val setMin &#x3D; set.min()    println(&quot;Set 聚合操作: sum&#x3D;$setSum, max&#x3D;$setMax, min&#x3D;$setMin&quot;)    &#x2F;&#x2F; 更改集合内容的操作（添加或删除元素）    &#x2F;&#x2F; MutableSet 的更改操作    mutableSet.add(12)    println(&quot;MutableSet 添加元素后: $mutableSet&quot;)    mutableSet.remove(10)    println(&quot;MutableSet 移除元素后: $mutableSet&quot;)    &#x2F;&#x2F; Set 不支持更改操作，以下代码会导致编译错误    &#x2F;&#x2F; set.add(13)    &#x2F;&#x2F; set.remove(8)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：<code>MutableSet</code> 是可变的，可以对其元素进行添加、删除等操作；而 <code>Set</code> 是不可变的，一旦创建，其元素不能被修改，只能进行读取、过滤、聚合等不改变原集合的操作。</p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><table><thead><tr><th>特性</th><th>MutableMap</th><th>Map</th></tr></thead><tbody><tr><td>可变性</td><td>可变，允许添加、删除元素</td><td>不可变，元素一旦确定不能修改</td></tr><tr><td>使用场景</td><td>当需要动态存储一组元素，且不允许重复元素，并且在后续操作中需要对集合元素进行添加、删除等修改操作时，使用 MutableMap。</td><td>当需要存储一组不允许重复的元素，且该集合在创建后不允许修改，仅用于元素的检查、遍历等操作时，使用 Map。</td></tr><tr><td>以下是 <code>Map</code> 和 <code>MutableMap</code> 在不同操作上的区别和常用方法的表格：</td><td></td><td></td></tr></tbody></table><table><thead><tr><th>操作</th><th><code>MutableMap</code></th><th><code>Map</code></th></tr></thead><tbody><tr><td>构造</td><td>- <code>mutableMapOf()</code>：创建一个可变映射，可传入初始键值对。<br>例如：<code>val mutableMap = mutableMapOf(&quot;a&quot; to 1, &quot;b&quot; to 2)</code><br>- <code>HashMap()</code>（Java 风格）：创建一个空的可变映射，后续可添加键值对。<br>例如：<code>val mutableMap = HashMap&lt;String, Int&gt;()</code></td><td>- <code>mapOf()</code>：创建一个不可变映射，可传入初始键值对。<br>例如：<code>val map = mapOf(&quot;a&quot; to 1, &quot;b&quot; to 2)</code><br>- <code>toMap()</code>：将其他映射或键值对集合转换为不可变映射。<br>例如：<code>val map = mutableMap.toMap()</code></td></tr><tr><td>迭代器</td><td>- <code>iterator()</code>：返回一个迭代器，可用于遍历映射的键值对。<br>例如：<br><code>kotlin&lt;br&gt;val mutableMap = mutableMapOf(&quot;a&quot; to 1, &quot;b&quot; to 2)&lt;br&gt;val iterator = mutableMap.iterator()&lt;br&gt;while (iterator.hasNext()) &#123;&lt;br&gt;    val entry = iterator.next()&lt;br&gt;    println(&quot;$&#123;entry.key&#125;: $&#123;entry.value&#125;&quot;)&lt;br&gt;&#125;&lt;br&gt;</code></td><td>- <code>iterator()</code>：返回一个迭代器，可用于遍历映射的键值对。<br>例如：<br><code>kotlin&lt;br&gt;val map = mapOf(&quot;a&quot; to 1, &quot;b&quot; to 2)&lt;br&gt;val iterator = map.iterator()&lt;br&gt;while (iterator.hasNext()) &#123;&lt;br&gt;    val entry = iterator.next()&lt;br&gt;    println(&quot;$&#123;entry.key&#125;: $&#123;entry.value&#125;&quot;)&lt;br&gt;&#125;&lt;br&gt;</code></td></tr><tr><td>过滤</td><td>- <code>filter()</code>：返回一个新的 <code>MutableMap</code>，包含满足条件的键值对。<br>例如：<br><code>kotlin&lt;br&gt;val mutableMap = mutableMapOf(&quot;a&quot; to 1, &quot;b&quot; to 2, &quot;c&quot; to 3)&lt;br&gt;val filteredMap = mutableMap.filter &#123; it.value % 2 == 0 &#125;&lt;br&gt;</code></td><td>- <code>filter()</code>：返回一个新的 <code>Map</code>，包含满足条件的键值对。<br>例如：<br><code>kotlin&lt;br&gt;val map = mapOf(&quot;a&quot; to 1, &quot;b&quot; to 2, &quot;c&quot; to 3)&lt;br&gt;val filteredMap = map.filter &#123; it.value % 2 == 0 &#125;&lt;br&gt;</code></td></tr><tr><td>加减操作符</td><td>- <code>+</code>：创建一个新的 <code>MutableMap</code>，包含原映射和新的键值对。<br>例如：<code>val newMutableMap = mutableMap + (&quot;d&quot; to 4)</code><br>- <code>+=</code>：直接在原映射中添加键值对。<br>例如：<code>mutableMap += (&quot;d&quot; to 4)</code><br>- <code>-</code>：创建一个新的 <code>MutableMap</code>，不包含指定键的键值对。<br>例如：<code>val newMutableMap = mutableMap - &quot;a&quot;</code><br>- <code>-=</code>：直接从原映射中移除指定键的键值对。<br>例如：<code>mutableMap -= &quot;a&quot;</code></td><td>- <code>+</code>：创建一个新的 <code>Map</code>，包含原映射和新的键值对。<br>例如：<code>val newMap = map + (&quot;d&quot; to 4)</code><br> <code>-</code>：创建一个新的 <code>Map</code>，不包含指定键的键值对。<br>例如：<code>val newMap = map - &quot;a&quot;</code></td></tr><tr><td>取集合的一部分</td><td>- 无直接方法，可通过过滤或转换为其他集合类型操作</td><td>无直接方法，可通过过滤或转换为其他集合类型操作</td></tr><tr><td>取单个元素</td><td>- <code>get()</code> 或 <code>[]</code>：根据键获取对应的值。<br>例如：<code>val value = mutableMap[&quot;a&quot;]</code></td><td>- <code>get()</code> 或 <code>[]</code>：根据键获取对应的值。<br>例如：<code>val value = map[&quot;a&quot;]</code></td></tr><tr><td>排序</td><td>- 对键排序：<code>toSortedMap()</code> 按键排序返回新的 <code>MutableMap</code>。<br>例如：<code>val sortedMutableMap = mutableMap.toSortedMap()</code><br> 对值排序：先转换为键值对列表排序再转回映射。<br>例如：<br><code>kotlin&lt;br&gt;val sortedByValue = mutableMap.toList().sortedBy &#123; it.value &#125;.toMap().toMutableMap()&lt;br&gt;</code></td><td>- 对键排序：<code>toSortedMap()</code> 按键排序返回新的 <code>Map</code>。<br>例如：<code>val sortedMap = map.toSortedMap()</code><br> 对值排序：先转换为键值对列表排序再转回映射。<br>例如：<br><code>kotlin&lt;br&gt;val sortedByValue = map.toList().sortedBy &#123; it.value &#125;.toMap()&lt;br&gt;</code></td></tr><tr><td>聚合操作</td><td>- <code>values.sum()</code>：计算所有值的总和（值需为数字类型）。<br>例如：<code>val sum = mutableMap.values.sum()</code><br>- <code>values.max()</code>：获取所有值中的最大值。<br>例如：<code>val max = mutableMap.values.max()</code><br>- <code>values.min()</code>：获取所有值中的最小值。<br>例如：<code>val min = mutableMap.values.min()</code></td><td>- <code>values.sum()</code>：计算所有值的总和（值需为数字类型）。<br>例如：<code>val sum = map.values.sum()</code><br>- <code>values.max()</code>：获取所有值中的最大值。<br>例如：<code>val max = map.values.max()</code><br>- <code>values.min()</code>：获取所有值中的最小值。<br>例如：<code>val min = map.values.min()</code></td></tr><tr><td>更改集合内容的操作（添加或删除键值对）</td><td>- <code>put()</code>：添加或更新键值对。<br>例如：<code>mutableMap.put(&quot;e&quot;, 5)</code><br>- <code>remove()</code>：移除指定键的键值对。<br>例如：<code>mutableMap.remove(&quot;b&quot;)</code></td><td>不支持，因为 <code>Map</code> 是不可变的，尝试添加或删除键值对会导致编译错误。</td></tr></tbody></table><p>以下是对应的 Kotlin 代码示例：</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">fun main() &#123;    &#x2F;&#x2F; 构造    &#x2F;&#x2F; MutableMap 的构造    val mutableMap &#x3D; mutableMapOf(&quot;a&quot; to 1, &quot;b&quot; to 2)    val mutableMapJavaStyle &#x3D; HashMap&lt;String, Int&gt;()    mutableMapJavaStyle[&quot;c&quot;] &#x3D; 3    mutableMapJavaStyle[&quot;d&quot;] &#x3D; 4    println(&quot;MutableMap 构造: $mutableMap, $mutableMapJavaStyle&quot;)    &#x2F;&#x2F; Map 的构造    val map &#x3D; mapOf(&quot;e&quot; to 5, &quot;f&quot; to 6)    val mapFromMutable &#x3D; mutableMap.toMap()    println(&quot;Map 构造: $map, $mapFromMutable&quot;)    &#x2F;&#x2F; 迭代器    &#x2F;&#x2F; MutableMap 的迭代器    println(&quot;MutableMap 迭代器:&quot;)    val mutableIterator &#x3D; mutableMap.iterator()    while (mutableIterator.hasNext()) &#123;        val entry &#x3D; mutableIterator.next()        println(&quot;$&#123;entry.key&#125;: $&#123;entry.value&#125;&quot;)    &#125;    &#x2F;&#x2F; Map 的迭代器    println(&quot;Map 迭代器:&quot;)    val mapIterator &#x3D; map.iterator()    while (mapIterator.hasNext()) &#123;        val entry &#x3D; mapIterator.next()        println(&quot;$&#123;entry.key&#125;: $&#123;entry.value&#125;&quot;)    &#125;    &#x2F;&#x2F; 过滤    &#x2F;&#x2F; MutableMap 的过滤    val filteredMutableMap &#x3D; mutableMap.filter &#123; it.value % 2 &#x3D;&#x3D; 0 &#125;.toMutableMap()    println(&quot;MutableMap 过滤: $filteredMutableMap&quot;)    &#x2F;&#x2F; Map 的过滤    val filteredMap &#x3D; map.filter &#123; it.value % 2 &#x3D;&#x3D; 0 &#125;    println(&quot;Map 过滤: $filteredMap&quot;)    &#x2F;&#x2F; 加减操作符    &#x2F;&#x2F; MutableMap 的加减操作符    val newMutableMapPlus &#x3D; mutableMap + (&quot;g&quot; to 7)    println(&quot;MutableMap + 操作符: $newMutableMapPlus&quot;)    mutableMap +&#x3D; (&quot;h&quot; to 8)    println(&quot;MutableMap +&#x3D; 操作符: $mutableMap&quot;)    val newMutableMapMinus &#x3D; mutableMap - &quot;a&quot;    println(&quot;MutableMap - 操作符: $newMutableMapMinus&quot;)    mutableMap -&#x3D; &quot;b&quot;    println(&quot;MutableMap -&#x3D; 操作符: $mutableMap&quot;)    &#x2F;&#x2F; Map 的加减操作符    val newMapPlus &#x3D; map + (&quot;i&quot; to 9)    println(&quot;Map + 操作符: $newMapPlus&quot;)    val newMapMinus &#x3D; map - &quot;e&quot;    println(&quot;Map - 操作符: $newMapMinus&quot;)    &#x2F;&#x2F; 取单个元素    &#x2F;&#x2F; MutableMap 取单个元素    val mutableMapValue &#x3D; mutableMap[&quot;c&quot;]    println(&quot;MutableMap 取单个元素: $mutableMapValue&quot;)    &#x2F;&#x2F; Map 取单个元素    val mapValue &#x3D; map[&quot;f&quot;]    println(&quot;Map 取单个元素: $mapValue&quot;)    &#x2F;&#x2F; 排序    &#x2F;&#x2F; MutableMap 的排序    val sortedMutableMapByKey &#x3D; mutableMap.toSortedMap()    println(&quot;MutableMap 按键排序: $sortedMutableMapByKey&quot;)    val sortedMutableMapByValue &#x3D; mutableMap.toList().sortedBy &#123; it.value &#125;.toMap().toMutableMap()    println(&quot;MutableMap 按值排序: $sortedMutableMapByValue&quot;)    &#x2F;&#x2F; Map 的排序    val sortedMapByKey &#x3D; map.toSortedMap()    println(&quot;Map 按键排序: $sortedMapByKey&quot;)    val sortedMapByValue &#x3D; map.toList().sortedBy &#123; it.value &#125;.toMap()    println(&quot;Map 按值排序: $sortedMapByValue&quot;)    &#x2F;&#x2F; 聚合操作    &#x2F;&#x2F; MutableMap 的聚合操作    val mutableMapSum &#x3D; mutableMap.values.sum()    val mutableMapMax &#x3D; mutableMap.values.max()    val mutableMapMin &#x3D; mutableMap.values.min()    println(&quot;MutableMap 聚合操作: sum&#x3D;$mutableMapSum, max&#x3D;$mutableMapMax, min&#x3D;$mutableMapMin&quot;)    &#x2F;&#x2F; Map 的聚合操作    val mapSum &#x3D; map.values.sum()    val mapMax &#x3D; map.values.max()    val mapMin &#x3D; map.values.min()    println(&quot;Map 聚合操作: sum&#x3D;$mapSum, max&#x3D;$mapMax, min&#x3D;$mapMin&quot;)    &#x2F;&#x2F; 更改集合内容的操作（添加或删除键值对）    &#x2F;&#x2F; MutableMap 的更改操作    mutableMap.put(&quot;j&quot;, 10)    println(&quot;MutableMap 添加键值对后: $mutableMap&quot;)    mutableMap.remove(&quot;c&quot;)    println(&quot;MutableMap 移除键值对后: $mutableMap&quot;)    &#x2F;&#x2F; Map 不支持更改操作，以下代码会导致编译错误    &#x2F;&#x2F; map.put(&quot;k&quot;, 11)    &#x2F;&#x2F; map.remove(&quot;f&quot;)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：<code>MutableMap</code> 是可变的，可以对其键值对进行添加、删除、修改等操作；而 <code>Map</code> 是不可变的，一旦创建，其键值对不能被修改，只能进行读取、过滤、聚合等不改变原映射的操作。</p><h3 id="与-Java-集合关系"><a href="#与-Java-集合关系" class="headerlink" title="与 Java 集合关系"></a>与 Java 集合关系</h3><p>以下是关于 <code>List</code>、<code>MutableList</code> 以及 <code>Map</code>、<code>MutableMap</code>、<code>Set</code>、<code>MutableSet</code> 相关的 Java 原型类型的详细说明：</p><h4 id="List-和-MutableList"><a href="#List-和-MutableList" class="headerlink" title="List 和 MutableList"></a><code>List</code> 和 <code>MutableList</code></h4><ul><li><code>**List**</code> 和 <code>MutableList</code> 与 <code>ArrayList</code>、<code>LinkedList</code> 的关系：<ul><li><code>List</code> 是 Kotlin 中的接口，它对应 Java 中的 <code>java.util.List</code> 接口。<code>List</code> 本身是只读的，不允许修改元素。</li><li><code>MutableList</code> 是 Kotlin 中的接口，对应 Java 中的 <code>java.util.List</code> 接口，不过它表示可变的列表，允许对列表元素进行添加、删除和修改等操作。</li><li><code>ArrayList</code> 和 <code>LinkedList</code> 都可以作为 <code>MutableList</code> 的实现。在 Kotlin 中，当你使用 <code>mutableListOf()</code> 函数创建一个可变列表时，默认情况下它会返回一个基于 <code>ArrayList</code> 的实现。例如：</li></ul></li></ul><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">val mutableList &#x3D; mutableListOf(1, 2, 3) &#x2F;&#x2F; 默认是 ArrayList 实现<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>- 如果你想明确使用 `LinkedList`，可以通过 Java 互操作性来实现：</code></pre><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">import java.util.LinkedListval linkedList: MutableList&lt;Int&gt; &#x3D; LinkedList&lt;Int&gt;()linkedList.add(1)linkedList.add(2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Map-和-MutableMap"><a href="#Map-和-MutableMap" class="headerlink" title="Map 和 MutableMap"></a><code>Map</code> 和 <code>MutableMap</code></h4><ul><li><strong>Java 原型类型</strong>：<ul><li><code>Map</code> 是 Kotlin 中的只读映射接口，对应 Java 中的 <code>java.util.Map</code> 接口。它表示一个键值对的集合，不允许修改其中的键值对。</li><li><code>MutableMap</code> 是 Kotlin 中的可变映射接口，也对应 Java 中的 <code>java.util.Map</code> 接口。它允许对映射中的键值对进行添加、删除和修改等操作。</li><li>在 Kotlin 中，当你使用 <code>mutableMapOf()</code> 函数创建一个可变映射时，默认情况下它会返回一个基于 <code>java.util.HashMap</code> 的实现。例如：</li></ul></li></ul><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">val mutableMap &#x3D; mutableMapOf(&quot;key1&quot; to 1, &quot;key2&quot; to 2) &#x2F;&#x2F; 默认是 HashMap 实现<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Set-和-MutableSet"><a href="#Set-和-MutableSet" class="headerlink" title="Set 和 MutableSet"></a><code>Set</code> 和 <code>MutableSet</code></h4><ul><li><strong>Java 原型类型</strong>：<ul><li><code>Set</code> 是 Kotlin 中的只读集合接口，对应 Java 中的 <code>java.util.Set</code> 接口。它表示一个不包含重复元素的集合，不允许修改集合中的元素。</li><li><code>MutableSet</code> 是 Kotlin 中的可变集合接口，也对应 Java 中的 <code>java.util.Set</code> 接口。它允许对集合中的元素进行添加、删除等操作。</li><li>在 Kotlin 中，当你使用 <code>mutableSetOf()</code> 函数创建一个可变集合时，默认情况下它会返回一个基于 <code>java.util.HashSet</code> 的实现。例如：</li></ul></li></ul><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">val mutableSet &#x3D; mutableSetOf(1, 2, 3) &#x2F;&#x2F; 默认是 HashSet 实现<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>总结如下：</p><table><thead><tr><th>Kotlin 类型</th><th>Java 原型接口</th><th>默认实现类</th></tr></thead><tbody><tr><td><code>List</code></td><td><code>java.util.List</code></td><td>无（只读）</td></tr><tr><td><code>MutableList</code></td><td><code>java.util.List</code></td><td><code>java.util.ArrayList</code></td></tr><tr><td><code>Map</code></td><td><code>java.util.Map</code></td><td>无（只读）</td></tr><tr><td><code>MutableMap</code></td><td><code>java.util.Map</code></td><td><code>java.util.HashMap</code></td></tr><tr><td><code>Set</code></td><td><code>java.util.Set</code></td><td>无（只读）</td></tr><tr><td><code>MutableSet</code></td><td><code>java.util.Set</code></td><td><code>java.util.HashSet</code></td></tr></tbody></table><h3 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h3><p><code>ArrayDeque</code> 是 Java 中的一个双端队列（Deque，Double Ended Queue）实现类，它基于数组实现，既可以作为栈（Stack）使用，也可以作为队列（Queue）使用，提供了高效的插入和删除操作。在 Kotlin 中可以通过 Java 互操作性来使用 <code>ArrayDeque</code>。</p><ul><li><strong>动态数组</strong>：<code>ArrayDeque</code> 内部使用动态数组来存储元素，当数组容量不足时会自动扩容。</li><li><strong>双端操作</strong>：支持在队列的两端（头部和尾部）进行插入和删除操作，时间复杂度为 $O(1)$。</li><li><strong>线程不安全</strong>：<code>ArrayDeque</code> 不是线程安全的，如果需要在多线程环境下使用，需要进行外部同步。</li></ul><p>这里我们列举了它的一些常用方法：</p><ul><li><strong>添加元素</strong>：<ul><li><code>addFirst(element)</code>：在队列头部添加元素。</li><li><code>addLast(element)</code>：在队列尾部添加元素。</li><li><code>offerFirst(element)</code>：在队列头部添加元素，添加失败返回 <code>false</code>。</li><li><code>offerLast(element)</code>：在队列尾部添加元素，添加失败返回 <code>false</code>。</li></ul></li><li><strong>删除元素</strong>：<ul><li><code>removeFirst()</code>：移除并返回队列头部的元素，队列为空时抛出异常。</li><li><code>removeLast()</code>：移除并返回队列尾部的元素，队列为空时抛出异常。</li><li><code>pollFirst()</code>：移除并返回队列头部的元素，队列为空时返回 <code>null</code>。</li><li><code>pollLast()</code>：移除并返回队列尾部的元素，队列为空时返回 <code>null</code>。</li></ul></li><li><strong>获取元素</strong>：<ul><li><code>getFirst()</code>：获取队列头部的元素，队列为空时抛出异常。</li><li><code>getLast()</code>：获取队列尾部的元素，队列为空时抛出异常。</li><li><code>peekFirst()</code>：获取队列头部的元素，队列为空时返回 <code>null</code>。</li><li><code>peekLast()</code>：获取队列尾部的元素，队列为空时返回 <code>null</code>。</li></ul></li></ul><p>以下是基于 Kotlin 的代码示例：</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">import java.util.ArrayDequefun main() &#123;    &#x2F;&#x2F; 创建一个 ArrayDeque 实例    val deque &#x3D; ArrayDeque&lt;Int&gt;()    &#x2F;&#x2F; 在队列尾部添加元素    deque.addLast(1)    deque.addLast(2)    deque.addLast(3)    println(&quot;队列内容: $deque&quot;)    &#x2F;&#x2F; 在队列头部添加元素    deque.addFirst(0)    println(&quot;在头部添加元素后: $deque&quot;)    &#x2F;&#x2F; 获取队列头部的元素    val firstElement &#x3D; deque.peekFirst()    println(&quot;队列头部元素: $firstElement&quot;)    &#x2F;&#x2F; 获取队列尾部的元素    val lastElement &#x3D; deque.peekLast()    println(&quot;队列尾部元素: $lastElement&quot;)    &#x2F;&#x2F; 移除队列头部的元素    val removedFirst &#x3D; deque.pollFirst()    println(&quot;移除的头部元素: $removedFirst&quot;)    println(&quot;移除头部元素后: $deque&quot;)    &#x2F;&#x2F; 移除队列尾部的元素    val removedLast &#x3D; deque.pollLast()    println(&quot;移除的尾部元素: $removedLast&quot;)    println(&quot;移除尾部元素后: $deque&quot;)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一般来说，<code>ArrayDeque</code> 用于以下情景：</p><ul><li><strong>栈的实现</strong>：由于 <code>ArrayDeque</code> 支持在一端进行高效的插入和删除操作，因此可以用它来实现栈。例如，在进行深度优先搜索（DFS）时，可以使用 <code>ArrayDeque</code> 来存储待访问的节点。</li><li><strong>队列的实现</strong>：<code>ArrayDeque</code> 也可以作为普通队列使用，支持在一端插入元素，在另一端删除元素。例如，在进行广度优先搜索（BFS）时，可以使用 <code>ArrayDeque</code> 来存储待访问的节点。</li><li><strong>双端队列的应用</strong>：在某些场景下，需要在队列的两端进行插入和删除操作，例如实现一个滑动窗口算法，<code>ArrayDeque</code> 可以提供高效的性能。</li></ul><p>Kotlin 的 <code>kotlinx.serialization</code> 是一个强大的跨平台序列化库，它允许你将 Kotlin 对象序列化为各种格式，以及从这些格式反序列化为 Kotlin 对象。以下是关于 <code>kotlinx.serialization</code> 及其支持的不同格式（JSON、Protocol buffers、CBOR、Properties、HOCON）的详细说明：</p><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p><code>kotlinx.serialization</code> 提供了一个统一的接口来处理不同格式的序列化和反序列化。通过添加相应的格式支持库，你可以轻松地在不同的格式之间切换，而无需编写大量的样板代码。每个格式的序列化和反序列化操作都非常相似，只是使用不同的编码器和解码器。</p><h3 id="导入包-数据类支持"><a href="#导入包-数据类支持" class="headerlink" title="导入包 &amp; 数据类支持"></a>导入包 &amp; 数据类支持</h3><p>首先，你需要在项目中添加相应的依赖。如果你使用的是 Gradle，以下是添加 <code>kotlinx.serialization</code> 核心库以及不同格式支持库的示例：</p><pre class="line-numbers language-Groovy" data-language="Groovy"><code class="language-Groovy">&#x2F;&#x2F; 核心库implementation &quot;org.jetbrains.kotlinx:kotlinx-serialization-core:1.3.2&quot;&#x2F;&#x2F; JSON 支持implementation &quot;org.jetbrains.kotlinx:kotlinx-serialization-json:1.3.2&quot;&#x2F;&#x2F; Protocol buffers 支持implementation &quot;org.jetbrains.kotlinx:kotlinx-serialization-protobuf:1.3.2&quot;&#x2F;&#x2F; CBOR 支持implementation &quot;org.jetbrains.kotlinx:kotlinx-serialization-cbor:1.3.2&quot;&#x2F;&#x2F; Properties 支持implementation &quot;org.jetbrains.kotlinx:kotlinx-serialization-properties:1.3.2&quot;&#x2F;&#x2F; HOCON 支持implementation &quot;org.jetbrains.kotlinx:kotlinx-serialization-hocon:1.3.2&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要使用 <code>kotlinx.serialization</code>，你需要将你的数据类标记为 <code>@Serializable</code>。例如：</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">import kotlinx.serialization.Serializable@Serializabledata class Person(    val name: String,    val age: Int)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="JSON-序列化和反序列化"><a href="#JSON-序列化和反序列化" class="headerlink" title="JSON 序列化和反序列化"></a>JSON 序列化和反序列化</h3><p><code>kotlinx-serialization-json</code> 库用于处理 JSON 格式的序列化和反序列化。</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">import kotlinx.serialization.encodeToStringimport kotlinx.serialization.decodeFromStringimport kotlinx.serialization.json.Jsonfun main() &#123;    val person &#x3D; Person(&quot;John Doe&quot;, 30)    &#x2F;&#x2F; 序列化    val json &#x3D; Json.encodeToString(person)    println(json) &#x2F;&#x2F; 输出: &#123;&quot;name&quot;:&quot;John Doe&quot;,&quot;age&quot;:30&#125;    &#x2F;&#x2F; 反序列化    val decodedPerson &#x3D; Json.decodeFromString&lt;Person&gt;(json)    println(decodedPerson) &#x2F;&#x2F; 输出: Person(name&#x3D;John Doe, age&#x3D;30)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Protocol-buffers-序列化和反序列化"><a href="#Protocol-buffers-序列化和反序列化" class="headerlink" title="Protocol buffers 序列化和反序列化"></a>Protocol buffers 序列化和反序列化</h3><p><code>kotlinx-serialization-protobuf</code> 库用于处理 Protocol buffers 格式的序列化和反序列化。</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">import kotlinx.serialization.protobuf.ProtoBufimport kotlinx.serialization.encodeToByteArrayimport kotlinx.serialization.decodeFromByteArrayfun main() &#123;    val person &#x3D; Person(&quot;John Doe&quot;, 30)    &#x2F;&#x2F; 序列化    val protoBytes &#x3D; ProtoBuf.encodeToByteArray(person)    &#x2F;&#x2F; 反序列化    val decodedPerson &#x3D; ProtoBuf.decodeFromByteArray&lt;Person&gt;(protoBytes)    println(decodedPerson) &#x2F;&#x2F; 输出: Person(name&#x3D;John Doe, age&#x3D;30)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="CBOR-序列化和反序列化"><a href="#CBOR-序列化和反序列化" class="headerlink" title="CBOR 序列化和反序列化"></a>CBOR 序列化和反序列化</h3><p><code>kotlinx-serialization-cbor</code> 库用于处理 CBOR 格式的序列化和反序列化。</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">import kotlinx.serialization.cbor.Cborimport kotlinx.serialization.encodeToByteArrayimport kotlinx.serialization.decodeFromByteArrayfun main() &#123;    val person &#x3D; Person(&quot;John Doe&quot;, 30)    &#x2F;&#x2F; 序列化    val cborBytes &#x3D; Cbor.encodeToByteArray(person)    &#x2F;&#x2F; 反序列化    val decodedPerson &#x3D; Cbor.decodeFromByteArray&lt;Person&gt;(cborBytes)    println(decodedPerson) &#x2F;&#x2F; 输出: Person(name&#x3D;John Doe, age&#x3D;30)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Properties-序列化和反序列化"><a href="#Properties-序列化和反序列化" class="headerlink" title="Properties 序列化和反序列化"></a>Properties 序列化和反序列化</h3><p><code>kotlinx-serialization-properties</code> 库用于处理 Properties 格式的序列化和反序列化。</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">import kotlinx.serialization.encodeToStringimport kotlinx.serialization.decodeFromStringimport kotlinx.serialization.properties.Propertiesfun main() &#123;    val person &#x3D; Person(&quot;John Doe&quot;, 30)    &#x2F;&#x2F; 序列化    val propertiesString &#x3D; Properties.encodeToString(person)    println(propertiesString) &#x2F;&#x2F; 输出: name&#x3D;John Doe\nage&#x3D;30    &#x2F;&#x2F; 反序列化    val decodedPerson &#x3D; Properties.decodeFromString&lt;Person&gt;(propertiesString)    println(decodedPerson) &#x2F;&#x2F; 输出: Person(name&#x3D;John Doe, age&#x3D;30)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="HOCON-序列化和反序列化"><a href="#HOCON-序列化和反序列化" class="headerlink" title="HOCON 序列化和反序列化"></a>HOCON 序列化和反序列化</h3><p><code>kotlinx-serialization-hocon</code> 库用于处理 HOCON 格式的序列化和反序列化。</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">import kotlinx.serialization.encodeToStringimport kotlinx.serialization.decodeFromStringimport kotlinx.serialization.hocon.Hoconfun main() &#123;    val person &#x3D; Person(&quot;John Doe&quot;, 30)    &#x2F;&#x2F; 序列化    val hoconString &#x3D; Hocon.encodeToString(person)    println(hoconString) &#x2F;&#x2F; 输出: name &#x3D; &quot;John Doe&quot;\nage &#x3D; 30    &#x2F;&#x2F; 反序列化    val decodedPerson &#x3D; Hocon.decodeFromString&lt;Person&gt;(hoconString)    println(decodedPerson) &#x2F;&#x2F; 输出: Person(name&#x3D;John Doe, age&#x3D;30)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Lincheck 是一个用于测试并发数据结构线性一致性（linearizability）的框架，主要用于 Kotlin 和 Java 语言。以下是关于 Lincheck 的详细介绍：</p><h2 id="Lincheck"><a href="#Lincheck" class="headerlink" title="Lincheck"></a>Lincheck</h2><h3 id="线性一致性（Linearizability）"><a href="#线性一致性（Linearizability）" class="headerlink" title="线性一致性（Linearizability）"></a>线性一致性（Linearizability）</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>线性一致性是并发数据结构的一个重要正确性属性。简单来说，如果一个并发数据结构是线性一致的，<strong>那么它的所有操作看起来就像是以某种原子方式顺序执行的</strong>，即每个操作都在某个时刻瞬间完成，并且这些操作的执行顺序与程序的并发执行历史是一致的。</p><p>在多线程程序中，多个线程可能会访问同一块内存区域或共享变量：</p><ul><li>例如，线程A和线程B可能同时对一个全局变量进行读写操作。线程一致性要求在一个线程对共享数据进行写操作后，其他线程在读取该数据时，能够看到最新的值。如果一个线程更新了数据，另一个线程应该能立即或在合理的时间内看到这个更新。</li><li>为了保证线程一致性，必须确保数据的可见性。即，一个线程对共享数据的修改，应该能被其他线程及时感知到。这通常通过锁、同步机制（如互斥锁、信号量）或内存屏障来实现。</li><li>编译器和处理器可能会对指令进行重排序，以优化性能，这可能导致线程间的执行顺序不一致。为了避免这种情况，程序需要使用适当的同步机制来确保操作的顺序。</li></ul><p>总而言之，在多线程环境下，不满足线程一致性的程序可能会导致这些问题：</p><ul><li><strong>共享资源冲突</strong>：当多个线程同时读写同一块内存或资源时，可能导致数据不一致。</li><li><strong>竞态条件（Race Condition）</strong>：线程执行顺序不确定，导致结果依赖于线程调度顺序。</li><li><strong>内存可见性问题</strong>：某个线程修改了共享数据，其他线程可能无法立即看到修改后的值。</li></ul><p>根据问题分析，我们可以确定相应的解决方案。</p><p>（1）<strong>原子性（Atomicity）</strong></p><ul><li><strong>问题</strong>：一个操作（如 <code>i++</code>）可能被拆分为多个步骤（读、改、写），若中途被其他线程打断，会导致结果错误。</li><li><strong>解决方案</strong>：<ul><li><strong>锁（Lock）</strong>：如 <code>synchronized</code>（Java）、<code>mutex</code>（C++）。</li><li><strong>原子变量（Atomic Variables）</strong>：如 <code>AtomicInteger</code>（Java）、<code>std::atomic</code>（C++）。</li></ul></li></ul><p>（2）<strong>可见性（Visibility）</strong></p><ul><li><strong>问题</strong>：线程A修改了共享变量，但线程B可能因缓存（CPU缓存、寄存器）未刷新而读到旧值。</li><li><strong>解决方案</strong>：<ul><li><code>volatile</code><strong>关键字</strong>（Java）：强制线程从主内存读写变量。</li><li><strong>内存屏障（Memory Barrier）</strong>：确保指令执行顺序和内存可见性。</li></ul></li></ul><p>（3）<strong>有序性（Ordering）</strong></p><ul><li><strong>问题</strong>：编译器或CPU可能对指令重排序（优化），导致代码执行顺序与预期不符。</li><li><strong>解决方案</strong>：<ul><li><code>synchronized</code><strong>或锁</strong>：限制指令重排序。</li><li><code>volatile</code><strong>关键字</strong>：禁止对 volatile 变量的操作重排序。</li></ul></li></ul><p>以<strong>线程安全的数据结构为例子，我们</strong>考虑如下代码 <code>ConcurrentStack</code>，<code>java.util.Stack</code> 是一个典型的线程安全数据结构，即并发栈：</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">class ConcurrentStack&lt;T&gt; &#123;    private val stack &#x3D; java.util.Stack&lt;T&gt;()    @Operation    fun push(value: T) &#123;        stack.push(value)    &#125;    @Operation    fun pop(): T? &#123;        return if (stack.isEmpty()) null else stack.pop()    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，多个线程可以同时操作 <code>push</code> 和 <code>pop</code> 方法。</p><h4 id="并发时的行为差异"><a href="#并发时的行为差异" class="headerlink" title="并发时的行为差异"></a>并发时的行为差异</h4><ul><li>非并发情况下的行为</li></ul><p>在非并发（单线程）环境下，<code>ConcurrentStack</code> 的行为是非常直观的。当调用 <code>push</code> 方法时，元素会按顺序依次被添加到栈顶；当调用 <code>pop</code> 方法时，栈顶元素会被移除并返回。操作是顺序执行的，不会出现数据不一致的问题。</p><p>例如，以下是单线程环境下的操作序列：</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">val stack &#x3D; ConcurrentStack&lt;Int&gt;()stack.push(1)stack.push(2)val topElement &#x3D; stack.pop() &#x2F;&#x2F; 返回 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>并发情况下的行为</li></ul><p>在并发（多线程）环境下，<code>ConcurrentStack</code> 的行为会变得复杂。多个线程可能同时尝试对栈进行 <code>push</code> 或 <code>pop</code> 操作，这可能会导致以下几种情况：</p><ol><li><strong>竞态条件（Race Condition）</strong>：<ul><li>多个线程同时调用 <code>push</code> 方法，可能会导致元素的插入顺序不符合预期。例如，线程 A 和线程 B 同时调用 <code>push</code> 方法，由于线程调度的不确定性，最终栈中的元素顺序可能会出现混乱。</li><li>多个线程同时调用 <code>pop</code> 方法，可能会导致某个线程获取到错误的栈顶元素，或者在栈为空时仍然尝试弹出元素。</li></ul></li><li><strong>数据不一致</strong>：<ul><li>当一个线程正在执行 <code>pop</code> 操作，而另一个线程同时执行 <code>push</code> 操作时，可能会导致栈的状态不一致。例如，<code>pop</code> 操作可能会在 <code>push</code> 操作完成之前判断栈为空，从而返回 <code>null</code>，而实际上栈中已经有元素被添加。</li></ul></li></ol><p>具体来说，以下是一些符合线性一致性的示例：</p><ul><li><strong>示例 1：并发</strong><code>**push**</code><strong>操作</strong><ul><li>线程 A 调用 <code>push(1)</code>，线程 B 调用 <code>push(2)</code>，最终栈中的元素顺序应该是 <code>2</code> 在栈顶，<code>1</code> 在栈底，或者 <code>1</code> 在栈顶，<code>2</code> 在栈底，这取决于线程调度的顺序。但无论如何，栈中的元素数量应该是正确的，并且后续的 <code>pop</code> 操作应该按照栈的规则依次返回元素。</li></ul></li><li><strong>示例 2：并发</strong><code>**pop**</code><strong>操作</strong><ul><li>线程 A 和线程 B 同时调用 <code>pop</code> 方法，栈中最初有两个元素 <code>[2, 1]</code>（<code>2</code> 为栈顶）。最终，两个线程应该分别获取到 <code>2</code> 和 <code>1</code>，不会出现两个线程都获取到 <code>2</code> 或者都获取到 <code>1</code> 的情况。</li></ul></li><li><strong>示例 3：并发</strong><code>**push**</code> 和 <code>pop</code><strong>操作</strong><ul><li>线程 A 调用 <code>push(1)</code>，线程 B 调用 <code>pop()</code>。如果 <code>push</code> 操作先于 <code>pop</code> 操作完成，那么 <code>pop</code> 操作应该返回 <code>1</code>；如果 <code>pop</code> 操作在 <code>push</code> 操作之前判断栈为空，那么 <code>pop</code> 操作应该返回 <code>null</code>。</li></ul></li></ul><h3 id="Lincheck-的主要功能和特点"><a href="#Lincheck-的主要功能和特点" class="headerlink" title="Lincheck 的主要功能和特点"></a>Lincheck 的主要功能和特点</h3><p>Lincheck 是一个用于测试并发数据结构线性一致性（linearizability）的框架，主要用于 Kotlin 和 Java 语言。以下是关于 Lincheck 的详细介绍：</p><h4 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h4><ul><li>自动生成测试用例：Lincheck 能够自动生成大量的并发测试用例，这些测试用例包含不同的操作组合和不同的线程交错执行情况。通过随机生成这些测试用例，Lincheck 可以覆盖到各种可能的并发场景，从而更全面地测试并发数据结构的正确性。</li><li>自动检查线性一致性：在执行生成的测试用例后，Lincheck 会自动检查并发数据结构的执行结果是否满足线性一致性。它会分析操作的执行顺序和结果，判断是否存在违反线性一致性的情况。</li></ul><h4 id="简洁易用"><a href="#简洁易用" class="headerlink" title="简洁易用"></a>简洁易用</h4><ul><li>注解驱动：Lincheck 使用注解来定义测试类和测试方法，开发人员只需要在代码中添加少量的注解，就可以快速创建并发测试。例如，使用 <code>@Operation</code> 注解来标记并发数据结构的操作方法，使用 <code>@Param</code> 注解来定义操作的参数范围等。</li><li>集成方便：Lincheck 可以很方便地集成到现有的测试框架中，如 JUnit 或 Kotlin 的测试框架。开发人员可以将 Lincheck 测试作为普通的单元测试来运行，无需进行复杂的配置。</li></ul><h4 id="跨平台支持"><a href="#跨平台支持" class="headerlink" title="跨平台支持"></a>跨平台支持</h4><p>Lincheck 支持多种并发模型和执行环境，包括 Java 的线程、Kotlin 的协程等。这使得它可以在不同的平台和并发编程模型下进行并发数据结构的测试。</p><h4 id="详细的错误报告"><a href="#详细的错误报告" class="headerlink" title="详细的错误报告"></a>详细的错误报告</h4><p>当 Lincheck 检测到并发数据结构存在线性一致性问题时，它会提供详细的错误报告。报告中会包含测试用例的执行历史、操作的调用顺序、线程的交错情况以及违反线性一致性的具体原因等信息。这些信息可以帮助开发人员快速定位和修复并发数据结构中的问题。</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>以下是一个使用 Lincheck 测试并发栈的简单示例：</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">import kotlinx.coroutines.*import org.jetbrains.kotlinx.lincheck.*import org.jetbrains.kotlinx.lincheck.annotations.*import org.jetbrains.kotlinx.lincheck.strategy.managed.modelchecking.*import org.jetbrains.kotlinx.lincheck.verifier.*&#x2F;&#x2F; 定义并发栈类class ConcurrentStack&lt;T&gt; &#123;    private val stack &#x3D; java.util.Stack&lt;T&gt;()    @Operation    fun push(value: T) &#123;        stack.push(value)    &#125;    @Operation    fun pop(): T? &#123;        return if (stack.isEmpty()) null else stack.pop()    &#125;&#125;&#x2F;&#x2F; 测试类class ConcurrentStackTest &#123;    private val stack &#x3D; ConcurrentStack&lt;Int&gt;()    @Operation    fun push(@Param(name &#x3D; &quot;value&quot;) value: Int) &#x3D; stack.push(value)    @Operation    fun pop() &#x3D; stack.pop()    &#x2F;&#x2F; 测试配置    @Test    fun test() &#123;        val options &#x3D; ModelCheckingOptions()            .iterations(100) &#x2F;&#x2F; 测试迭代次数            .threads(3) &#x2F;&#x2F; 并发线程数            .actorsPerThread(5) &#x2F;&#x2F; 每个线程的操作数        val result &#x3D; ModelCheckingChecker.check(this::class.java, options)        assert(result.passed())    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个示例中，我们定义了一个简单的并发栈类 <code>ConcurrentStack</code>，并使用 Lincheck 对其进行测试。通过 <code>@Operation</code> 注解标记了栈的 <code>push</code> 和 <code>pop</code> 操作，然后在测试类 <code>ConcurrentStackTest</code> 中定义了相应的测试方法。最后，使用 <code>ModelCheckingChecker</code> 来执行测试，并通过 <code>assert(result.passed())</code> 来验证测试是否通过。</p><p>在 <code>ConcurrentStack</code> 类中，<code>push</code> 和 <code>pop</code> 方法被标记为 <code>@Operation</code> 注解。这是 Lincheck 框架的一个重要特性，用于指定这些方法是并发操作的一部分。通过这种方式，Lincheck 可以自动生成不同的并发测试用例，模拟多个线程同时调用这些方法的情况，从而测试该栈在并发环境下的行为。</p><p>使用 Lincheck 进行测试时，如果 <code>ConcurrentStack</code> 满足线性一致性，测试应该通过，即 <code>ModelCheckingChecker.check</code> 方法的返回结果的 <code>passed()</code> 方法应该返回 <code>true</code>。</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">val result &#x3D; ModelCheckingChecker.check(this::class.java, options)assert(result.passed())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果测试不通过，Lincheck 会提供详细的错误报告，包括测试用例的执行历史、操作的调用顺序、线程的交错情况以及违反线性一致性的具体原因等信息，帮助开发人员定位和修复问题。</p><p>总之，符合预期的测试结果是 <code>ConcurrentStack</code> 在并发环境下的操作满足线性一致性，不会出现竞态条件和数据不一致的问题。</p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><h3 id="协程与线程进程的关系"><a href="#协程与线程进程的关系" class="headerlink" title="协程与线程进程的关系"></a>协程与线程进程的关系</h3><p>好的！以下是 <strong>协程（Coroutine）、线程（Thread）、进程（Process）</strong> 的关系解析，结合 <strong>Kotlin 代码示例</strong> 说明它们的区别和使用场景。</p><h4 id="关系概述与核心区别"><a href="#关系概述与核心区别" class="headerlink" title="关系概述与核心区别"></a><strong>关系概述与核心区别</strong></h4><table><thead><tr><th><strong>概念</strong></th><th><strong>定义</strong></th><th><strong>关系</strong></th></tr></thead><tbody><tr><td><strong>进程</strong></td><td>操作系统资源分配的基本单位，独立的内存空间和系统资源（如文件句柄）。</td><td><strong>进程 &gt; 线程 &gt; 协程</strong>：一个进程包含多个线程，一个线程可以运行多个协程。协程是线程中的轻量级任务。</td></tr><tr><td><strong>线程</strong></td><td>进程内的执行单元，共享进程的内存和资源，但有自己的栈和寄存器。</td><td>线程由操作系统调度，协程由开发者或协程库调度。</td></tr><tr><td><strong>协程</strong></td><td>用户态的轻量级线程，由程序控制调度（非抢占式），挂起时不会阻塞线程。</td><td>协程运行在线程之上，一个线程可同时执行多个协程（通过挂起&#x2F;恢复）。</td></tr></tbody></table><table><thead><tr><th><strong>特性</strong></th><th><strong>进程</strong></th><th><strong>线程</strong></th><th><strong>协程</strong></th></tr></thead><tbody><tr><td><strong>资源开销</strong></td><td>高（独立内存）</td><td>中（共享内存）</td><td>极低（无内核切换）</td></tr><tr><td><strong>调度方式</strong></td><td>操作系统调度</td><td>操作系统调度</td><td>程序控制（协作式调度）</td></tr><tr><td><strong>并发性</strong></td><td>多进程并行</td><td>多线程并行（需多核CPU）</td><td>单线程内伪并行（通过挂起）</td></tr><tr><td><strong>通信成本</strong></td><td>高（IPC机制）</td><td>中（共享内存+锁）</td><td>低（直接共享变量）</td></tr><tr><td><strong>适用场景</strong></td><td>高隔离性任务（如浏览器）</td><td>CPU密集型任务</td><td>I&#x2F;O密集型、高并发任务</td></tr></tbody></table><p>协程是可挂起计算的一个实例。从概念上讲，它与线程类似，都需要一个代码块与其他代码同时运行。不过，例程并不受制于任何特定的线程。它可以在一个线程中暂停执行，然后在另一个线程中继续执行。</p><p>可以把协程看作轻量级线程，但它们在实际使用中与线程有许多重要区别。</p><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a><strong>代码示例</strong></h4><ul><li><strong>(1) 进程</strong></li></ul><p>Kotlin&#x2F;JVM 中直接操作进程较少见（通常通过 <code>ProcessBuilder</code>），但可以启动独立程序：</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">&#x2F;&#x2F; 启动一个外部进程（如打开计算器）val process &#x3D; ProcessBuilder(&quot;calc.exe&quot;).start()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><strong>(2) 线程</strong></li></ul><p>Kotlin 通过 <code>thread</code> 函数或 <code>Executor</code> 创建线程：</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">&#x2F;&#x2F; 方式1：直接启动线程thread(name &#x3D; &quot;MyThread&quot;) &#123;    println(&quot;Thread running: $&#123;Thread.currentThread().name&#125;&quot;)    Thread.sleep(1000) &#x2F;&#x2F; 阻塞线程&#125;&#x2F;&#x2F; 方式2：使用线程池val executor &#x3D; Executors.newFixedThreadPool(2)executor.submit &#123;    println(&quot;Pool thread: $&#123;Thread.currentThread().name&#125;&quot;)&#125;executor.shutdown()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>(3) 协程</strong></li></ul><p>Kotlin 协程通过 <code>kotlinx.coroutines</code> 库实现：</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">import kotlinx.coroutines.*fun main() &#x3D; runBlocking &#123;    &#x2F;&#x2F; 启动一个协程（不阻塞当前线程）    val job &#x3D; launch(Dispatchers.Default) &#123;        println(&quot;Coroutine started on thread: $&#123;Thread.currentThread().name&#125;&quot;)        delay(1000) &#x2F;&#x2F; 挂起协程，不阻塞线程        println(&quot;Coroutine resumed!&quot;)    &#125;    &#x2F;&#x2F; 启动多个协程（单线程内并发）    val deferredResults &#x3D; (1..3).map &#123; i -&gt;        async &#123;            delay(1000L * i)            &quot;Result $i&quot;        &#125;    &#125;    &#x2F;&#x2F; 等待所有结果    deferredResults.forEach &#123; println(it.await()) &#125;    job.join() &#x2F;&#x2F; 等待协程结束&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>输出示例：</strong></p><pre class="line-numbers language-PlainText" data-language="PlainText"><code class="language-PlainText">Coroutine started on thread: DefaultDispatcher-worker-1Result 1Result 2Result 3Coroutine resumed!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="协程与线程的协作"><a href="#协程与线程的协作" class="headerlink" title="协程与线程的协作"></a><strong>协程与线程的协作</strong></h4><p>协程可以指定调度器（Dispatcher），决定它运行在哪个线程：</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">fun main() &#x3D; runBlocking &#123;    &#x2F;&#x2F; 协程1：运行在IO线程池    launch(Dispatchers.IO) &#123;        println(&quot;IO work on: $&#123;Thread.currentThread().name&#125;&quot;)    &#125;    &#x2F;&#x2F; 协程2：运行在主线程（Android中常用）    launch(Dispatchers.Main) &#123;        println(&quot;UI update on: $&#123;Thread.currentThread().name&#125;&quot;)    &#125;    &#x2F;&#x2F; 协程3：切换线程    withContext(Dispatchers.Default) &#123;        println(&quot;Computation on: $&#123;Thread.currentThread().name&#125;&quot;)    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>进程</strong>：资源隔离，适合独立任务（如浏览器标签）。</li><li><strong>线程</strong>：共享进程资源，适合CPU密集型任务，但需处理同步问题。</li><li><strong>协程</strong>：轻量级，适合高并发I&#x2F;O任务（如网络请求、数据库操作），通过挂起避免线程阻塞。</li></ul><p>在 Kotlin 中，协程是替代回调&#x2F;线程池的最佳实践，通过 <code>suspend</code> 函数和结构化并发简化异步代码。</p><h3 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h3><p>在 Kotlin 协程中，虽然协程的核心功能由 <code>kotlinx.coroutines</code> 库提供，但语言本身也通过一些关键字和库函数来支持协程编程。以下是关键概念和协程启动过程的详细说明：</p><h4 id="协程的「关键字」与核心概念"><a href="#协程的「关键字」与核心概念" class="headerlink" title="协程的「关键字」与核心概念"></a><strong>协程的「关键字」与核心概念</strong></h4><p>严格来说，Kotlin 协程的专用关键字只有 <code>suspend</code>，其他是协程库中的函数或类。以下是关键术语及其作用：</p><table><thead><tr><th><strong>关键字&#x2F;函数&#x2F;类</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><code>**suspend**</code></td><td>标记函数为挂起函数，只能在协程或其他挂起函数中调用。</td></tr><tr><td><code>**CoroutineScope**</code></td><td>协程作用域，管理协程的生命周期（如取消）。</td></tr><tr><td><code>**launch**</code></td><td>启动一个不返回结果的协程（返回 <code>Job</code>）。</td></tr><tr><td><code>**async**</code></td><td>启动一个返回 <code>Deferred&lt;T&gt;</code> 的协程（可通过 <code>await()</code> 获取结果）。</td></tr><tr><td><code>**runBlocking**</code></td><td>创建一个阻塞当前线程的协程作用域，通常用于测试或 <code>main</code> 函数。</td></tr><tr><td><code>**withContext**</code></td><td>切换协程的上下文（如线程池），并返回结果。</td></tr><tr><td><code>**Job**</code></td><td>表示一个协程的任务，用于控制生命周期（取消、等待完成）。</td></tr><tr><td><code>**Deferred**</code></td><td>继承自 <code>Job</code>，表示一个异步计算的结果（通过 <code>async</code> 启动）。</td></tr><tr><td><code>**CoroutineDispatcher**</code></td><td>协程调度器，决定协程在哪个线程池运行（如 <code>Dispatchers.IO</code>）。</td></tr><tr><td><code>**coroutineScope**</code></td><td>创建一个子作用域，所有子协程完成前不会退出。</td></tr><tr><td><code>**supervisorScope**</code></td><td>类似 <code>coroutineScope</code>，但子协程的失败不会影响其他子协程。</td></tr></tbody></table><h4 id="如何启动一个协程？"><a href="#如何启动一个协程？" class="headerlink" title="如何启动一个协程？"></a><strong>如何启动一个协程？</strong></h4><ul><li><strong>(1) 添加依赖</strong></li></ul><p>在 <code>build.gradle.kts</code> 中添加协程库依赖（必需）：</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">dependencies &#123;    implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.8.0&quot;)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><strong>(2) 启动协程的两种方式</strong></li></ul><p><strong>方式 1：</strong><code>launch</code><strong>（不返回结果）</strong></p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">import kotlinx.coroutines.*fun main() &#x3D; runBlocking &#123; &#x2F;&#x2F; 1. 创建阻塞式协程作用域    val job &#x3D; launch &#123;     &#x2F;&#x2F; 2. 启动协程，返回 Job        delay(1000)        &#x2F;&#x2F; 3. 挂起协程，不阻塞线程        println(&quot;World!&quot;)    &#125;    println(&quot;Hello,&quot;)    job.join()            &#x2F;&#x2F; 4. 等待协程完成&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>方式 2：</strong><code>async</code><strong>（返回结果）</strong></p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">import kotlinx.coroutines.*fun main() &#x3D; runBlocking &#123;    val deferred &#x3D; async &#123; &#x2F;&#x2F; 启动协程，返回 Deferred&lt;Int&gt;        delay(1000)        42    &#125;    println(&quot;Result: $&#123;deferred.await()&#125;&quot;) &#x2F;&#x2F; 等待结果&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3. 关键代码元素解析</strong></p><p><strong>(1)</strong><code>**runBlocking**</code></p><ul><li><strong>作用</strong>：创建一个阻塞当前线程的协程作用域，直到内部所有协程完成。</li><li><strong>使用场景</strong>：用于 <code>main</code> 函数或测试代码，将阻塞代码与协程桥接。</li></ul><p><strong>(2)</strong><code>**launch**</code> 和 <code>**async**</code></p><table><thead><tr><th><strong>对比项</strong></th><th><code>**launch**</code></th><th><code>**async**</code></th></tr></thead><tbody><tr><td><strong>返回值</strong></td><td><code>Job</code>（表示任务）</td><td><code>Deferred&lt;T&gt;</code>（延迟计算的结果）</td></tr><tr><td><strong>用途</strong></td><td>执行不需要返回值的任务（如日志、更新UI）</td><td>执行需要返回值的异步计算（如网络请求）</td></tr><tr><td><strong>结果获取</strong></td><td>无</td><td>通过 <code>await()</code> 获取结果</td></tr></tbody></table><p><strong>(3)</strong><code>**suspend**</code><strong>函数</strong></p><ul><li><strong>定义</strong>：只能在协程或其他挂起函数中调用的函数。</li><li><strong>示例</strong>：</li></ul><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">suspend fun fetchData(): String &#123;    delay(1000)    return &quot;Data loaded&quot;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>(4)</strong><code>**withContext**</code></p><ul><li><strong>作用</strong>：切换协程的调度器（如从 IO 线程切换到主线程）。</li><li><strong>示例</strong>：</li></ul><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">suspend fun loadData() &#x3D; withContext(Dispatchers.IO) &#123;    &#x2F;&#x2F; 在 IO 线程执行耗时操作&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="协程调度器（Dispatchers）"><a href="#协程调度器（Dispatchers）" class="headerlink" title="协程调度器（Dispatchers）"></a><strong>协程调度器（Dispatchers）</strong></h4><table><thead><tr><th><strong>调度器</strong></th><th><strong>用途</strong></th></tr></thead><tbody><tr><td><code>Dispatchers.Default</code></td><td>CPU 密集型任务（如计算、排序）</td></tr><tr><td><code>Dispatchers.IO</code></td><td>I&#x2F;O 密集型任务（如网络请求、文件读写）</td></tr><tr><td><code>Dispatchers.Main</code></td><td>主线程更新 UI（Android 或 JavaFX）</td></tr><tr><td><code>Dispatchers.Unconfined</code></td><td>不限制线程（慎用）</td></tr></tbody></table><h4 id="结构化并发示例"><a href="#结构化并发示例" class="headerlink" title="结构化并发示例"></a><strong>结构化并发示例</strong></h4><p>协程通过作用域（<code>CoroutineScope</code>）实现结构化生命周期管理：</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">import kotlinx.coroutines.*fun main() &#x3D; runBlocking &#123;    &#x2F;&#x2F; 父协程    coroutineScope &#123; &#x2F;&#x2F; 所有子协程完成前不会退出        launch &#123;             delay(1000)            println(&quot;Task 1&quot;)        &#125;        launch &#123;            delay(500)            println(&quot;Task 2&quot;)        &#125;    &#125;    println(&quot;All tasks completed!&quot;)&#125;&#x2F;&#x2F; 输出顺序：Task 2 → Task 1 → All tasks completed!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><ul><li><strong>核心关键字</strong>：<code>suspend</code>。</li><li><strong>启动协程</strong>：通过 <code>launch</code> 或 <code>async</code>，需在协程作用域（如 <code>runBlocking</code>）内调用。</li><li><strong>调度器</strong>：通过 <code>Dispatchers</code> 指定协程运行的线程池。</li><li><strong>结构化并发</strong>：通过 <code>coroutineScope</code> 或 <code>supervisorScope</code> 管理子协程。</li></ul><h3 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h3><h4 id="协程的取消与超时"><a href="#协程的取消与超时" class="headerlink" title="协程的取消与超时"></a>协程的取消与超时</h4><p>Kotlin 协程支持通过 <code>CoroutineScope</code> 来取消协程。你可以调用 <code>cancel()</code> 方法来取消一个协程。使用 <code>withTimeout</code> 函数可以设置一个超时时间，如果在规定时间内协程未完成，则会被取消。</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">import kotlinx.coroutines.*fun main() &#x3D; runBlocking &#123;    val job &#x3D; launch &#123;        &#x2F;&#x2F; 模拟长时间运行的任务        repeat(1000) &#123; i -&gt;            println(&quot;Job: $i&quot;)            delay(500L)        &#125;    &#125;    delay(1300L) &#x2F;&#x2F; 等待一段时间    job.cancel() &#x2F;&#x2F; 取消协程    println(&quot;Job cancelled&quot;)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="组合挂起函数"><a href="#组合挂起函数" class="headerlink" title="组合挂起函数"></a>组合挂起函数</h4><p>挂起函数可以组合使用，允许在一个协程中调用多个挂起函数。通过使用 <code>async</code> 和 <code>await</code>，可以并行执行多个任务，并在需要时等待它们完成。</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">suspend fun fetchData(): String &#123;    &#x2F;&#x2F; 模拟网络请求    delay(1000)    return &quot;Data&quot;&#125;fun main() &#x3D; runBlocking &#123;    val data &#x3D; async &#123; fetchData() &#125;    println(&quot;Fetching data...&quot;)    println(data.await()) &#x2F;&#x2F; 等待数据返回&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="异步流"><a href="#异步流" class="headerlink" title="异步流"></a>异步流</h4><p>Kotlin 的 <code>Flow</code> 提供了一种异步流的方式来处理数据流。<code>Flow</code> 是冷流（cold stream），只有在收集时才会开始执行。</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">import kotlinx.coroutines.flow.*fun simpleFlow(): Flow&lt;Int&gt; &#x3D; flow &#123;    for (i in 1..3) &#123;        delay(1000) &#x2F;&#x2F; 模拟耗时操作        emit(i) &#x2F;&#x2F; 发射下一个值    &#125;&#125;fun main() &#x3D; runBlocking &#123;    simpleFlow().collect &#123; value -&gt;        println(value)    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h4><p>通道（Channel）是一个用于在协程之间传输数据的非阻塞队列。它可以用于实现生产者-消费者模式。</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">import kotlinx.coroutines.channels.*fun main() &#x3D; runBlocking &#123;    val channel &#x3D; Channel&lt;Int&gt;()    &#x2F;&#x2F; 生产者    launch &#123;        for (x in 1..5) channel.send(x * x) &#x2F;&#x2F; 发送平方数        channel.close() &#x2F;&#x2F; 关闭通道    &#125;    &#x2F;&#x2F; 消费者    for (y in channel) &#123;        println(y) &#x2F;&#x2F; 接收并打印    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="协程异常处理"><a href="#协程异常处理" class="headerlink" title="协程异常处理"></a>协程异常处理</h4><p>Kotlin 协程提供了 <code>CoroutineExceptionHandler</code> 来处理协程中的异常。</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">val handler &#x3D; CoroutineExceptionHandler &#123; _, exception -&gt;    println(&quot;Caught $exception&quot;)&#125;fun main() &#x3D; runBlocking(handler) &#123;    launch &#123;        throw AssertionError(&quot;Something went wrong!&quot;)    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="共享的可变状态与并发"><a href="#共享的可变状态与并发" class="headerlink" title="共享的可变状态与并发"></a>共享的可变状态与并发</h4><p>Kotlin 协程支持共享可变状态，使用 <code>Mutex</code> 和 <code>Atomic</code> 类型来保证线程安全。</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">import kotlinx.coroutines.*import kotlinx.coroutines.sync.Muteximport kotlinx.coroutines.sync.withLockvar counter &#x3D; 0val mutex &#x3D; Mutex()suspend fun increment() &#123;    mutex.withLock &#123;        counter++    &#125;&#125;fun main() &#x3D; runBlocking &#123;    val jobs &#x3D; List(100) &#123;        launch &#123;            repeat(1000) &#123;                increment()            &#125;        &#125;    &#125;    jobs.forEach &#123; it.join() &#125;    println(&quot;Counter &#x3D; $counter&quot;)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="日期与时间"><a href="#日期与时间" class="headerlink" title="日期与时间"></a>日期与时间</h2><p><code>kotlinx-datetime</code> 是 Kotlin 官方推出的跨平台日期时间处理库，旨在为 Kotlin Multiplatform 项目提供统一的日期时间操作 API。它设计简洁且与 Java 的 <code>java.time</code> 包类似，但完全兼容 Kotlin 的跨平台特性（支持 JVM、JS、Native 等平台）。</p><h3 id="基本使用-2"><a href="#基本使用-2" class="headerlink" title="基本使用"></a>基本使用</h3><ul><li>在 <code>build.gradle.kts</code> 中添加依赖：</li></ul><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">kotlin &#123;    sourceSets &#123;        commonMain &#123;            dependencies &#123;                implementation(&quot;org.jetbrains.kotlinx:kotlinx-datetime:0.4.0&quot;) &#x2F;&#x2F; 检查最新版本            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>创建日期时间对象</strong></li></ul><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">import kotlinx.datetime.*&#x2F;&#x2F; 获取当前时间（基于系统时钟）val now: Instant &#x3D; Clock.System.now()&#x2F;&#x2F; 创建 LocalDate（日期）val date &#x3D; LocalDate(2023, 10, 1)&#x2F;&#x2F; 创建 LocalDateTime（日期 + 时间）val dateTime &#x3D; LocalDateTime(2023, 10, 1, 12, 30, 15)&#x2F;&#x2F; 解析字符串为日期时间val parsedDate &#x3D; LocalDate.parse(&quot;2023-10-01&quot;)val parsedDateTime &#x3D; LocalDateTime.parse(&quot;2023-10-01T12:30:15&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>格式化与解析</strong></li></ul><p>使用 <code>format</code> 和 <code>parse</code> 进行字符串转换：</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">import kotlinx.datetime.format.*&#x2F;&#x2F; 自定义格式val format &#x3D; LocalDate.Format &#123;    year()    char(&#39;&#x2F;&#39;)    monthNumber()    char(&#39;&#x2F;&#39;)    dayOfMonth()&#125;val dateString &#x3D; format.format(LocalDate(2023, 10, 1)) &#x2F;&#x2F; &quot;2023&#x2F;10&#x2F;01&quot;val parsedDate &#x3D; format.parse(&quot;2023&#x2F;10&#x2F;01&quot;) &#x2F;&#x2F; LocalDate(2023, 10, 1)&#x2F;&#x2F; 使用预定义的 ISO 格式val isoDateString &#x3D; LocalDate(2023, 10, 1).toString() &#x2F;&#x2F; &quot;2023-10-01&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>时间计算与差值</strong></li></ul><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">val today &#x3D; LocalDate(2023, 10, 1)val tomorrow &#x3D; today + DatePeriod(days &#x3D; 1)val yesterday &#x3D; today - DatePeriod(months &#x3D; 1)&#x2F;&#x2F; 计算两个日期的差值val daysBetween &#x3D; today.daysUntil(tomorrow) &#x2F;&#x2F; 1&#x2F;&#x2F; 计算时间差（Duration）val start &#x3D; Instant.parse(&quot;2023-10-01T00:00:00Z&quot;)val end &#x3D; Instant.parse(&quot;2023-10-02T12:00:00Z&quot;)val duration &#x3D; end - start &#x2F;&#x2F; 36.hours<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>时区处理</strong></li></ul><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">&#x2F;&#x2F; 将 Instant 转换为带时区的日期时间val timeZone &#x3D; TimeZone.of(&quot;Asia&#x2F;Shanghai&quot;)val zonedDateTime &#x3D; now.toLocalDateTime(timeZone)&#x2F;&#x2F; 时区转换val newYorkTime &#x3D; zonedDateTime.toInstant(TimeZone.of(&quot;America&#x2F;New_York&quot;))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>时间区间与比较</strong></li></ul><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">val date1 &#x3D; LocalDate(2023, 10, 1)val date2 &#x3D; LocalDate(2023, 10, 5)&#x2F;&#x2F; 比较日期val isBefore &#x3D; date1 &lt; date2 &#x2F;&#x2F; true&#x2F;&#x2F; 创建时间区间val dateRange &#x3D; date1..date2val isInRange &#x3D; LocalDate(2023, 10, 3) in dateRange &#x2F;&#x2F; true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>跨平台注意事项：</strong></p><ul><li><strong>JS 和 Native 平台</strong>：部分功能（如复杂时区规则）可能依赖平台实现，需确保目标平台支持。</li><li><strong>与 Java 互操作</strong>：在 JVM 上，可以通过扩展函数与 <code>java.time</code> 互转：</li></ul><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">&#x2F;&#x2F; 转换为 java.time.LocalDateval javaLocalDate: java.time.LocalDate &#x3D; kotlinDate.toJavaLocalDate()&#x2F;&#x2F; 从 java.time 转换val kotlinDate: LocalDate &#x3D; javaLocalDate.toKotlinLocalDate()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="常见场景示例"><a href="#常见场景示例" class="headerlink" title="常见场景示例"></a><strong>常见场景示例</strong></h3><ul><li><strong>获取本周的起始和结束日期</strong></li></ul><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">val today &#x3D; Clock.System.todayIn(TimeZone.currentSystemDefault())val startOfWeek &#x3D; today - DatePeriod(days &#x3D; today.dayOfWeek.ordinal)val endOfWeek &#x3D; startOfWeek + DatePeriod(days &#x3D; 6)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><strong>计算任务执行时间</strong></li></ul><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">val startTime &#x3D; Clock.System.now()&#x2F;&#x2F; 执行任务...val endTime &#x3D; Clock.System.now()val elapsed &#x3D; endTime - startTimeprintln(&quot;耗时: $&#123;elapsed.inWholeSeconds&#125; 秒&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Android" scheme="https://blog.pengdonglai.com/categories/Android/"/>
    
    <category term="基础语法" scheme="https://blog.pengdonglai.com/categories/Android/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    
    
    <category term="Android" scheme="https://blog.pengdonglai.com/tags/Android/"/>
    
    <category term="Kotlin" scheme="https://blog.pengdonglai.com/tags/Kotlin/"/>
    
    <category term="基础语法" scheme="https://blog.pengdonglai.com/tags/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>安卓（1）-语法基础：Kotlin ＆ Java ＆ TS 对比</title>
    <link href="https://blog.pengdonglai.com/2025/01/29/android-1/"/>
    <id>https://blog.pengdonglai.com/2025/01/29/android-1/</id>
    <published>2025-01-29T11:52:36.000Z</published>
    <updated>2025-02-03T12:24:56.448Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote><p>2024 年我开始逐渐介入客户端的研发，因此我开始学习客户端的知识。<br>从服务端开始，转到前端来其实完全代表着我的编码风格的转变。我喜欢 UI 编程那「所见即所得」的惊艳，也喜欢人机交互相关的内容。<br>做 C 端 App，前端技术实际上更多是一种强行「卷」过来的结果：首先，基础肯定是客户端技术 Android&#x2F;iOS，但是前端的作用越来越清晰。当然，目前的大环境下走入前端甚至客户端开发通常被认为是一种开倒车的举动。但这种东西谁又说得好呢——难道做算法调优几个版本实验指标波动，亦或者做服务端大半夜被机器人打电话就能让人兴奋了吗？<br>人总有无知的时候，在已知信息差的时候我们总有一天要为认知买单。所以就让我们为梦想，做出一次不那么受到束缚的选择吧。<br>这是安卓系列的第一期，它包含以下内容：<br><a href="/2025/01/29/android-1/">安卓（1）-语法基础：Kotlin ＆ Java ＆ TS 对比</a><br><a href="/2025/01/29/android-2/">安卓（2）-语法基础：Kotlin 常用库（1）</a><br><a href="/2025/01/29/android-3/">安卓（3）-实用篇：UI（1）</a><br>我使用了 AI 来辅助我创作了一些重复性的工作，第一期内容会以相关知识的罗列为主，所以最好的阅读方式是阅读后进行查漏补缺。<br>希望大家可以喜欢这些教程！</p></blockquote><p>前端研发学习客户端开发很有必要，主要体现在以下几方面：</p><ul><li>拓宽技术栈，增强竞争力：当前技术就业市场青睐全栈开发能力，掌握客户端开发知识，能让前端开发者从专注浏览器端用户界面，拓展到移动、桌面等多种客户端平台的开发，满足更多类型项目的需求。在求职和职业发展中更具优势，尤其对于追求低成本、高效率的企业，一专多能的开发者更受欢迎。</li><li>提升用户体验理解：用户期望不同设备间体验一致，学习客户端开发能让前端开发者参与跨平台应用开发，实现网页端和客户端体验的无缝过渡。同时，客户端开发涉及更多硬件资源利用和性能优化技巧，有助于前端开发者将这些理念应用到前端开发中，提升整体用户体验。</li><li>更好地进行团队协作：在包含多种角色的开发团队里，了解客户端开发能使前端开发者与客户端开发人员沟通更顺畅，减少因技术认知差异产生的沟通障碍，提高协作效率。在项目规划阶段，还能结合前端和客户端的特点，提出更合理的技术方案，避免后期出现平台开发不协调的问题。</li></ul><p>目标：</p><ul><li>语言能力：for 前端同学，能看懂 Java 代码，能上手写 Kotlin 代码。</li></ul><h3 id="Kotlin-＆-Java"><a href="#Kotlin-＆-Java" class="headerlink" title="Kotlin ＆ Java"></a>Kotlin ＆ Java</h3><p><strong>Kotlin</strong>是一种在 <a href="https://zh.wikipedia.org/wiki/Java%E8%99%9B%E6%93%AC%E6%A9%9F">Java 虚拟机</a>上执行的<a href="https://zh.wikipedia.org/wiki/%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B">静态类型</a><a href="https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80">编程语言</a>，它也可以被编译成为 <a href="https://zh.wikipedia.org/wiki/JavaScript">JavaScript</a> 源代码。它主要是由 <a href="https://zh.wikipedia.org/wiki/JetBrains">JetBrains</a> 在<a href="https://zh.wikipedia.org/wiki/%E4%BF%84%E7%BE%85%E6%96%AF">俄罗斯</a><a href="https://zh.wikipedia.org/wiki/%E8%81%96%E5%BD%BC%E5%BE%97%E5%A0%A1">圣彼得堡</a>的开发团队所发展出来的编程语言，其名称来自于圣彼得堡附近的<a href="https://zh.wikipedia.org/wiki/%E7%A7%91%E7%89%B9%E6%9E%97%E5%B3%B6">科特林岛</a>。</p><h3 id="Kotlin-的优势（对比-Java）"><a href="#Kotlin-的优势（对比-Java）" class="headerlink" title="Kotlin 的优势（对比 Java）"></a>Kotlin 的优势（对比 Java）</h3><p><strong>富有表现力且简洁</strong> 您可以使用更少的代码实现更多的功能。表达自己的想法，少编写样板代码。在使用 Kotlin 的专业开发者中，有 67% 的人反映其工作效率有所提高。</p><p><strong>更安全的代码</strong> Kotlin 有许多语言功能，可帮助您避免 null 指针异常等常见编程错误。包含 Kotlin 代码的 Android 应用发生崩溃的可能性降低了 20%。</p><p><strong>可互操作</strong> 您可以在 Kotlin 代码中调用 Java 代码，或者在 Java 代码中调用 Kotlin 代码。Kotlin 可完全与 Java 编程语言互操作，因此您可以根据需要在项目中添加任意数量的 Kotlin 代码。</p><p><strong>结构化并发</strong> Kotlin 协程让异步代码像阻塞代码一样易于使用。协程可大幅简化后台任务管理，例如网络调用、本地数据访问等任务的管理。</p><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="1-1-变量、常量声明"><a href="#1-1-变量、常量声明" class="headerlink" title="1.1 变量、常量声明"></a>1.1 变量、常量声明</h4><p>在 Kotlin 中，可以使用 val 或 var 关键字声明变量。var 声明的变量可以在程序执行期间重新赋值，而 val 声明的变量则不能重新赋值，使用方式跟 TypeScript 类似。</p><ul><li><p>TypeScript</p></li><li><p><strong>常量</strong>：使用 <code>const</code> 声明。</p></li><li><p><strong>变量</strong>：使用 <code>let</code> 或 <code>var</code> 声明。</p></li></ul><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">Example</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 常量</span>    <span class="token keyword">static</span> <span class="token keyword">readonly</span> <span class="token constant">CONSTANT_VALUE</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token comment">// 变量</span>    variableValue<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>    <span class="token function">constructor</span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>variableValue <span class="token operator">=</span> value<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>Java</p></li><li><p><strong>常量</strong>：使用 <code>final</code> 关键字声明。</p></li><li><p><strong>变量</strong>：可使用 <code>int</code>、<code>String</code> 等基本类型或对象类型声明。</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Example</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 常量</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">CONSTANT_VALUE</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token comment">// 变量</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> variableValue<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Example</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>variableValue <span class="token operator">=</span> value<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>Kotlin</p></li><li><p><strong>常量</strong>：使用 <code>val</code> 声明（不可变），使用 <code>const val</code> 声明编译时常量。</p></li><li><p><strong>变量</strong>：使用 <code>var</code> 声明（可变）。</p></li></ul><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">class</span> <span class="token function">Example</span><span class="token punctuation">(</span>value<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 常量</span>    <span class="token keyword">companion</span> <span class="token keyword">object</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">const</span> <span class="token keyword">val</span> CONSTANT_VALUE <span class="token operator">=</span> <span class="token number">10</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 变量</span>    <span class="token keyword">var</span> variableValue<span class="token operator">:</span> Int <span class="token operator">=</span> value<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-变量类型"><a href="#1-2-变量类型" class="headerlink" title="1.2 变量类型"></a>1.2 变量类型</h4><h5 id="1-2-1-基本类型"><a href="#1-2-1-基本类型" class="headerlink" title="1.2.1 基本类型"></a>1.2.1 基本类型</h5><ol><li>TypeScript</li></ol><ul><li><strong>基本类型</strong>包括 <code>number</code>, <code>boolean</code>, <code>string</code>, <code>bigint</code>, <code>symbol</code>, <code>null</code>, <code>undefined</code>。</li><li>可以使用 <code>null</code> 和 <code>undefined</code>，类型可以声明为可选的。</li></ul><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">let</span> num<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token comment">// 基本类型</span><span class="token keyword">let</span> nullableNum<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 可为 null</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="2"><li>Java</li></ol><ul><li><strong>基本类型</strong>有 <code>int</code>, <code>boolean</code>, <code>char</code>, <code>byte</code>, <code>short</code>, <code>long</code>, <code>float</code>, <code>double</code>。</li><li>使用包装类来处理 <code>null</code> 值，例如 <code>Integer</code>。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token comment">// 基本类型</span><span class="token class-name">Integer</span> nullableNum <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 包装类</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="3"><li>Kotlin</li></ol><ul><li><strong>基本类型</strong>使用 <code>Int</code>, <code>Boolean</code>, <code>Char</code>, <code>Byte</code>, <code>Short</code>, <code>Long</code>, <code>Float</code>, <code>Double</code>。</li><li>默认不可为 <code>null</code>，使用 <code>?</code> 表示可为 <code>null</code>。</li></ul><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">val</span> num<span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token number">42</span> <span class="token comment">// 基本类型</span><span class="token keyword">val</span> nullableNum<span class="token operator">:</span> Int<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span> <span class="token comment">// 可为 null</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="1-2-2-包装类型"><a href="#1-2-2-包装类型" class="headerlink" title="1.2.2 包装类型"></a>1.2.2 包装类型</h4><p>包装类是用于将基本数据类型（如整数、布尔值等）封装成对象类型的类。包装类的主要作用是允许基本类型与对象进行交互，提供了更多的方法和功能。</p><p>在 TypeScript 中，基本类型没有单独的包装类，但可以使用对象类型。例如，<code>number</code> 和 <code>string</code> 是基本类型，但可以与对象交互。</p><ul><li><strong>特点</strong>：<ul><li><code>null</code> 和 <code>undefined</code> 可以被作为类型。</li><li>可以使用对象类型（如 <code>Number</code> 和 <code>String</code>）来模拟包装类的功能。</li></ul></li></ul><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">let</span> wrappedInt<span class="token operator">:</span> Number <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Number</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 使用 Number 对象</span><span class="token keyword">let</span> primitiveInt<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> wrappedInt<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取基本类型</span><span class="token keyword">let</span> nullableInt<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 可为 null</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>wrappedInt <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 15</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>nullableInt<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 null</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 Java 中，包装类是与基本类型相对应的类。每种基本类型都有一个对应的包装类：</p><ul><li><p><code>int</code> -&gt; <code>Integer</code></p></li><li><p><code>boolean</code> -&gt; <code>Boolean</code></p></li><li><p><code>char</code> -&gt; <code>Character</code></p></li><li><p><code>byte</code> -&gt; <code>Byte</code></p></li><li><p><code>short</code> -&gt; <code>Short</code></p></li><li><p><code>long</code> -&gt; <code>Long</code></p></li><li><p><code>float</code> -&gt; <code>Float</code></p></li><li><p><code>double</code> -&gt; <code>Double</code></p></li><li><p><strong>特点</strong>：</p><ul><li>包装类可以为 <code>null</code>，而基本类型不能。</li><li>提供了一些方法，比如转换、比较等。</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 使用包装类</span>        <span class="token class-name">Integer</span> wrappedInt <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将 int 转换为 Integer</span>        <span class="token keyword">int</span> primitiveInt <span class="token operator">=</span> wrappedInt<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将 Integer 转换为 int</span>        <span class="token comment">// 可以为 null</span>        <span class="token class-name">Integer</span> nullableInt <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>wrappedInt <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 15</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>nullableInt<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 null</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 Kotlin 中，基本类型和对象类型有更紧密的结合。Kotlin 不再使用单独的包装类，而是直接使用对象类型（如 <code>Int</code>、<code>Boolean</code>）。Kotlin 的基本类型会在 JVM 中优化为原始类型。</p><ul><li><strong>特点</strong>：<ul><li>默认不可为 <code>null</code>，使用 <code>?</code> 表示可为 <code>null</code>。</li><li>不需要显式的转换方法，Kotlin 会自动进行转换。</li></ul></li></ul><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 使用基本类型</span>    <span class="token keyword">val</span> wrappedInt<span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token number">5</span> <span class="token comment">// 直接使用 Int 类型</span>    <span class="token keyword">val</span> nullableInt<span class="token operator">:</span> Int<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span> <span class="token comment">// 可为 null</span>    <span class="token comment">// 可以直接进行运算</span>    <span class="token function">println</span><span class="token punctuation">(</span>wrappedInt <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token comment">// 输出 15</span>    <span class="token function">println</span><span class="token punctuation">(</span>nullableInt<span class="token punctuation">)</span> <span class="token comment">// 输出 null</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-3-模板字符串"><a href="#1-2-3-模板字符串" class="headerlink" title="1.2.3 模板字符串"></a>1.2.3 模板字符串</h4><p>在 TypeScript 中，使用反引号（&#96;&#96;&#96;）来定义模板字符串，支持多行字符串和插值。可以使用 <code>$&#123;&#125;</code> 语法插入变量或表达式。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> name<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">"Alice"</span><span class="token punctuation">;</span><span class="token keyword">const</span> age<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span><span class="token keyword">const</span> greeting<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hello, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>name<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">. You are </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>age<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string"> years old.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>greeting<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出: Hello, Alice. You are 30 years old.</span><span class="token comment">// 多行字符串</span><span class="token keyword">const</span> multiLine <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">This is line one.This is line two.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>multiLine<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 Java 中，虽然没有直接的模板字符串语法，但可以使用字符串连接运算符（<code>+</code>）或 <code>String.format()</code> 方法来实现字符串插值。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token string">"Alice"</span><span class="token punctuation">;</span><span class="token keyword">int</span> age <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span><span class="token class-name">String</span> greeting <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"Hello, %s. You are %d years old."</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>greeting<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出: Hello, Alice. You are 30 years old.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Kotlin 支持使用 <code>$</code> 符号进行字符串插值，语法更加简洁。可以直接在字符串中使用变量，也可以使用花括号 <code>&#123;&#125;</code> 来插入表达式。</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">val</span> name <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"Alice"</span></span><span class="token keyword">val</span> age <span class="token operator">=</span> <span class="token number">30</span><span class="token keyword">val</span> greeting <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"Hello, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">name</span></span><span class="token string">. You are </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">age</span></span><span class="token string"> years old."</span></span><span class="token function">println</span><span class="token punctuation">(</span>greeting<span class="token punctuation">)</span> <span class="token comment">// 输出: Hello, Alice. You are 30 years old.</span><span class="token comment">// 使用表达式</span><span class="token keyword">val</span> greetingWithExpression <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"Hello, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token expression">name<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">. You are </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">age</span></span><span class="token string"> years old."</span></span><span class="token function">println</span><span class="token punctuation">(</span>greetingWithExpression<span class="token punctuation">)</span> <span class="token comment">// 输出: Hello, ALICE. You are 30 years old.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-4-枚举"><a href="#1-2-4-枚举" class="headerlink" title="1.2.4 枚举"></a>1.2.4 枚举</h4><p><strong>Java、Kotlin:</strong> 枚举是类，可以有构造函数和方法，支持字段和行为。</p><p><strong>TypeScript</strong>: 提供数字和字符串枚举，语法简单，主要用于定义常量集合。</p><p>在 TypeScript 中，枚举可以是数字枚举或字符串枚举。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">enum</span> Color <span class="token punctuation">&#123;</span>    Red <span class="token operator">=</span> <span class="token string">"RED"</span><span class="token punctuation">,</span>    Green <span class="token operator">=</span> <span class="token string">"GREEN"</span><span class="token punctuation">,</span>    Blue <span class="token operator">=</span> <span class="token string">"BLUE"</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token comment">// 使用枚举</span><span class="token keyword">let</span> color<span class="token operator">:</span> Color <span class="token operator">=</span> Color<span class="token punctuation">.</span>Red<span class="token punctuation">;</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>color<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出: "RED"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 Java 中，枚举是一个特殊的类，可以具有字段、方法和构造函数。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Color</span> <span class="token punctuation">&#123;</span>    <span class="token constant">RED</span><span class="token punctuation">,</span> <span class="token constant">GREEN</span><span class="token punctuation">,</span> <span class="token constant">BLUE</span><span class="token punctuation">;</span>    <span class="token comment">// 可以添加字段和方法</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> hex<span class="token punctuation">;</span>    <span class="token class-name">Color</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>hex <span class="token operator">=</span> <span class="token string">"#"</span> <span class="token operator">+</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">toHexString</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">ordinal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getHex</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> hex<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 使用枚举</span><span class="token class-name">Color</span> color <span class="token operator">=</span> <span class="token class-name">Color</span><span class="token punctuation">.</span><span class="token constant">RED</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>color<span class="token punctuation">.</span><span class="token function">getHex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 Kotlin 中，枚举类是一个特殊的类，支持属性和方法。</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token function">Color</span><span class="token punctuation">(</span><span class="token keyword">val</span> hex<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">RED</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"#FF0000"</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">GREEN</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"#00FF00"</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">BLUE</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"#0000FF"</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">fun</span> <span class="token function">describe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"Color: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">name</span></span><span class="token string">, Hex: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">hex</span></span><span class="token string">"</span></span><span class="token punctuation">&#125;</span><span class="token comment">// 使用枚举</span><span class="token keyword">val</span> color <span class="token operator">=</span> Color<span class="token punctuation">.</span>RED<span class="token function">println</span><span class="token punctuation">(</span>color<span class="token punctuation">.</span><span class="token function">describe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 输出: Color: RED, Hex: #FF0000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-3-类型检查和类型转换"><a href="#1-3-类型检查和类型转换" class="headerlink" title="1.3 类型检查和类型转换"></a>1.3 类型检查和类型转换</h4><p><strong>类型推断</strong>：</p><ul><li>Java 需要显式声明类型。</li><li>Kotlin 和 TypeScript 支持隐式推断，可以省略类型声明。</li></ul><p><strong>类型转换</strong>：</p><ul><li>Java 使用强制转换语法，Kotlin 使用转换方法，TypeScript 使用 <code>as</code> 进行转换。</li></ul><p><strong>强制类型转换</strong>：</p><ul><li>Java 和 TypeScript 使用直接的强制转换语法，Kotlin 提供了安全转换的方式。</li></ul><p>在 TypeScript 中，支持类型推导，可以省略类型声明，编译器会根据初始值推断类型。</p><ul><li><strong>隐式推断</strong>：TypeScript 也支持类型推断，可以省略类型声明，编译器会根据初始值推断类型。</li><li><strong>类型转换</strong>：可以使用 <code>as</code> 进行类型转换，也可以使用类型断言。</li><li><strong>强制类型转换</strong>：使用 <code>as</code> 进行类型断言。</li></ul><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// 类型推导</span><span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token comment">// 隐式推断为 number</span><span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span> <span class="token comment">// 隐式推断为 string</span><span class="token comment">// 类型转换</span><span class="token keyword">let</span> d<span class="token operator">:</span> <span class="token builtin">any</span> <span class="token operator">=</span> <span class="token number">9.78</span><span class="token punctuation">;</span> <span class="token keyword">let</span> num<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> d <span class="token keyword">as</span> <span class="token builtin">number</span><span class="token punctuation">;</span> <span class="token comment">// 使用 as 进行类型转换</span><span class="token comment">// 强制类型转换</span><span class="token keyword">let</span> obj<span class="token operator">:</span> <span class="token builtin">any</span> <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span><span class="token keyword">let</span> str<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> obj <span class="token keyword">as</span> <span class="token builtin">string</span><span class="token punctuation">;</span> <span class="token comment">// 强制转换</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 Java 中，必须显式声明变量的类型。</p><ul><li><strong>显式声明</strong>：Java 不支持类型推断，必须显式声明变量的类型。</li><li><strong>类型转换</strong>：需要使用强制转换语法。</li><li><strong>强制类型转换</strong>：需要使用强制转换语法。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 类型推导</span><span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token comment">// 显式声明类型</span><span class="token comment">// 类型转换</span><span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token number">9.78</span><span class="token punctuation">;</span><span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> d<span class="token punctuation">;</span> <span class="token comment">// 显式强制转换，从 double 转为 int</span><span class="token comment">// 强制类型转换</span><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span><span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> obj<span class="token punctuation">;</span> <span class="token comment">// 强制转换</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 Kotlin 中，支持类型推断，可以省略类型声明，编译器会根据初始值推断类型。</p><ul><li><strong>隐式推断</strong>：Kotlin 支持类型推断，可以省略类型声明，编译器会根据初始值推断类型。</li><li><strong>类型转换</strong>：Kotlin 提供了转换方法，如 <code>toInt()</code>。</li><li><strong>强制类型转换</strong>：使用 <code>as</code> 关键字进行强制转换，支持安全转换（<code>as?</code>）。</li></ul><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token comment">// 类型推导</span><span class="token keyword">val</span> num <span class="token operator">=</span> <span class="token number">42</span> <span class="token comment">// 隐式推断为 Int </span><span class="token keyword">val</span> str <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"Hello"</span></span> <span class="token comment">// 隐式推断为 String</span><span class="token comment">// 类型转换</span><span class="token keyword">val</span> d <span class="token operator">=</span> <span class="token number">9.78</span> <span class="token keyword">val</span> num <span class="token operator">=</span> d<span class="token punctuation">.</span><span class="token function">toInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 使用转换方法</span><span class="token comment">// 强制类型转换</span><span class="token keyword">val</span> obj<span class="token operator">:</span> Any <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"Hello"</span></span><span class="token keyword">val</span> str<span class="token operator">:</span> String <span class="token operator">=</span> obj <span class="token keyword">as</span> String <span class="token comment">// 强制转换</span><span class="token keyword">val</span> safeStr<span class="token operator">:</span> String<span class="token operator">?</span> <span class="token operator">=</span> obj <span class="token keyword">as</span><span class="token operator">?</span> String <span class="token comment">// 安全转换，若失败返回 null</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-4-类型判断"><a href="#1-4-类型判断" class="headerlink" title="1.4 类型判断"></a>1.4 类型判断</h4><ul><li><strong>Java</strong>：使用 <code>instanceof</code> 进行类型判断，需手动强制转换。</li><li><strong>Kotlin</strong>：使用 <code>is</code> 进行类型判断，支持自动和安全转换，简化了语法。</li><li><strong>TypeScript</strong>：使用 <code>typeof</code> 和 <code>instanceof</code>，适用于基本数据类型和对象类型。</li></ul><p>在 TypeScript 中，使用 <code>typeof</code> 和 <code>instanceof</code> 进行类型判断。</p><ul><li>**使用 <code>typeof</code>**：主要用于基本数据类型。</li><li>**使用 <code>instanceof</code>**：用于对象和类的类型判断。</li></ul><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">typeCheck</span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> value <span class="token operator">===</span> <span class="token string">"string"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"是一个字符串: "</span> <span class="token operator">+</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token keyword">instanceof</span> <span class="token class-name"><span class="token builtin">Array</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"是一个数组"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"不是一个字符串或数组"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">typeCheck</span><span class="token punctuation">(</span><span class="token string">"Hello, World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出: 是一个字符串: Hello, World!</span><span class="token function">typeCheck</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出: 是一个数组</span><span class="token function">typeCheck</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出: 不是一个字符串或数组</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 Java 中，使用 <code>instanceof</code> 关键字进行类型判断。</p><p>在 Java 中，基本数据类型没有对象的特性，因此通常通过 <code>instanceof</code> 来判断对象类型。如果使用包装类（如 <code>Integer</code>、<code>Double</code> 等），可以使用 <code>instanceof</code> 进行判断。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token string">"Hello, World!"</span><span class="token punctuation">;</span>              <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> obj<span class="token punctuation">;</span> <span class="token comment">// 强制转换</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"是一个字符串: "</span> <span class="token operator">+</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"不是一个字符串"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 基本类型判断</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token comment">// 基本类型的包装类</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">Integer</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"是一个 Integer 类型"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">Double</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"是一个 Double 类型"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"不是 Integer 或 Double 类型"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 Kotlin 中，使用 <code>is</code> 关键字进行类型判断，使用 <code>as</code> 进行强制转换，支持安全转换。</p><p>在 Kotlin 中，基本数据类型和对象类型更紧密结合，使用 <code>is</code> 关键字进行判断。Kotlin 允许直接判断基本类型。</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">val</span> obj<span class="token operator">:</span> Any <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"Hello, World!"</span></span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token keyword">is</span> String<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 不需要强制转换</span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"是一个字符串: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">obj</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"不是一个字符串"</span></span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>      <span class="token comment">// 使用安全转换</span>    <span class="token keyword">val</span> str<span class="token operator">:</span> String<span class="token operator">?</span> <span class="token operator">=</span> obj <span class="token keyword">as</span><span class="token operator">?</span> String <span class="token comment">// 如果不是 String，则返回 null</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"安全转换: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">str</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// 基本类型判断</span><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">val</span> obj<span class="token operator">:</span> Any <span class="token operator">=</span> <span class="token number">42</span> <span class="token comment">// 基本类型</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token keyword">is</span> Int<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"是一个 Int 类型"</span></span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token keyword">is</span> Double<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"是一个 Double 类型"</span></span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"不是 Int 或 Double 类型"</span></span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><table><thead><tr><th>运算符</th><th>异同点</th></tr></thead><tbody><tr><td><strong>算术运算符</strong>（如 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>）</td><td>完全一致</td></tr><tr><td><strong>比较运算符</strong>（如 <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>）</td><td>除 &#x3D;&#x3D; 外基本一致</td></tr><tr><td><strong>逻辑运算符</strong>（如 <code>&amp;&amp;</code>, &#96;</td><td></td></tr><tr><td><strong>位运算符</strong>（如 <code>&amp;</code>, &#96;</td><td><code>, </code>^<code>, </code>&lt;&lt;<code>, </code>&gt;&gt;&#96;）</td></tr></tbody></table><h4 id="相等运算符异同点"><a href="#相等运算符异同点" class="headerlink" title="相等运算符异同点"></a>相等运算符异同点</h4><p><strong>TypeScript</strong> 的 <code>==</code> 进行类型转换，<code>===</code> 不进行转换。</p><p><strong>Kotlin</strong> 的 <code>==</code> 进行内容比较，<code>===</code> 比较引用。</p><p><strong>Java</strong> 的 <code>==</code> 在基本类型上比较值，在对象上比较引用，没有严格相等运算符。</p><p>在 TypeScript 中，<code>==</code>（相等运算符）进行类型转换后比较值。</p><ul><li>例如，<code>0 == &#39;0&#39;</code> 为 <code>true</code>，因为字符串 <code>&#39;0&#39;</code> 被转换为数字。</li></ul><p><code>===</code>（严格相等运算符）不进行类型转换，只有在类型和值都相等时才返回 <code>true</code>。</p><ul><li>例如，<code>0 === &#39;0&#39;</code> 为 <code>false</code>，因为类型不同。</li></ul><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">let</span> a<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">let</span> b<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">'0'</span><span class="token punctuation">;</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// true, 因为进行类型转换</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a <span class="token operator">===</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false, 因为类型不同</span><span class="token keyword">let</span> obj1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">'Alice'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">let</span> obj2 <span class="token operator">=</span> <span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">'Alice'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">let</span> obj3 <span class="token operator">=</span> obj1<span class="token punctuation">;</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1 <span class="token operator">==</span> obj2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// false, 不同的引用</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1 <span class="token operator">===</span> obj2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false, 不同的引用</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1 <span class="token operator">===</span> obj3<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true, 同一引用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 Java 中，<code>==</code>用于基本数据类型时比较值（如 <code>int</code>, <code>char</code>），用于对象时比较引用。</p><ul><li>例如，<code>int a = 5; int b = 5; a == b</code> 为 <code>true</code>，但对于对象，<code>String a = &quot;Hello&quot;; String b = new String(&quot;Hello&quot;); a == b</code> 为 <code>false</code>，因为它们是不同的对象。</li></ul><p>**没有 <code>===</code>**：Java 只有一种相等运算符 <code>==</code>，因此无法直接进行严格相等检查。对象的内容比较通常使用 <code>.equals()</code> 方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> str1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> str2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> str3 <span class="token operator">=</span> str1<span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x <span class="token operator">==</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true, 基本类型比较值</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1 <span class="token operator">==</span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false, 不同的引用</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true, 内容相等</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1 <span class="token operator">==</span> str3<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true, 同一引用</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 Kotlin 中，<code>==</code>表示结构相等（相当于 Java 中的 <code>equals()</code> 方法）。</p><ul><li>例如，<code>val a = &quot;Hello&quot;; val b = &quot;Hello&quot;; a == b</code> 为 <code>true</code>，因为它们的内容相等。</li></ul><p><code>===</code>表示引用相等，检查两个引用是否指向同一个对象。</p><ul><li>例如，<code>val a = &quot;Hello&quot;; val b = a; a === b</code> 为 <code>true</code>，但 <code>val c = &quot;Hello&quot;; a === c</code> 可能为 <code>false</code>（如果 <code>c</code> 是不同的对象）。</li></ul><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">val</span> a <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"Hello"</span></span>    <span class="token keyword">val</span> b <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"Hello"</span></span>    <span class="token keyword">val</span> c <span class="token operator">=</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"Hello"</span></span><span class="token punctuation">)</span>    <span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span>  <span class="token comment">// true, 结构相等</span>    <span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">===</span> b<span class="token punctuation">)</span> <span class="token comment">// true, 引用相等（在字符串常量池中）</span>    <span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> c<span class="token punctuation">)</span>  <span class="token comment">// true, 结构相等</span>    <span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">===</span> c<span class="token punctuation">)</span> <span class="token comment">// false, 不同的引用</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><h4 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a><code>if</code> 语句</h4><p><strong>描述</strong>: 条件判断<br><strong>异同点</strong>: 完全一致<br><strong>代码示例</strong>: </p><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">if (condition) &#123;     &#x2F;&#x2F; 执行代码 &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a><code>for</code> 循环</h4><p><strong>描述</strong>: 循环<br><strong>异同点</strong>: 基本 <code>for</code> 循环，除 Kotlin 外，Java 和 TypeScript 一致。区别主要在于增强型 <code>for</code> 循环上：  </p><ul><li><strong>TypeScript</strong>: 使用 <code>for...of</code> 遍历可迭代对象。  </li><li><strong>Java</strong>: 使用增强型 <code>for</code> 循环（<code>for (type var : collection)</code>）遍历数组和集合。  </li><li><strong>Kotlin</strong>: 使用 <code>for (item in collection)</code> 语法遍历数组和集合。<br><strong>代码示例</strong>:</li></ul><ul><li>一般语法</li></ul><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">for (let i &#x3D; 0; i &lt; 5; i++) &#123;    &#x2F;&#x2F; 执行代码 &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>TypeScript</li></ul><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">&#x2F;&#x2F; for of 循环const array &#x3D; [1, 2, 3, 4, 5];for (const value of array) &#123;    console.log(value); &#x2F;&#x2F; 输出 1, 2, 3, 4, 5&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Java</li></ul><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F; for each 循环int[] array &#x3D; &#123;1, 2, 3, 4, 5&#125;;for (int value : array) &#123;    System.out.println(value); &#x2F;&#x2F; 输出 1, 2, 3, 4, 5&#125;&#x2F;&#x2F; 对于集合List&lt;Integer&gt; list &#x3D; Arrays.asList(1, 2, 3, 4, 5);for (int value : list) &#123;    System.out.println(value); &#x2F;&#x2F; 输出 1, 2, 3, 4, 5&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Kotlin</li></ul><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">&#x2F;&#x2F; 带索引遍历for ((index, item) in arrayListOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).withIndex()) &#123;    println(&quot;$index - $item&quot;)&#x2F;&#x2F; 0-a  1-b 2-c &#125;&#x2F;&#x2F; 包左包右for (i in 1..10) &#123;    println(i) &#x2F;&#x2F; 12345678910&#125;&#x2F;&#x2F; 包左不包右for (i in 1 until 10) &#123;    println(i) &#x2F;&#x2F; 123456789&#125;&#x2F;&#x2F; 降序-包左包右for (i in 10 downTo 1) &#123;    println(i) &#x2F;&#x2F; 10987654321&#125;&#x2F;&#x2F; 跳步-包左包右for (i in 1..10 step 2) &#123;    println(i) &#x2F;&#x2F; 13579&#125;&#x2F;&#x2F; 包左不包右repeat(10) &#123;    print(it) &#x2F;&#x2F; 0123456789&#125;&#x2F;&#x2F; for in 循环val array &#x3D; arrayOf(1, 2, 3, 4, 5)for (value in array) &#123;    println(value) &#x2F;&#x2F; 输出 1, 2, 3, 4, 5&#125;&#x2F;&#x2F; 对于集合val list &#x3D; listOf(1, 2, 3, 4, 5)for (value in list) &#123;    println(value) &#x2F;&#x2F; 输出 1, 2, 3, 4, 5&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a><code>while</code> 循环</h4><p><strong>描述</strong>: 循环<br><strong>异同点</strong>: 完全一致<br><strong>代码示例</strong>: </p><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">while (condition) &#123;    &#x2F;&#x2F; 执行代码 &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="do-while-循环"><a href="#do-while-循环" class="headerlink" title="do...while 循环"></a><code>do...while</code> 循环</h4><p><strong>描述</strong>: 循环<br><strong>异同点</strong>: 完全一致<br><strong>代码示例</strong>: </p><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">do &#123;     &#x2F;&#x2F; 执行代码 &#125; while (condition);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a><code>switch</code> 语句</h4><p><strong>描述</strong>: 多情况判断<br><strong>异同点</strong>: 除开 Kotlin 以外，长的一样。在 Kotlin 中，这被称之为 <code>when</code> 语句。<br><strong>代码示例</strong>:</p><ul><li>一般性语法</li></ul><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">switch (value) &#123;     case value1:         &#x2F;&#x2F; 执行代码         break;     case value2:         &#x2F;&#x2F; 执行代码         break;     default:         &#x2F;&#x2F; 执行代码 &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Kotlin 语法</li></ul><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">val day &#x3D; 2when (day) &#123;    1 -&gt; &#123;        println(&quot;Monday&quot;)        &#x2F;&#x2F; 其他操作        println(&quot;It&#39;s the start of the week.&quot;)    &#125;    2 -&gt; &#123;        println(&quot;Tuesday&quot;)        &#x2F;&#x2F; 其他操作        println(&quot;Keep going!&quot;)    &#125;    3 -&gt; &#123;        println(&quot;Wednesday&quot;)        &#x2F;&#x2F; 其他操作        println(&quot;Halfway through the week!&quot;)    &#125;    else -&gt; &#123;        println(&quot;Other day&quot;)    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="try-catch-语句"><a href="#try-catch-语句" class="headerlink" title="try...catch 语句"></a><code>try...catch</code> 语句</h4><p><strong>描述</strong>: 异常处理<br><strong>异同点</strong>: 除了 Java 在错误类型声明有写法上的差异，其余完全一致<br><strong>代码示例</strong>: </p><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">try &#123;     &#x2F;&#x2F; 执行可能抛出异常的代码 &#125; catch (error) &#123;    &#x2F;&#x2F; 处理异常 &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="4-1-函数声明与调用"><a href="#4-1-函数声明与调用" class="headerlink" title="4.1 函数声明与调用"></a>4.1 函数声明与调用</h4><ul><li><strong>Java</strong>:</li></ul><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public int add(int a, int b) &#123;    return a + b;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><strong>TypeScript</strong>:</li></ul><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">function add(a: number, b: number): number &#123;    return a + b;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><strong>Kotlin</strong>:</li></ul><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">fun add(a: Int, b: Int): Int &#123;    return a + b&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="4-2-可选参数和默认参数"><a href="#4-2-可选参数和默认参数" class="headerlink" title="4.2 可选参数和默认参数"></a>4.2 可选参数和默认参数</h4><ul><li><strong>Java</strong>: Java 不支持可选参数，可以通过方法重载实现类似效果。</li></ul><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public int add(int a, int b) &#123;    return a + b;&#125;public int add(int a) &#123;    return a + 10; &#x2F;&#x2F; 默认值&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>TypeScript</strong>: 支持可选参数和默认参数。</li></ul><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">function add(a: number, b: number &#x3D; 10): number &#123;    return a + b;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><strong>Kotlin</strong>: 也支持默认参数。</li></ul><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">fun add(a: Int, b: Int &#x3D; 10): Int &#123;    return a + b&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="4-3-rest-参数"><a href="#4-3-rest-参数" class="headerlink" title="4.3 rest 参数"></a>4.3 rest 参数</h4><ul><li><strong>Java</strong>: 使用数组来实现。</li></ul><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public int sum(int... numbers) &#123;    int total &#x3D; 0;    for (int number : numbers) &#123;        total +&#x3D; number;    &#125;    return total;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>TypeScript</strong>: 使用 <code>...</code> 表示 rest 参数。</li></ul><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">function sum(...numbers: number[]): number &#123;    return numbers.reduce((total, n) &#x3D;&gt; total + n, 0);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><strong>Kotlin</strong>: 使用 <code>vararg</code> 来实现。</li></ul><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">fun sum(vararg numbers: Int): Int &#123;    return numbers.sum()&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="4-4-函数类型"><a href="#4-4-函数类型" class="headerlink" title="4.4 函数类型"></a>4.4 函数类型</h4><ul><li><strong>Java</strong>: 使用接口或 lambda 表达式。</li></ul><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">interface IntOperation &#123;    int operate(int a, int b);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><strong>TypeScript</strong>: 可以直接定义函数类型。</li></ul><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">type IntOperation &#x3D; (a: number, b: number) &#x3D;&gt; number;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>Kotlin</strong>: 直接使用函数类型。不过它的返回值是单箭头 <code>-&gt;</code> 而非 ts 的等号箭头 <code>=&gt;</code></li></ul><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">fun operate(a: Int, b: Int, operation: (Int, Int) -&gt; Int): Int &#123;    return operation(a, b)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="4-5-匿名函数"><a href="#4-5-匿名函数" class="headerlink" title="4.5 匿名函数"></a>4.5 匿名函数</h4><ul><li><strong>Java</strong>: 使用 lambda 表达式。</li></ul><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">IntOperation add &#x3D; (a, b) -&gt; a + b;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>TypeScript</strong>: 使用箭头函数。</li></ul><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">const add: IntOperation &#x3D; (a, b) &#x3D;&gt; a + b;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>Kotlin</strong>: 使用 lambda 表达式。</li></ul><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">val add: (Int, Int) -&gt; Int &#x3D; &#123; a, b -&gt; a + b &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="4-6-函数重载"><a href="#4-6-函数重载" class="headerlink" title="4.6 函数重载"></a>4.6 函数重载</h4><p>三者均支持函数重载，语法上略有差别：</p><ul><li>Java</li></ul><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public int add(int a, int b) &#123; return a + b; &#125;public double add(double a, double b) &#123; return a + b; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>TypeScript</li></ul><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">function add(a: number, b: number): number;function add(a: string, b: string): string;function add(a: any, b: any): any &#123;    return a + b;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Kotlin</li></ul><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">fun add(a: Int, b: Int): Int &#123; return a + b &#125;fun add(a: Double, b: Double): Double &#123; return a + b &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Kotlin 可以通过 关键字 <code>&lt;span style=&quot;color: #FBBFBC&quot;&gt;@JvmOverloads</code> 修饰 <code>&lt;span style=&quot;color: #FBBFBC&quot;&gt;constructor</code>生成多个构造。</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">class MyFrameLayout @JvmOverloads constructor(    context: Context,    attrs: AttributeSet? &#x3D; null,    defStyleAttr: Int &#x3D; 0,    defStyleRes: Int &#x3D; 0) : FrameLayout(context, attrs, defStyleAttr, defStyleRes) &#123;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">@JvmOverloads fun f(a: String, b: Int&#x3D;0, c:String&#x3D;&quot;abc&quot;)&#123; &#125;&#x2F;&#x2F; 下面3个Java方法等价上面1个kotlin方法void f(String a)void f(String a, int b)void f(String a, int b, String c)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="OOP-相关（施工中-🚧）"><a href="#OOP-相关（施工中-🚧）" class="headerlink" title="OOP 相关（施工中 🚧）"></a>OOP 相关（施工中 🚧）</h3><h4 id="5-1-对象"><a href="#5-1-对象" class="headerlink" title="5.1 对象"></a>5.1 对象</h4><h5 id="字面量对象"><a href="#字面量对象" class="headerlink" title="字面量对象"></a>字面量对象</h5><p><strong>Java</strong>: 使用匿名内部类来创建字面量对象。</p><p><strong>TypeScript</strong>: 使用对象字面量语法，直接定义具有属性和方法的对象。</p><p><strong>Kotlin</strong>: 使用对象表达式，定义具有属性和方法的匿名对象。</p><ul><li><strong>Java</strong></li></ul><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class Example &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 使用匿名内部类        Object obj &#x3D; new Object() &#123;            @Override            public String toString() &#123;                return &quot;This is a literal object&quot;;            &#125;        &#125;;        System.out.println(obj);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>TypeScript</strong></li></ul><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">const obj &#x3D; &#123;    name: &quot;Example&quot;,    value: 42,    describe() &#123;        return &#96;$&#123;this.name&#125;: $&#123;this.value&#125;&#96;;    &#125;&#125;;console.log(obj.describe()); &#x2F;&#x2F; 输出: Example: 42<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>Kotlin</strong></li></ul><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">fun main() &#123;    val obj &#x3D; object &#123;        val name &#x3D; &quot;Example&quot;        val value &#x3D; 42        fun describe() &#x3D; &quot;$name: $value&quot;    &#125;    println(obj.describe()) &#x2F;&#x2F; 输出: Example: 42&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h5><p>Java 没有解构赋值，Kotlin 和 TypeScript 使用不同的方法实现解构赋值。</p><p><strong>数据类</strong>：数据类自动支持解构赋值。</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">data class Person(val name: String, val age: Int)fun main() &#123;    val person &#x3D; Person(&quot;Alice&quot;, 30)    val (name, age) &#x3D; person    println(&quot;Name: $name, Age: $age&quot;) &#x2F;&#x2F; 输出: Name: Alice, Age: 30&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Pair 和 Triple</strong>：这两个类也支持解构赋值。</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">fun main() &#123;    val pair &#x3D; Pair(&quot;Kotlin&quot;, 2023)    val (language, year) &#x3D; pair    println(&quot;Language: $language, Year: $year&quot;) &#x2F;&#x2F; 输出: Language: Kotlin, Year: 2023&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>自定义解构声明</strong>：可以在任意类中定义 <code>componentN()</code> 函数，使其支持解构赋值。</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">class Coordinates(val x: Int, val y: Int) &#123;    operator fun component1() &#x3D; x    operator fun component2() &#x3D; y&#125;fun main() &#123;    val point &#x3D; Coordinates(10, 20)    val (x, y) &#x3D; point    println(&quot;X: $x, Y: $y&quot;) &#x2F;&#x2F; 输出: X: 10, Y: 20&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-2-类"><a href="#5-2-类" class="headerlink" title="5.2 类"></a>5.2 类</h4><h5 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h5><table><thead><tr><th>语言</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>TypeScript</td><td>*<strong>public</strong>: 默认可见，所有类可见。</td><td></td></tr></tbody></table><ul><li><strong>private</strong>: 仅对同一类可见。</li><li><strong>protected</strong>: 对同一类和子类可见。</li><li><strong>readonly</strong>: 用于只读属性。<br>|</li></ul><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">class Example &#123;    public publicField: number;       &#x2F;&#x2F; 所有类可见    protected protectedField: number;   &#x2F;&#x2F; 对同一类和子类可见    private privateField: number;       &#x2F;&#x2F; 仅对本类可见&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> |<br>|Java |* <strong>public</strong>: 对所有类可见。</p><ul><li><strong>protected</strong>: 对同一包内的类和所有子类可见。</li><li><strong>private</strong>: 仅对同一类可见。</li><li><strong>默认（包私有，no modifier）</strong>: 仅对同一包内的类可见。</li></ul><p> |</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class Example &#123;    public int publicField;       &#x2F;&#x2F; 对所有类可见    protected int protectedField;  &#x2F;&#x2F; 对同一包和子类可见    private int privateField;      &#x2F;&#x2F; 仅对本类可见    int packagePrivateField;       &#x2F;&#x2F; 对同一包内可见&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> |<br>|Kotlin |* <strong>public</strong>: 默认可见，所有类可见。</p><ul><li><strong>private</strong>: 仅对同一文件或类可见。</li><li><strong>protected</strong>: 对同一类和子类可见。</li><li><strong>internal</strong>: 仅对同一模块内可见。<br>|</li></ul><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">class Example &#123;    var publicField: Int &#x3D; 0         &#x2F;&#x2F; 所有类可见    protected var protectedField: Int &#x3D; 0  &#x2F;&#x2F; 对同一类和子类可见    private var privateField: Int &#x3D; 0      &#x2F;&#x2F; 仅对本类可见    internal var internalField: Int &#x3D; 0     &#x2F;&#x2F; 对同一模块内可见&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> |</p><h4 id="5-3-接口"><a href="#5-3-接口" class="headerlink" title="5.3 接口"></a>5.3 接口</h4><table><thead><tr><th>语言</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>TypeScript</td><td><strong>TypeScript</strong> 使用 <code>interface</code> 关键字定义接口，支持属性和方法的定义，且可以通过 <code>extends</code> 进行继承。</td><td>*<strong>定义接口</strong></td></tr></tbody></table><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">interface Person &#123;    name: string;    age: number;&#125;const john: Person &#x3D; &#123;    name: &quot;John&quot;,    age: 30&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>接口继承</strong>：</li></ul><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">interface Employee extends Person &#123;    employeeId: number;&#125;const jane: Employee &#x3D; &#123;    name: &quot;Jane&quot;,    age: 28,    employeeId: 1234&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> |<br>|Java |<strong>Java</strong> 使用 <code>interface</code> 关键字定义接口，方法通过 getter 访问，且通过 <code>implements</code> 关键字实现接口。 |* <strong>定义接口</strong>：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public interface Person &#123;    String getName();    int getAge();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>接口继承</strong>：</li></ul><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public interface Employee extends Person &#123;    int getEmployeeId();&#125;public class Employee implements Person &#123;    private String name;    private int age;    public Employee(String name, int age) &#123;        this.name &#x3D; name;        this.age &#x3D; age;    &#125;    public String getName() &#123;        return name;    &#125;    public int getAge() &#123;        return age;    &#125;&#125;public class Manager implements Employee &#123;    private String name;    private int age;    private int employeeId;    public Manager(String name, int age, int employeeId) &#123;        this.name &#x3D; name;        this.age &#x3D; age;        this.employeeId &#x3D; employeeId;    &#125;    public String getName() &#123;        return name;    &#125;    public int getAge() &#123;        return age;    &#125;    public int getEmployeeId() &#123;        return employeeId;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> |<br>|Kotlin |<strong>Kotlin</strong> 使用 <code>interface</code> 关键字定义接口，属性使用 <code>val</code> 或 <code>var</code> 声明，且通过冒号 <code>:</code> 来实现接口。 |* <strong>定义接口</strong>：</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">interface Person &#123;    val name: String    val age: Int&#125;class Employee(override val name: String, override val age: Int) : Person<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>接口继承</strong>：</li></ul><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">interface Employee : Person &#123;    val employeeId: Int&#125;class Manager(override val name: String, override val age: Int, override val employeeId: Int) : Employee<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> |</p><h3 id="空安全"><a href="#空安全" class="headerlink" title="空安全"></a>空安全</h3><h4 id="6-1-非空断言"><a href="#6-1-非空断言" class="headerlink" title="6.1 非空断言"></a>6.1 非空断言</h4><table><thead><tr><th>语言</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>TypeScript</td><td>使用 <code>!</code> 运算符，可以告诉 TypeScript 编译器某个值不会是 <code>null</code> 或 <code>undefined</code>。</td><td></td></tr></tbody></table><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">const value: string | null &#x3D; getValue();const nonNullValue: string &#x3D; value!; &#x2F;&#x2F; 非空断言<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> |<br>|Java |<strong>Java 没有内置的非空断言运算符，但可以使用</strong> <code>**Optional**</code><strong>类来处理可能为 null 的值。</strong> |</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">Optional&lt;String&gt; optionalValue &#x3D; Optional.ofNullable(getValue());String nonNullValue &#x3D; optionalValue.orElse(&quot;default&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> |<br>|Kotlin |<strong>使用</strong> <code>**!!**</code><strong>运算符，可以将一个可空类型转换为非空类型，如果为 null 则抛出异常。</strong> |</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">val value: String? &#x3D; getValue()val nonNullValue: String &#x3D; value!! &#x2F;&#x2F; 如果 value 为 null，会抛出异常<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> |</p><h4 id="6-2-空值合并"><a href="#6-2-空值合并" class="headerlink" title="6.2 空值合并"></a>6.2 空值合并</h4><table><thead><tr><th>语言</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>TypeScript</td><td>使用 <code>??</code> 运算符，当左侧值为 <code>null</code> 或 <code>undefined</code> 时，返回右侧的值。</td><td></td></tr></tbody></table><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">const value &#x3D; null;const result &#x3D; value ?? &#39;default&#39;; &#x2F;&#x2F; result 为 &#39;default&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> |<br>|Java |<strong>Java 没有类似于</strong> <code>**??**</code><strong>的运算符，但可以通过</strong> <code>**Optional**</code><strong>的</strong> <code>**orElse**</code><strong>方法实现类似功能。</strong> |</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">String value &#x3D; null;String result &#x3D; Optional.ofNullable(value).orElse(&quot;default&quot;); &#x2F;&#x2F; result 为 &#39;default&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> |<br>|Kotlin |<strong>使用</strong> <code>**?:**</code><strong>运算符，当左侧值为 null 时，返回右侧的值。</strong> |</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">val value: String? &#x3D; nullval result &#x3D; value ?: &quot;default&quot; &#x2F;&#x2F; result 为 &#39;default&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> |</p><h4 id="6-3-可选链"><a href="#6-3-可选链" class="headerlink" title="6.3 可选链"></a>6.3 可选链</h4><p>可选链运算符只会在属性访问链中遇到第一个 <code>undefined</code> 或 <code>null</code> 值时停止，并返回 <code>undefined</code>。如果后续的属性访问链中还有其他的 <code>undefined</code> 或 <code>null</code> 值，不会继续进行访问。</p><p>Kotlin 没有 <code>undefined</code> 值。</p><p>Java 可以通过<strong>通过</strong> <code>**Optional**</code><strong>的 map 来达到类似于可选链的效果。</strong></p><table><thead><tr><th>语言</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>TypeScript</td><td>使用 <code>?.</code> 运算符，可以安全地访问对象的属性或调用方法，如果路径中的某个值为 <code>null</code> 或 <code>undefined</code>，则返回 <code>undefined</code></td><td></td></tr></tbody></table><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">const obj &#x3D; null;const result &#x3D; obj?.property; &#x2F;&#x2F; result 为 undefined<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> |<br>|Java |<strong>Java 没有可选链运算符，但可以通过</strong> <code>**Optional**</code><strong>来避免</strong> <code>**NullPointerException**</code><strong>。</strong> |</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class Address &#123;    String street;&#125;class User &#123;    Address address;&#125;User user &#x3D; null;String street &#x3D; Optional.ofNullable(user) &#x2F;&#x2F; 如果 user 为 null，链式调用会停止                        .map(User::getAddress)                        .map(Address::getStreet)                        .orElse(&quot;default street&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> |<br>|Kotlin |和 TypeScript 比较类似。使用 <code>?.</code> 运算符，可以安全地访问对象的属性或调用方法。 |</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">val obj: MyClass? &#x3D; nullval result &#x3D; obj?.property &#x2F;&#x2F; result 为 null<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> |</p><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><h4 id="7-1-一般性写法"><a href="#7-1-一般性写法" class="headerlink" title="7.1 一般性写法"></a>7.1 一般性写法</h4><p><strong>泛型写法</strong> 在三种语言中都比较相似，但语法略有不同。这里以函数举例：</p><ul><li><strong>TypeScript</strong></li></ul><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">function identity&lt;T&gt;(arg: T): T &#123;    return arg;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><strong>Kotlin</strong></li></ul><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">fun &lt;T&gt; identity(arg: T): T &#123;    return arg&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><strong>Java</strong></li></ul><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public &lt;T&gt; T identity(T arg) &#123;    return arg;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="7-2-泛型约束"><a href="#7-2-泛型约束" class="headerlink" title="7.2 泛型约束"></a>7.2 泛型约束</h4><p><strong>泛型上界约束</strong> 的语法在 TS 和 Java 中使用 <code>extends</code>，而 Kotlin 使用冒号和 <code>where</code>。</p><ul><li><strong>TypeScript：</strong>使用 <code>extends</code> 关键字来约束泛型类型：</li></ul><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">interface Lengthwise &#123;    length: number;&#125;function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123;    console.log(arg.length);    return arg;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>Kotlin：</strong>使用 <code>:</code> 、<code>where</code> 关键字来约束泛型类型：</li></ul><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">&#x2F;&#x2F; 使用 where 来约束泛型类型fun &lt;T&gt; loggingIdentity(arg: T) where T : CharSequence &#123;    println(arg.length)&#125;&#x2F;&#x2F; 使用 : 来约束泛型类型fun &lt;T : Number&gt; sum(a: T, b: T): Double &#123;    return a.toDouble() + b.toDouble()&#125;&#x2F;&#x2F; 使用 where 进行多重约束fun &lt;T&gt; process(value: T) where T : Comparable&lt;T&gt;, T : CharSequence &#123;    &#x2F;&#x2F; ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>Java</strong> 使用 <code>extends</code> 关键字来约束泛型类型：</li></ul><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public &lt;T extends CharSequence&gt; void loggingIdentity(T arg) &#123;    System.out.println(arg.length());&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>泛型下界约束</strong> 的语法在 Java 中使用 <code>super</code>，而 Kotlin 使用冒号和 <code>in</code>。<strong>TypeScript 不支持下界约束。</strong></p><ul><li><strong>Kotlin</strong> 使用 <code>in</code> 关键字定义下界约束，限制泛型类型必须是某个类或接口的超类。</li></ul><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">fun addNumbers(list: MutableList&lt;in Int&gt;) &#123;    list.add(1) &#x2F;&#x2F; 可以添加 Int 类型&#125;fun main() &#123;    val numbers: MutableList&lt;Number&gt; &#x3D; mutableListOf()    addNumbers(numbers)    println(numbers)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>Java</strong> 使用 <code>super</code> 关键字来定义下界约束，限制泛型类型必须是某个类或接口的超类。</li></ul><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">import java.util.ArrayList;import java.util.List;class NumberList &#123;    public static void addNumbers(List&lt;? super Integer&gt; list) &#123;        list.add(1); &#x2F;&#x2F; 可以添加 Integer 类型    &#125;    public static void main(String[] args) &#123;        List&lt;Number&gt; numbers &#x3D; new ArrayList&lt;&gt;();        addNumbers(numbers);        System.out.println(numbers);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="7-3-泛型默认值"><a href="#7-3-泛型默认值" class="headerlink" title="7.3 泛型默认值"></a>7.3 泛型默认值</h4><p><strong>泛型默认值</strong> 仅在 TypeScript 中支持，Kotlin 和 Java 不支持这一特性。</p><ul><li><strong>TypeScript：</strong>TypeScript 支持泛型的默认值：</li></ul><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">function identity&lt;T &#x3D; string&gt;(arg: T): T &#123;    return arg;&#125;const result &#x3D; identity(123); &#x2F;&#x2F; result 的类型为 number<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="7-4-Kotlin-泛型进阶"><a href="#7-4-Kotlin-泛型进阶" class="headerlink" title="7.4 Kotlin 泛型进阶"></a>7.4 Kotlin 泛型进阶</h4><h5 id="7-4-1-reified"><a href="#7-4-1-reified" class="headerlink" title="7.4.1 reified"></a>7.4.1 <code>reified</code></h5><p>在 Kotlin 中，<code>reified</code> 是一个关键字。使用 <code>reified</code> 关键字，可以在 inline 函数中保留类型信息，从而在运行时使用该类型。</p><p>通过 <code>reified</code> 获取参数类型：</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">inline fun &lt;reified T&gt; printType(value: T) &#123;    println(&quot;The type of value is: $&#123;T::class.simpleName&#125;&quot;) &#x2F;&#x2F; 使用 reified 获取类型信息&#125;fun main() &#123;    printType(42)          &#x2F;&#x2F; 输出: The type of value is: Int    printType(&quot;Hello&quot;)     &#x2F;&#x2F; 输出: The type of value is: String    printType(3.14)        &#x2F;&#x2F; 输出: The type of value is: Double&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个示例中，<code>printType</code> 函数是一个 inline 函数，使用了 <code>reified</code> 关键字。通过 <code>T::class.simpleName</code> 可以获取泛型参数的类型信息。</p><p>用于类型检查&#x2F;过滤：</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">inline fun &lt;reified T&gt; List&lt;*&gt;.filterIsInstance(): List&lt;T&gt; &#123;    return this.filterIsInstance&lt;T&gt;() &#x2F;&#x2F; 使用 reified 进行类型过滤&#125;fun main() &#123;    val mixedList: List&lt;Any&gt; &#x3D; listOf(1, &quot;two&quot;, 3.0, 4)    val intList: List&lt;Int&gt; &#x3D; mixedList.filterIsInstance&lt;Int&gt;()      println(intList) &#x2F;&#x2F; 输出: [1, 4]&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在此示例中，<code>filterIsInstance</code> 函数使用 <code>reified</code> 关键字来过滤给定列表中的元素，返回指定类型的子集。</p><p>使用类型安全的反射：</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">inline fun &lt;reified T&gt; createInstance(): T &#123;    return T::class.constructors.first().call() &#x2F;&#x2F; 使用 reified 创建实例&#125;data class Person(val name: String &#x3D; &quot;John Doe&quot;)fun main() &#123;    val person: Person &#x3D; createInstance() &#x2F;&#x2F; 创建 Person 实例    println(person) &#x2F;&#x2F; 输出: Person(name&#x3D;John Doe)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个示例中，<code>createInstance</code> 函数通过 <code>reified</code> 关键字和反射机制创建了指定类型的实例。</p><h5 id="7-4-2-out、in、Invariant"><a href="#7-4-2-out、in、Invariant" class="headerlink" title="7.4.2 out、in、Invariant"></a>7.4.2 <strong>out、in、Invariant</strong></h5><p>在 Kotlin 中，<code>out</code>、<code>in</code> 和不带任何修饰符（也称为 <strong>Invariant</strong>）是用于定义泛型类型参数的三种方式。它们分别表示不同的协变和逆变的概念，影响泛型类型的可用性和类型安全性。</p><ol><li>Out（协变）</li></ol><p>使用 <code>out</code> 修饰符的泛型类型参数表示协变。协变允许我们可以将泛型类型作为输出类型（返回值）。这意味着可以将子类型的对象赋值给父类型的变量。</p><p><strong>示例</strong>：</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">interface Producer&lt;out T&gt; &#123;    fun produce(): T&#125;class StringProducer : Producer&lt;String&gt; &#123;    override fun produce(): String &#123;        return &quot;Hello, Kotlin!&quot;    &#125;&#125;fun main() &#123;    val producer: Producer&lt;Any&gt; &#x3D; StringProducer() &#x2F;&#x2F; 可以将 Producer&lt;String&gt; 赋值给 Producer&lt;Any&gt;    println(producer.produce()) &#x2F;&#x2F; 输出: Hello, Kotlin!&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，<code>Producer</code> 接口的类型参数 <code>T</code> 被标记为 <code>out</code>，这允许我们将 <code>Producer&lt;String&gt;</code> 赋值给 <code>Producer&lt;Any&gt;</code>。</p><ol><li>In（逆变）</li></ol><p>使用 <code>in</code> 修饰符的泛型类型参数表示逆变。逆变允许我们可以将泛型类型作为输入类型（参数）。这意味着可以将父类型的对象赋值给子类型的变量。</p><p><strong>示例</strong>：</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">interface Consumer&lt;in T&gt; &#123;    fun consume(item: T)&#125;class StringConsumer : Consumer&lt;String&gt; &#123;    override fun consume(item: String) &#123;        println(&quot;Consuming: $item&quot;)    &#125;&#125;fun main() &#123;    val consumer: Consumer&lt;Any&gt; &#x3D; StringConsumer() &#x2F;&#x2F; 可以将 Consumer&lt;String&gt; 赋值给 Consumer&lt;Any&gt;    consumer.consume(&quot;Hello, Kotlin!&quot;) &#x2F;&#x2F; 输出: Consuming: Hello, Kotlin!&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，<code>Consumer</code> 接口的类型参数 <code>T</code> 被标记为 <code>in</code>，这允许我们将 <code>Consumer&lt;String&gt;</code> 赋值给 <code>Consumer&lt;Any&gt;</code>。</p><ol><li>Invariant（不变）</li></ol><p>不带任何修饰符的泛型类型参数表示不变。这意味着泛型类型参数既不能被视为协变也不能被视为逆变。我们只能使用完全相同的类型。</p><p><strong>示例</strong>：</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">class Box&lt;T&gt;(val value: T)fun main() &#123;    val stringBox: Box&lt;String&gt; &#x3D; Box(&quot;Hello&quot;)    &#x2F;&#x2F; val anyBox: Box&lt;Any&gt; &#x3D; stringBox &#x2F;&#x2F; 这是不允许的，会导致编译错误&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，<code>Box&lt;T&gt;</code> 是不变的。不能将 <code>Box&lt;String&gt;</code> 赋值给 <code>Box&lt;Any&gt;</code>，因为它们是不同的类型。</p><h3 id="模块化语法"><a href="#模块化语法" class="headerlink" title="模块化语法"></a>模块化语法</h3><table><thead><tr><th>语言</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>TypeScript</td><td><strong>TypeScript</strong> 使用 <code>import</code> 和 <code>export</code> 关键字来显式导入和导出模块。</td><td></td></tr></tbody></table><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">&#x2F;&#x2F; 导入import &#123; ModuleName &#125; from &#39;.&#x2F;module&#39;;&#x2F;&#x2F; 全包导入import * as Module from &#39;.&#x2F;module&#39;;&#x2F;&#x2F; 导出export const variableName &#x3D; &#39;value&#39;; export function functionName() &#123; &#125;&#x2F;&#x2F; 默认导出export default class ClassName &#123; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> |<br>|Java |<strong>Kotlin</strong> 和 <strong>Java</strong> 使用 <code>import</code> 语句导入，但导出则依赖于类和函数的可见性（如 <code>public</code> 修饰符）。Java 中的类和接口默认是包私有的。要导出它们，可以使用 <code>public</code> 修饰符。 |</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F; 导入import com.example.ModuleName;&#x2F;&#x2F; 全包导入import com.example.*;&#x2F;&#x2F; 导出public class ClassName &#123; &#125; public static void functionName() &#123; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> |<br>|Kotlin |<strong>Kotlin</strong> 和 <strong>Java</strong> 使用 <code>import</code> 语句导入，但导出则依赖于类和函数的可见性（如 <code>public</code> 修饰符）。Kotlin 没有显式的导出语法，因为所有公共类和函数默认都是可导出的。可以使用 <code>public</code> 修饰符来明确表示。Kotlin 导出导入的语法和 Java 是完全一致的。导出心智也是完全一致的。 |</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">&#x2F;&#x2F; 导入import com.example.ModuleName&#x2F;&#x2F; 全包导入import com.example.*&#x2F;&#x2F; 导出public val variableName &#x3D; &quot;value&quot;public fun functionName() &#123; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> |</p><h2 id="Kotlin-进阶语法"><a href="#Kotlin-进阶语法" class="headerlink" title="Kotlin 进阶语法"></a>Kotlin 进阶语法</h2><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><h4 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h4><p>TypeScript 和 Kotlin 都支持高阶函数，因此也都支持回调函数。但回调地狱的问题导致两者均已不常使用这种方案。</p><h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><p>TypeScript 和 Kotlin 相同点：</p><ol><li><strong>创建 Promise</strong>：<ul><li>两者都可以使用类似的方式来创建 Promise 对象，通常通过提供一个执行器函数（executor function），该函数接收 <code>resolve</code> 和 <code>reject</code> 回调。</li></ul></li><li><strong>链式调用</strong>：<ul><li>都支持使用 <code>.then()</code> 和 <code>.catch()</code> 方法进行链式调用，以处理成功和失败的回调。</li></ul></li></ol><p>TypeScript 和 Kotlin 不同点：</p><ol><li><strong>Promise 的创建</strong>：</li></ol><ul><li><strong>Kotlin</strong> 使用 <code>kotlin.js.Promise</code>：</li></ul><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">val promise &#x3D; Promise&lt;String&gt; &#123; resolve, reject -&gt;    &#x2F;&#x2F; 模拟异步操作    window.setTimeout(&#123;        resolve(&quot;Hello from Kotlin!&quot;)    &#125;, 1000)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>TypeScript</strong> 使用原生 JavaScript 的 <code>Promise</code>：</li></ul><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">const promise &#x3D; new Promise&lt;string&gt;((resolve, reject) &#x3D;&gt; &#123;    &#x2F;&#x2F; 模拟异步操作    setTimeout(() &#x3D;&gt; &#123;        resolve(&quot;Hello from TypeScript!&quot;);    &#125;, 1000);&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><strong>使用 Promise</strong>：</li></ol><ul><li><strong>Kotlin</strong>：</li></ul><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">promise.then &#123; result -&gt;    console.log(result) &#x2F;&#x2F; 输出: Hello from Kotlin!&#125;.catch &#123; error -&gt;    console.error(error)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>TypeScript</strong>：</li></ul><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">promise    .then(result &#x3D;&gt; &#123;        console.log(result); &#x2F;&#x2F; 输出: Hello from TypeScript!    &#125;)    .catch(error &#x3D;&gt; &#123;        console.error(error);    &#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><strong>类型系统</strong>：</li></ol><ul><li><strong>Kotlin</strong>：类型是显式的，使用 <code>Promise&lt;Type&gt;</code> 的形式定义返回值类型。</li><li><strong>TypeScript</strong>：类型也可以显式定义，但可以利用类型推断来简化代码。</li></ul><ol><li><strong>错误处理</strong>：</li></ol><ul><li><strong>Kotlin</strong> 的 Promise 使用 <code>.catch()</code> 方法与 TypeScript 类似，但在 Kotlin 中通常习惯使用 <code>try-catch</code> 来捕获异步调用中的异常。</li><li><strong>TypeScript</strong> 通过 <code>.catch()</code> 方法处理错误，语法更为直接。</li></ul><ol><li><strong>运行环境</strong>：</li></ol><ul><li><strong>Kotlin</strong> 的 Promise 一般在 Kotlin&#x2F;JS 环境下使用，依赖于 Kotlin 的标准库。</li><li><strong>TypeScript</strong> 直接运行在 JavaScript 环境中，具有更广泛的兼容性。</li></ul><h4 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h4><blockquote><p><a href="https://developer.android.com/kotlin/coroutines?hl=zh-cn">https://developer.android.com/kotlin/coroutines?hl=zh-cn</a></p></blockquote><p>异步或非阻塞程序设计是开发领域的重要部分。 创建服务器端应用、 桌面应用或者移动端应用时，都很重要的一点是， 提供的体验不仅是从用户角度看着流畅， 而且还能在需要时伸缩（scalable，可扩充&#x2F;缩减规模）。</p><p>Kotlin 以一种灵活的方式解决了这个问题，在语言层面提供了<a href="https://en.wikipedia.org/wiki/Coroutine">协程</a>支持， 而将大部分功能委托给库。</p><p>我们使用安卓教程中的一个例子来认识在安卓中它是如何被使用的：</p><p>假设我们有这样的一个方法，该方法为<strong>耗时方法且为同步执行</strong>：</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">fun makeLoginRequest(jsonBody: String): Result&lt;LoginResponse&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果在主线程执行 <code>makeLoginRequest()</code>，则会导致刚刚提及的阻塞状态。这对我们来说是不可能接受的。以下为这一过程的安卓原生代码：</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">class LoginViewModel(    private val loginRepository: LoginRepository): ViewModel() &#123;    fun login(username: String, token: String) &#123;        &#x2F;&#x2F; Create a new coroutine to move the execution off the UI thread        viewModelScope.launch(Dispatchers.IO) &#123;            val jsonBody &#x3D; &quot;&#123; username: \&quot;$username\&quot;, token: \&quot;$token\&quot;&#125;&quot;            loginRepository.makeLoginRequest(jsonBody)        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以做以下改进：</p><ol><li>在 Kotlin 项目中引入依赖：</li></ol><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">dependencies &#123;    implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.9&quot;)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol><li>改写代码，创建一个新的协程，然后在 I&#x2F;O 线程上执行网络请求：</li></ol><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">class LoginViewModel(    private val loginRepository: LoginRepository): ViewModel() &#123;    fun login(username: String, token: String) &#123;        &#x2F;&#x2F; Create a new coroutine to move the execution off the UI thread        viewModelScope.launch(Dispatchers.IO) &#123;            val jsonBody &#x3D; &quot;&#123; username: \&quot;$username\&quot;, token: \&quot;$token\&quot;&#125;&quot;            loginRepository.makeLoginRequest(jsonBody)        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>viewModelScope</code> 是预定义的 <code>CoroutineScope</code>，包含在 <code>ViewModel</code> KTX 扩展中。请注意，所有协程都必须在一个作用域内运行。一个 <code>CoroutineScope</code> 管理一个或多个相关的协程。</li><li><code>launch</code> 是一个函数，用于创建协程并将其函数主体的执行分派给相应的调度程序。</li><li><code>Dispatchers.IO</code> 指示此协程应在为 I&#x2F;O 操作预留的线程上执行。</li></ul><p><code>login</code> 函数按以下方式执行：</p><ul><li>应用从主线程上的 <code>View</code> 层调用 <code>login</code> 函数。</li><li><code>launch</code> 会创建一个新的协程，并且网络请求在为 I&#x2F;O 操作预留的线程上独立发出。</li><li>在该协程运行时，<code>login</code> 函数会继续执行，并可能在网络请求完成前返回。请注意，为简单起见，我们暂时忽略掉网络响应。</li></ul><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">class LoginRepository(...) &#123;    ...    suspend fun makeLoginRequest(        jsonBody: String    ): Result&lt;LoginResponse&gt; &#123;        &#x2F;&#x2F; Move the execution of the coroutine to the I&#x2F;O dispatcher        return withContext(Dispatchers.IO) &#123;            &#x2F;&#x2F; Blocking network request code        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>withContext(Dispatchers.IO)</code> 将协程的执行操作移至一个 I&#x2F;O 线程，这样一来，我们的调用函数便是主线程安全的，并且支持根据需要更新界面。</p><p><code>makeLoginRequest</code> 还会用 <code>suspend</code> 关键字进行标记。Kotlin 利用此关键字强制从协程内调用函数。</p><p><strong>所有</strong> <code>**suspend**</code><strong>函数都必须在协程中执行，和 TypeScript 对比的时候，我认为它的意义和 await 比较类似，因为所有的 await 都必须在 async 函数下执行。suspend 方法必须在协程中执行也正是体现了这一理念。</strong></p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">class LoginViewModel(    private val loginRepository: LoginRepository): ViewModel() &#123;    fun login(username: String, token: String) &#123;        &#x2F;&#x2F; Create a new coroutine on the UI thread        viewModelScope.launch &#123;            val jsonBody &#x3D; &quot;&#123; username: \&quot;$username\&quot;, token: \&quot;$token\&quot;&#125;&quot;            &#x2F;&#x2F; Make the network call and suspend execution until it finishes            val result &#x3D; loginRepository.makeLoginRequest(jsonBody)            &#x2F;&#x2F; Display result of the network request to the user            when (result) &#123;                is Result.Success&lt;LoginResponse&gt; -&gt; &#x2F;&#x2F; Happy path                else -&gt; &#x2F;&#x2F; Show error in UI            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>login</code> 函数现在按以下方式执行：</p><ul><li>应用从主线程上的 <code>View</code> 层调用 <code>login()</code> 函数。</li><li><code>launch</code> 在主线程上创建新协程，然后协程开始执行。</li><li>在协程内，调用 <code>loginRepository.makeLoginRequest()</code> 现在会挂起协程的进一步执行操作，直至 <code>makeLoginRequest()</code> 中的 <code>withContext</code> 块结束运行。</li><li><code>withContext</code> 块结束运行后，<code>login()</code> 中的协程在主线程上恢复执行操作，并返回网络请求的结果。</li></ul><h3 id="延迟初始化-lateinit-lazy"><a href="#延迟初始化-lateinit-lazy" class="headerlink" title="延迟初始化 lateinit, lazy"></a>延迟初始化 lateinit, lazy</h3><p>lateinit, lazy 是 Kotlin 中两种实现延迟初始化的方式.</p><ul><li>lateinit 只能用于 var 标示的变量，by lazy 只能用于 val 标示的变量。</li><li>by lazy 只在第一次调用时进行初始化。</li></ul><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">class User &#123;    private lateinit var name: String    private val password: String by lazy &#123;        println(&quot;lazy init&quot;)        &quot;admin&quot;    &#125;    fun setName(name: String) &#123;        this.name &#x3D; name    &#125;    fun show() &#123;        println(&quot;name &#x3D; $name&quot;)        println(&quot;--------------------&quot;)        println(&quot;第一次访问 password &#x3D; $password&quot;)        println(&quot;第二次访问 password &#x3D; $password&quot;)    &#125;&#125;fun main() &#123;    val user &#x3D; User()    user.setName(&quot;tomcat&quot;)    user.show()&#125;&#x2F;&#x2F; 输出结果&#x2F;&#x2F; name &#x3D; tomcat&#x2F;&#x2F; --------------------&#x2F;&#x2F; lazy init&#x2F;&#x2F; 第一次访问 password &#x3D; admin&#x2F;&#x2F; 第二次访问 password &#x3D; admin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="委托-by"><a href="#委托-by" class="headerlink" title="委托 by"></a>委托 by</h3><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">&#x2F;** * 定义 Base 接口 * *&#x2F;interface Base &#123;    fun say()&#125;&#x2F;** * 定义 Base 接口的实现类，并实现 say() 方法 *&#x2F;class BaseImpl : Base &#123;    override fun say() &#123;        println(&quot;BaseImpl say()&quot;)    &#125;&#125;&#x2F;** * 定义 BaseProxy 类，并实现了 Base 接口， * 关键字 by 将接口 Base 中所有的方法都委托给 base 对象，这样 BaseProxy 类就不需要去实现接口 Base 中的方法了， * 简化了实现接口时要实现其中的方法。 *&#x2F;class BaseProxy(base: Base) : Base by basefun main() &#123;    val baseImpl &#x3D; BaseImpl()    &#x2F;&#x2F; 调用的是 BaseImpl 中的 say() 方法    BaseProxy(baseImpl).say()&#125;&#x2F;&#x2F; 输出结果&#x2F;&#x2F; BaseImpl say()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="扩展函数"><a href="#扩展函数" class="headerlink" title="扩展函数"></a>扩展函数</h3><p>扩展函数可以给类额外添加成员函数，通过「类名.方法名」方式实现。</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">&#x2F;** * 定义扩展函数，给 File 添加 readText() 方法 *&#x2F;fun File.readText(charset: Charset): String &#x3D; readBytes().toString(charset)&#x2F;&#x2F; 调用fun main() &#123;    val file &#x3D; File(&quot;&#x2F;Users&#x2F;xing&#x2F;Desktop&#x2F;Android.md&quot;)    print(file.readText(Charset.forName(&quot;utf-8&quot;)))&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h3><p>Lambda 表达式是一种匿名函数，可以在 Kotlin 中简洁地表示函数类型。它们用于实现高阶函数的功能，使得函数式编程变得更加方便。以下是对 Lambda 表达式的详细介绍以及一些示例。</p><p>Kotlin 中的 Lambda 表达式语法如下：</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">val lambdaName: Type &#x3D; &#123; parameters -&gt; body &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>lambdaName</code> 是 Lambda 表达式的名称（可选）。</li><li><code>Type</code> 是 Lambda 表达式的类型（可选）。</li><li><code>parameters</code> 是输入参数。</li><li><code>body</code> 是表达式或语句。</li></ul><p>示例：</p><ol><li><strong>简单的 Lambda 表达式</strong></li></ol><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">val square: (Int) -&gt; Int &#x3D; &#123; x -&gt; x * x &#125;println(square(5)) &#x2F;&#x2F; 输出: 25<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li><strong>无参数的 Lambda 表达式</strong></li></ol><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">val greet: () -&gt; String &#x3D; &#123; &quot;Hello, World!&quot; &#125;println(greet()) &#x2F;&#x2F; 输出: Hello, World!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li><strong>多参数的 Lambda 表达式</strong></li></ol><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">val add: (Int, Int) -&gt; Int &#x3D; &#123; a, b -&gt; a + b &#125;println(add(3, 4)) &#x2F;&#x2F; 输出: 7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li><strong>作为高阶函数的参数</strong></li></ol><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">fun operateOnNumbers(a: Int, b: Int, operation: (Int, Int) -&gt; Int): Int &#123;    return operation(a, b)&#125;val result &#x3D; operateOnNumbers(5, 3, add)println(result) &#x2F;&#x2F; 输出: 8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><strong>使用 Lambda 表达式作为参数</strong></li></ol><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">fun main() &#123;    val numbers &#x3D; listOf(1, 2, 3, 4, 5)    &#x2F;&#x2F; 使用 Lambda 表达式过滤列表    val evenNumbers &#x3D; numbers.filter &#123; it % 2 &#x3D;&#x3D; 0 &#125;    println(evenNumbers) &#x2F;&#x2F; 输出: [2, 4]&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><strong>多个 Lambda 表达式</strong></li></ol><p>在某些情况下，可以将多个 Lambda 表达式作为参数传递给高阶函数。</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">fun calculate(a: Int, b: Int, operation: (Int, Int) -&gt; Int): Int &#123;    return operation(a, b)&#125;fun main() &#123;    val sum &#x3D; calculate(10, 5) &#123; x, y -&gt; x + y &#125;    val difference &#x3D; calculate(10, 5) &#123; x, y -&gt; x - y &#125;      println(&quot;Sum: $sum&quot;) &#x2F;&#x2F; 输出: Sum: 15    println(&quot;Difference: $difference&quot;) &#x2F;&#x2F; 输出: Difference: 5&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>lambda 表达式具有如下特性：</p><ul><li><strong>类型推断</strong>：Kotlin 可以自动推断 Lambda 表达式的类型，因此可以省略参数类型。</li><li><strong>单个参数的简化</strong>：如果 Lambda 表达式只有一个参数，可以省略参数名称，使用 <code>it</code> 作为默认名称。</li></ul><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">val double &#x3D; &#123; it: Int -&gt; it * 2 &#125;println(double(4)) &#x2F;&#x2F; 输出: 8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><strong>多行 Lambda 表达式</strong>：如果 Lambda 表达式体包含多行代码，需要使用 <code>&#123;&#125;</code> 包围，并且最后一行是返回值。</li></ul><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>Java 和 Kotlin 的注解机制相似，都是通过定义注解类型并在代码中使用，而 TypeScript 则通过装饰器实现类似的功能。它们的共同点在于都可以用于提供元数据，而不同之处在于实现机制、语法和使用场景。</p><table><thead><tr><th>语言</th><th>作用</th><th>举例</th></tr></thead><tbody><tr><td>TypeScript</td><td>TypeScript 中没有直接的注解机制，但可以通过装饰器（decorators）实现类似的功能。装饰器通常用于类和类成员，并提供元数据。#### 作用</td><td></td></tr></tbody></table><ul><li><strong>元数据</strong>：为类、方法、属性提供元数据。</li><li><strong>框架支持</strong>：常用于 Angular 等框架进行依赖注入和元编程。</li></ul><p> |</p><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">function MyAnnotation(value: string) &#123;    return function (target: any) &#123;        target.annotationValue &#x3D; value;    &#125;;&#125;@MyAnnotation(&quot;Hello, TypeScript!&quot;)class MyClass &#123;    static getAnnotation() &#123;        return (this as any).annotationValue;    &#125;&#125;console.log(MyClass.getAnnotation()); &#x2F;&#x2F; 输出: Hello, TypeScript!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> |<br>|Java |<strong>元数据</strong>：为代码元素（如类、方法、字段等）提供额外信息。<strong>运行时反射</strong>：可以在运行时通过反射获取注解信息。<strong>编译时检查</strong>：一些注解可以用于编译器进行静态检查。<strong>框架支持</strong>：许多框架（如 Spring）使用注解来进行依赖注入和配置。 |</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotation &#123;    String value();&#125;@MyAnnotation(&quot;Hello, Java!&quot;)public class MyClass &#123;    public static void main(String[] args) &#123;        MyAnnotation annotation &#x3D; MyClass.class.getAnnotation(MyAnnotation.class);        System.out.println(annotation.value()); &#x2F;&#x2F; 输出: Hello, Java!    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> |<br>|Kotlin |<strong>元数据</strong>：与 Java 类似，Kotlin 的注解用于提供元数据。<strong>运行时反射</strong>：Kotlin 的注解也可以在运行时通过反射获取。<strong>简化语法</strong>：Kotlin 的注解语法更简洁。 |</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">@Target(AnnotationTarget.CLASS)@Retention(AnnotationRetention.RUNTIME)annotation class MyAnnotation(val value: String)@MyAnnotation(&quot;Hello, Kotlin!&quot;)class MyClass &#123;    companion object &#123;        @JvmStatic        fun main(args: Array&lt;String&gt;) &#123;            val annotation &#x3D; MyClass::class.annotations.find &#123; it is MyAnnotation &#125; as MyAnnotation            println(annotation.value) &#x2F;&#x2F; 输出: Hello, Kotlin!        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> |</p><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>反射是一种强大的编程特性，允许程序在运行时检查和操作其自身的结构和行为。通过反射，开发者可以动态地获取类的信息、方法、字段等，并在运行时创建和操作对象。</p><p>Java 和 Kotlin 都提供了比较完整的反射机制，允许开发者在运行时操作类型信息，而 TypeScript 的反射能力相对较弱，主要依赖 JavaScript 的特性和装饰器来实现。</p><table><thead><tr><th>语言</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>TypeScript</td><td><strong>没有内置反射 API</strong>：TypeScript 本身没有完整的反射机制，但可以通过装饰器和元数据实现某种程度的反射。<strong>运行时类型信息</strong>：可以使用 <code>typeof</code> 和 <code>instanceof</code> 来检查类型。<strong>与 JavaScript 结合</strong>：TypeScript 的反射能力依赖于 JavaScript 的反射机制。</td><td></td></tr></tbody></table><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">function MyDecorator(target: any, propertyKey: string) &#123;    console.log(&#96;Decorated method: $&#123;propertyKey&#125;&#96;);&#125;class ReflectionExample &#123;    @MyDecorator    sayHello() &#123;        console.log(&quot;Hello, TypeScript!&quot;);    &#125;&#125;const example &#x3D; new ReflectionExample();example.sayHello(); &#x2F;&#x2F; 输出: Decorated method: sayHello                    &#x2F;&#x2F; 输出: Hello, TypeScript!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> |<br>|Java |<strong>完整的反射机制</strong>：Java 提供了完整的反射 API，可以检查类、方法、字段等。<strong>运行时类型信息</strong>：允许在运行时获取类型信息和修改对象的行为。<strong>动态代理</strong>：可以创建动态代理以实现 AOP（面向切面编程）。 |</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">import java.lang.reflect.Method;public class ReflectionExample &#123;    public void sayHello() &#123;        System.out.println(&quot;Hello, Java!&quot;);    &#125;    public static void main(String[] args) throws Exception &#123;        ReflectionExample example &#x3D; new ReflectionExample();        Method method &#x3D; example.getClass().getMethod(&quot;sayHello&quot;);        method.invoke(example); &#x2F;&#x2F; 输出: Hello, Java!    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> |<br>|Kotlin |<strong>Kotlin 反射库</strong>：Kotlin 提供了反射支持，语法更简洁。<strong>类型安全</strong>：Kotlin 的反射 API 设计更加注重类型安全。<strong>扩展功能</strong>：可以通过扩展函数轻松操作 Kotlin 特性，如扩展属性和函数。 |</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">import kotlin.reflect.full.declaredFunctionsclass ReflectionExample &#123;    fun sayHello() &#123;        println(&quot;Hello, Kotlin!&quot;)    &#125;&#125;fun main() &#123;    val example &#x3D; ReflectionExample()    val kClass &#x3D; example::class    val function &#x3D; kClass.declaredFunctions.find &#123; it.name &#x3D;&#x3D; &quot;sayHello&quot; &#125;    function?.call(example) &#x2F;&#x2F; 输出: Hello, Kotlin!&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> |</p><h2 id="开发感受"><a href="#开发感受" class="headerlink" title="开发感受"></a>开发感受</h2><p>Kotlin 是高级的 Java。</p><p>Java 和 Kotlin 很适合写 OOP 代码。Kotlin 比 Java 适合写面向过程的代码。</p><p>顺便再提一嘴 ArkTS，这玩意就是把 TS 变成了适合写 OOP 的样子，因此 TS 不是 Kotlin 的竞品，ArkTS 才是。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Android" scheme="https://blog.pengdonglai.com/categories/Android/"/>
    
    <category term="基础语法" scheme="https://blog.pengdonglai.com/categories/Android/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    
    
    <category term="Android" scheme="https://blog.pengdonglai.com/tags/Android/"/>
    
    <category term="Kotlin" scheme="https://blog.pengdonglai.com/tags/Kotlin/"/>
    
    <category term="基础语法" scheme="https://blog.pengdonglai.com/tags/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>安卓（3）-实用篇：UI（1）</title>
    <link href="https://blog.pengdonglai.com/2025/01/29/android-3/"/>
    <id>https://blog.pengdonglai.com/2025/01/29/android-3/</id>
    <published>2025-01-29T11:52:36.000Z</published>
    <updated>2025-01-31T15:14:09.307Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>2024 年我开始逐渐介入客户端的研发，因此我开始学习客户端的知识。<br>从服务端开始，转到前端来其实完全代表着我的编码风格的转变。我喜欢 UI 编程那「所见即所得」的惊艳，也喜欢人机交互相关的内容。<br>做 C 端 App，前端技术实际上更多是一种强行「卷」过来的结果：首先，基础肯定是客户端技术 Android&#x2F;iOS，但是前端的作用越来越清晰。当然，目前的大环境下走入前端甚至客户端开发通常被认为是一种开倒车的举动。但这种东西谁又说得好呢——难道做算法调优几个版本实验指标波动，亦或者做服务端大半夜被机器人打电话就能让人兴奋了吗？<br>人总有无知的时候，在已知信息差的时候我们总有一天要为认知买单。所以就让我们为梦想，做出一次不那么受到束缚的选择吧。<br>这是安卓系列的第一期，它包含以下内容：<br><a href="/2025/01/29/android-1/">安卓（1）-语法基础：Kotlin ＆ Java ＆ TS 对比</a><br><a href="/2025/01/29/android-2/">安卓（2）-语法基础：Kotlin 常用库（1）</a><br><a href="/2025/01/29/android-3/">安卓（3）-实用篇：UI（1）</a><br>我使用了 AI 来辅助我创作了一些重复性的工作，第一期内容会以相关知识的罗列为主，所以最好的阅读方式是阅读后进行查漏补缺。<br>希望大家可以喜欢这些教程！</p></blockquote><p>本文是安卓系列的第三个内容，主要介绍了 UI 范式相关的内容，用于构建用户页面。学习了这些内容后，我们就可以使用 Kotlin 和安卓 UI 范式直接上手开发我们的 App 了。</p><h2 id="UI-范式"><a href="#UI-范式" class="headerlink" title="UI 范式"></a>UI 范式</h2><h3 id="1-1-安卓各-UI-范式简介与区别"><a href="#1-1-安卓各-UI-范式简介与区别" class="headerlink" title="1.1 安卓各 UI 范式简介与区别"></a>1.1 安卓各 UI 范式简介与区别</h3><p>XML 主要是一种用于描述布局的标记语言，是传统 Android UI 开发中用于辅助<code>View</code>体系构建布局的工具。<code>View</code>是 Android UI 的核心基础组件体系，是构建传统 Android UI 的基本单元。而 Jetpack Compose 是一种独立的 UI 构建方案，它可以在一定程度上替代传统的<code>View</code>体系和 XML 布局方式。</p><p>XML 和<code>View</code>体系一起构成了传统的 Android UI 方案，用于构建从简单到复杂的各种 UI 界面。Jetpack Compose 则是一种新的、现代化的 UI 方案，提供了不同的 UI 构建逻辑和体验，用于满足日益复杂的 Android UI 开发需求，特别是在处理动态 UI 和状态管理方面有出色的表现。</p><h3 id="1-2-XML-View-传统范式"><a href="#1-2-XML-View-传统范式" class="headerlink" title="1.2 XML + View: 传统范式"></a>1.2 XML + View: 传统范式</h3><p>我们来创建一个简单的 Android 界面，界面中有一个垂直方向的线性布局（<code>LinearLayout</code>，属于<code>ViewGroup</code>），在线性布局中包含一个按钮（<code>Button</code>，属于<code>View</code>）和一个列表视图（<code>ListView</code>，属于<code>View</code>，且依赖于<code>Adapter</code>来提供数据展示，这里简化处理）。点击按钮可以在列表中添加一条默认的文本数据。</p><ol><li>创建 XML 布局文件（activity_main.xml）</li></ol><p>在<code>layout</code>目录下创建<code>activity_main.xml</code>文件：</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;    android:layout_width&#x3D;&quot;match_parent&quot;    android:layout_height&#x3D;&quot;match_parent&quot;    android:orientation&#x3D;&quot;vertical&quot;&gt;    &lt;Button        android:id&#x3D;&quot;@+id&#x2F;add_item_button&quot;        android:layout_width&#x3D;&quot;wrap_content&quot;        android:layout_height&#x3D;&quot;wrap_content&quot;        android:text&#x3D;&quot;添加列表项&quot; &#x2F;&gt;    &lt;ListView        android:id&#x3D;&quot;@+id&#x2F;list_view&quot;        android:layout_width&#x3D;&quot;match_parent&quot;        android:layout_height&#x3D;&quot;wrap_content&quot; &#x2F;&gt;&lt;&#x2F;LinearLayout&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们具体做了什么：</p><ul><li>整体定义了一个垂直方向（通过<code>android:orientation=&quot;vertical&quot;</code>指定）的线性布局（<code>LinearLayout</code>），它是一个<code>ViewGroup</code>，作为整个界面的根布局容器，用于管理其内部子视图的布局排列方式。</li><li>在线性布局内部，定义了一个按钮（<code>Button</code>）和一个列表视图（<code>ListView</code>），它们都是<code>View</code>的具体子类。按钮用于触发添加列表项的操作，列表视图用于展示数据列表。通过<code>android:id</code>属性为它们分别指定了唯一的标识符，方便在代码中通过<code>findViewById</code>方法找到对应的视图对象。</li></ul><ol><li>创建 Activity 类</li></ol><p><code>MainActivity.java</code></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.example.myapplication;import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.ArrayAdapter;import android.widget.Button;import android.widget.ListView;import java.util.ArrayList;import java.util.List;public class MainActivity extends AppCompatActivity &#123;    private ListView listView;    private Button addItemButton;    private List&lt;String&gt; dataList &#x3D; new ArrayList&lt;&gt;();    private ArrayAdapter&lt;String&gt; adapter;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        &#x2F;&#x2F; 通过findViewById方法找到XML中定义的视图对象        listView &#x3D; findViewById(R.id.list_view);        addItemButton &#x3D; findViewById(R.id.add_item_button);        adapter &#x3D; new ArrayAdapter&lt;&gt;(this, android.R.layout.simple_list_item_1, dataList);        listView.setAdapter(adapter);        addItemButton.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View v) &#123;                &#x2F;&#x2F; 点击按钮时添加一条默认文本数据到列表                dataList.add(&quot;新的列表项&quot;);                adapter.notifyDataSetChanged();            &#125;        &#125;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个<code>Activity</code>类中：</p><ul><li>首先通过<code>setContentView(R.layout.activity_main)</code>方法加载了之前创建的<code>XML</code>布局文件，这一步使得<code>XML</code>中定义的布局结构和视图组件能够在<code>Activity</code>中生效。</li><li>然后使用<code>findViewById</code>方法根据<code>XML</code>中定义的<code>id</code>来获取对应的<code>View</code>对象，也就是获取到了按钮（<code>addItemButton</code>）和列表视图（<code>listView</code>）。这里体现了<code>XML</code>和<code>View</code>的关联，<code>XML</code>只是用于描述布局和视图的定义，而要在代码中操作这些视图，就需要通过<code>findViewById</code>来获取具体的视图实例，它们是一一对应的关系。</li><li>接着创建了一个数据列表（<code>dataList</code>）和一个<code>ArrayAdapter</code>，用于将数据适配并展示在<code>ListView</code>中。</li><li>最后为按钮设置了点击监听器，当按钮被点击时，向数据列表中添加一条新的数据，并通过<code>adapter.notifyDataSetChanged()</code>通知适配器数据发生了变化，从而使得<code>ListView</code>更新显示内容。</li></ul><p>我们可以对这种开发范式进行一个总结：</p><h3 id="1-3-Compose-新范式"><a href="#1-3-Compose-新范式" class="headerlink" title="1.3 Compose: 新范式"></a>1.3 Compose: 新范式</h3><h4 id="1-3-1-传统范式的缺陷"><a href="#1-3-1-传统范式的缺陷" class="headerlink" title="1.3.1 传统范式的缺陷"></a>1.3.1 传统范式的缺陷</h4><p>我想前端同学看到传统范式，就会联想到 html + JS 的开发范式吧~</p><p>正如大家所想，html + JS 的缺点，XML + Model 层同样存在。例如在我们刚刚的例子中：</p><ol><li>代码分离导致的理解成本增加<ul><li>在基于 XML 的传统开发方式中，布局定义（XML 文件）和逻辑代码（Java 或 Kotlin 代码）是分离的。例如，在<code>activity_main.xml</code>文件中定义了按钮和列表视图的布局结构，但它们的实际行为（如按钮的点击事件处理和列表视图的数据更新）是在<code>MainActivity</code>类中实现的。</li><li>这使得开发者需要在两个不同的地方切换思维来理解整个 UI 的构建和功能实现。对于复杂的界面，可能会有多个 XML 布局文件和大量的代码来处理视图操作，这增加了代码的整体理解成本，尤其是对于新接触项目的开发者来说，可能需要花费更多的时间来梳理布局和逻辑之间的关系。</li></ul></li><li>缺乏动态性和灵活性<ul><li>XML 布局相对来说是静态的。虽然可以通过代码来修改视图的属性，但对于动态变化较多的 UI 场景，操作起来比较繁琐。</li><li>比如在这个案例中，当需要在列表视图中添加新的项时，需要通过操作数据适配器（<code>ArrayAdapter</code>）并调用<code>notifyDataSetChanged</code>方法来更新视图。如果要根据不同的条件动态地改变布局结构，如根据数据量的多少显示或隐藏某些视图，或者改变视图的排列方式，就需要在代码中进行复杂的判断和操作，并且可能需要频繁地修改 XML 布局和对应的逻辑代码。</li></ul></li><li>编译时错误检查的局限性<ul><li>XML 布局在编译时只能检查基本的语法错误和一些属性的合法性。对于布局结构是否在运行时能够正确地与逻辑代码配合，很难在编译阶段发现问题。</li><li>例如，在 XML 中可能正确地定义了一个视图的<code>id</code>，但在代码中可能会因为拼写错误或者忘记调用<code>findViewById</code>方法而导致无法正确获取和操作视图。这种运行时才可能发现的错误增加了调试的难度和时间成本。</li></ul></li><li>布局嵌套导致的性能和维护问题<ul><li>当使用 XML 构建复杂的 UI 时，不可避免地会使用到大量的布局嵌套。例如，为了实现特定的布局效果，可能会在一个<code>LinearLayout</code>中嵌套多个<code>RelativeLayout</code>，再在这些布局中包含各种视图。</li><li>过多的布局嵌套会影响性能，因为每个布局在绘制时都有一定的开销。而且，从维护的角度来看，复杂的布局嵌套会使代码变得臃肿，当需要修改布局时，可能会牵一发而动全身，影响到其他相关的布局和逻辑部分。</li></ul></li></ol><p>除了 4，可以说 1-3 都是前端在写三件套的时候，非常感同身受的缺陷了。同样的，安卓也为我们准备了类似于前端框架（统一维护 + 组件化 + 数据驱动）的方案，这就是 Jetpack Compose：</p><p>Google 官方给出了 Compose 相比于 View 的优越性：<a href="https://juejin.cn/post/6981354014453547039">Jetpack Compose 使用前后对比为了包含 Jetpack Compose 1.0.0-beta05 的更新内 - 掘金</a></p><blockquote><p><strong>在使用了 Compose 后，我们发现 APK 大小缩减了 41%，方法数减少了 17%</strong><br>XML 行数大幅减少了 **76%**。再见了，布局文件，以及 styles、theme 等其他的 XML 文件。<br>考虑到 Kotlin 编译器与 Compose 编译器插件为我们所做的事情，如位置记忆化、细粒度重组等工作，构建时间能够 <strong>减少 29%。可查看：</strong><a href="https://link.juejin.cn/?target=https://zhuanlan.zhihu.com/p/267250784">link.juejin.cn</a></p></blockquote><p>Compose 同时也具备跨平台的功能，并且在多端中保持了较好的 UI 一致性。</p><h4 id="1-3-2-Compose-重写功能"><a href="#1-3-2-Compose-重写功能" class="headerlink" title="1.3.2 Compose 重写功能"></a>1.3.2 Compose 重写功能</h4><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">import android.os.Bundleimport androidx.activity.ComponentActivityimport androidx.activity.compose.setContentimport androidx.compose.foundation.layout.Columnimport androidx.compose.material3.Buttonimport androidx.compose.material3.MaterialThemeimport androidx.compose.material3.Surfaceimport androidx.compose.material3.Textimport androidx.compose.runtime.getValueimport androidx.compose.runtime.mutableStateListOfimport androidx.compose.runtime.rememberimport androidx.compose.runtime.setValueimport androidx.compose.ui.Modifierimport androidx.compose.ui.tooling.preview.Previewclass MainActivity : ComponentActivity() &#123;    override fun onCreate(savedInstanceState: Bundle?) &#123;        super.onCreate(savedInstanceState)        setContent &#123;            &#x2F;&#x2F; 使用Surface作为最外层容器，应用主题            Surface(modifier &#x3D; Modifier.fillMaxSize(), color &#x3D; MaterialTheme.colorScheme.background) &#123;                MyApp()            &#125;        &#125;    &#125;&#125;@Composablefun MyApp() &#123;    &#x2F;&#x2F; 记住一个可变的字符串列表，用于存储列表项数据    var dataList by remember &#123; mutableStateListOf&lt;String&gt;() &#125;    Column &#123;        Button(onClick &#x3D; &#123;            &#x2F;&#x2F; 点击按钮时添加一条默认文本数据到列表            dataList.add(&quot;新的列表项&quot;)        &#125;) &#123;            Text(&quot;添加列表项&quot;)        &#125;        &#x2F;&#x2F; 遍历dataList并显示每个列表项        dataList.forEach &#123; item -&gt;            Text(text &#x3D; item)        &#125;    &#125;&#125;@Preview(showBackground &#x3D; true)@Composablefun DefaultPreview() &#123;    MyApp()&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不难看出，新方案具备如下优势：</p><ul><li>代码简洁性和可读性<ul><li>在传统的<code>View</code>、<code>ViewGroup</code>和<code>XML</code>结合的方式中，需要维护<code>XML</code>布局文件和对应的<code>Activity</code>或<code>Fragment</code>中的代码。<code>XML</code>文件用于定义布局结构，而在代码中需要通过<code>findViewById</code>等方式获取视图并设置其行为。这使得代码逻辑分散在不同的地方，增加了代码的复杂度。</li><li>而在 Compose 中，所有的 UI 相关代码都集中在可组合函数（如<code>MyApp</code>函数）中。通过组合各种<code>Composable</code>函数（如<code>Column</code>、<code>Button</code>、<code>Text</code>）来构建 UI，并且可以直接在函数内部处理交互逻辑（如按钮的点击事件）。这种声明式的方式使得代码更加简洁和易于理解，开发者可以更直观地看到 UI 的结构和行为是如何定义的。</li></ul></li><li>状态管理的便利性<ul><li>在传统方式中，当需要更新<code>ListView</code>中的数据时，需要操作<code>Adapter</code>并调用<code>notifyDataSetChanged</code>来通知视图更新。这涉及到多个对象之间的交互，并且容易出错。</li><li>Compose 通过<code>mutableStateListOf</code>和<code>remember</code>等机制使得状态管理更加方便。<code>var dataList by remember &#123; mutableStateListOf&lt;String&gt;() &#125;</code>这行代码创建了一个可被记住的可变状态列表。当列表数据发生变化（如按钮点击添加新项）时，Compose 会自动重新执行依赖于这个状态的 UI 部分（如遍历列表显示每个列表项的<code>Text</code>函数），从而更新 UI。<strong>这种自动更新机制减少了手动管理视图更新的工作量</strong>，降低了出错的概率。</li></ul></li><li>灵活性和动态 UI 构建<ul><li>传统的<code>XML</code>布局在构建复杂的动态 UI 时可能会变得很繁琐。例如，如果要根据不同的条件动态地添加或隐藏视图，需要在代码中通过<code>View</code>的<code>visibility</code>属性进行控制，并且可能需要修改<code>XML</code>布局结构来适应新的需求。</li><li>Compose 允许更灵活地构建动态 UI。由于所有的 UI 都是通过函数构建的，可以根据任何运行时条件动态地组合<code>Composable</code>函数。例如，可以根据用户权限或数据状态，轻松地在<code>Column</code>布局中添加或删除组件，或者改变组件的显示顺序，而不需要像传统方式那样考虑复杂的视图层次结构的修改。</li></ul></li></ul><h3 id="1-4-Compose-自定义组件"><a href="#1-4-Compose-自定义组件" class="headerlink" title="1.4 Compose 自定义组件"></a>1.4 Compose 自定义组件</h3><p>我们首先用一个常见的例子，对 Compose 自定义组件有一个粗浅的了解：</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">import android.os.Bundleimport androidx.activity.ComponentActivityimport androidx.activity.compose.setContentimport androidx.compose.foundation.layout.Columnimport androidx.compose.material3.Buttonimport androidx.compose.material3.MaterialThemeimport androidx.compose.material3.Surfaceimport androidx.compose.material3.Textimport androidx.compose.runtime.getValueimport androidx.compose.runtime.mutableStateListOfimport androidx.compose.runtime.rememberimport androidx.compose.runtime.setValueimport androidx.compose.ui.Modifierimport androidx.compose.ui.tooling.preview.Previewclass MainActivity : ComponentActivity() &#123;    override fun onCreate(savedInstanceState: Bundle?) &#123;        super.onCreate(savedInstanceState)        setContent &#123;            &#x2F;&#x2F; 使用Surface作为最外层容器，应用主题            Surface(modifier &#x3D; Modifier.fillMaxSize(), color &#x3D; MaterialTheme.colorScheme.background) &#123;                MyApp()            &#125;        &#125;    &#125;&#125;@Composablefun MyApp() &#123;    &#x2F;&#x2F; 状态管理部分    var dataList by remember &#123; mutableStateListOf&lt;String&gt;() &#125;  &#x2F;&#x2F; 第32行，声明可变状态列表，用于存储列表项数据，属于状态管理部分    Column &#123;        &#x2F;&#x2F; 事件处理部分        Button(onClick &#x3D; &#123;            &#x2F;&#x2F; 点击按钮时添加一条默认文本数据到列表，第36行，定义按钮点击事件的处理逻辑，属于事件处理部分            dataList.add(&quot;新的列表项&quot;)        &#125;) &#123;            Text(&quot;添加列表项&quot;)        &#125;        &#x2F;&#x2F; 遍历dataList并显示每个列表项，这部分涉及到状态管理与UI展示的结合，当dataList状态变化时，UI自动更新        dataList.forEach &#123; item -&gt;            Text(text &#x3D; item)        &#125;    &#125;&#125;@Preview(showBackground &#x3D; true)@Composablefun DefaultPreview() &#123;    MyApp()&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-4-1-状态管理"><a href="#1-4-1-状态管理" class="headerlink" title="1.4.1 状态管理"></a>1.4.1 状态管理</h4><h5 id="mutableState"><a href="#mutableState" class="headerlink" title="mutableState"></a>mutableState</h5><p>在<code>MyApp</code>这个可组合函数中：</p><ul><li><code>var dataList by remember &#123; mutableStateListOf&lt;String&gt;() &#125;</code>（第 32 行）：这一行声明了一个可变的状态列表<code>dataList</code>，它使用<code>remember</code>来确保在重组过程中能够记住这个状态，并且通过<code>mutableStateListOf</code>创建了一个可以被修改的列表类型的状态。每当这个列表的内容发生变化（比如通过按钮点击添加新元素），Compose 会自动重新执行依赖于这个状态的 UI 部分，也就是下面遍历列表展示每个列表项的<code>Text</code>部分，以此来更新界面显示。这属于状态管理部分，用于管理组件内部数据状态的变化以及和 UI 更新的关联。</li></ul><p>变量通过<code>mutableStateListOf</code>或者<code>mutableStateOf</code>包装后，当值发生变化（按钮点击导致列表更新），Compose 会自动重新执行依赖于这个状态的可组合函数（包含<code>Text</code>显示计数的部分），从而更新 UI。</p><p>除了基本对象使用<code>mutableStateOf</code>，列表对象使用 <code>mutableStateListOf</code> 以外，它们也可以用于包装一个对象。假设我们有一个自定义的数据类<code>User</code>：</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">data class User(val name: String, val age: Int)@Composablefun UserDisplay() &#123;    var user by remember &#123; mutableStateOf(User(&quot;John&quot;, 30)) &#125;    Button(onClick &#x3D; &#123; user &#x3D; user.copy(age &#x3D; user.age + 1) &#125;) &#123;        Text(&quot;User&#39;s age: $&#123;user.age&#125;&quot;)    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当按钮点击修改<code>user</code>对象的<code>age</code>属性（通过创建一个新的<code>User</code>对象副本实现），由于<code>user</code>是一个可变状态，UI 会自动更新显示新的年龄。</p><p>当然，<code>user</code> 已经不是原来的那个 <code>user</code> 了。所以类似于 React 的对象 State，必须要地址变更才会触发 UI 变更。</p><p>这其中有一个细节：<code>remember</code>函数。可以类比于前端的 <code>useMemo</code>。</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">@Composablefun ComplexLayout() &#123;    val screenDensity &#x3D; LocalDensity.current    val layoutSize by remember(screenDensity) &#123;        &#x2F;&#x2F; 复杂的计算尺寸的逻辑，这里简化为返回一个固定值        mutableStateOf(100.dp.toPx())    &#125;    Box(        modifier &#x3D; Modifier           .size(layoutSize)           .background(Color.Gray)    )&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里，<code>layoutSize</code>的计算结果通过<code>remember</code>进行缓存。只要<code>screenDensity</code>不变，这个计算结果就不会被重新计算，提高了性能。</p><h5 id="LaunchedEffect"><a href="#LaunchedEffect" class="headerlink" title="LaunchedEffect"></a>LaunchedEffect</h5><p>当需要从外部获取数据（如网络请求、数据库查询等）来更新 UI 时，可以使用<code>LaunchedEffect</code>。例如：</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">@Composablefun DataFetchScreen() &#123;    val viewModel &#x3D; viewModel&lt;MyViewModel&gt;()    val data by viewModel.data.collectAsState()    LaunchedEffect(Unit) &#123;        viewModel.fetchData()    &#125;    &#x2F;&#x2F; 根据获取到的数据展示UI    data.forEach &#123; item -&gt;        Text(item)    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>LaunchedEffect</code>在可组合函数首次组合或者其依赖的键发生变化时，触发<code>viewModel.fetchData()</code>来获取数据，当数据获取成功并更新<code>viewModel</code>中的数据状态后，由于<code>collectAsState</code>会收集这个状态变化，依赖这个状态的 UI 部分（显示数据的<code>Text</code>组件）会自动更新。</p><h5 id="MVVM-范式"><a href="#MVVM-范式" class="headerlink" title="MVVM 范式"></a>MVVM 范式</h5><p>接上个例子，我们如果想把 UI 和 Model 分离，我们可以通过观察 ViewModel 中的状态并传递给可组合函数。</p><p>在 Activity 中，通常会使用 ViewModel 来管理数据状态。例如，定义一个包含数据状态的 ViewModel：</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">class MyViewModel : ViewModel() &#123;    val data &#x3D; MutableLiveData&lt;List&lt;String&gt;&gt;()    fun fetchData() &#123;        &#x2F;&#x2F; 模拟获取数据并更新状态        val newData &#x3D; listOf(&quot;Data 1&quot;, &quot;Data 2&quot;)        data.value &#x3D; newData    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>然后在 Activity 的<code>setContent</code>方法中，将 ViewModel 中的状态传递给可组合函数：</li></ul><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">class MainActivity : ComponentActivity() &#123;    override fun onCreate(savedInstanceState: Bundle?) &#123;        super.onCreate(savedInstanceState)        val viewModel &#x3D; viewModel&lt;MyViewModel&gt;()        setContent &#123;            val data by viewModel.data.observeAsState(listOf())            MyComposable(data)        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>当 ViewModel 中的<code>data</code>状态发生变化时，传递给可组合函数<code>MyComposable</code>的数据也会改变，进而触发可组合函数内部的重组（如果数据被用于 UI 显示并正确处理了状态变化），从而更新 Activity 中的 UI。</li></ul><h4 id="1-4-2-参数传递"><a href="#1-4-2-参数传递" class="headerlink" title="1.4.2 参数传递"></a>1.4.2 参数传递</h4><p>我们在状态管理中，已经提及了将 ViewModel 中的状态传递给可组合函数。那么参数传递也能控制 UI 暂时吗？</p><p>参数不一定能直接控制 UI 变更：虽然参数在很多情况下会影响 UI，但并非所有参数的改变都必然导致 UI 变更。这取决于 Compose 的优化机制和函数内部的实现逻辑。例如，如果一个参数只是在函数内部用于一些计算，但不直接影响到最终绘制的 UI 元素，那么它的变化可能不会触发 UI 更改。</p><p>在我们的简单示例中，并没有明显体现外部参数传递，不过可以设想一下扩展情况。比如，如果想让按钮的文本内容可以由外部传入来定制，那么可以这样修改代码：</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">@Composablefun MyApp(customButtonText: String &#x3D; &quot;添加列表项&quot;) &#123;  &#x2F;&#x2F; 新增参数，并有默认值，外部可传入自定义文本，此处属于参数传递部分，用于接收外部传入参数并设置默认值    var dataList by remember &#123; mutableStateListOf&lt;String&gt;() &#125;    Column &#123;        Button(onClick &#x3D; &#123;            dataList.add(&quot;新的列表项&quot;)        &#125;) &#123;            Text(customButtonText)  &#x2F;&#x2F; 使用传入的参数作为按钮文本        &#125;        dataList.forEach &#123; item -&gt;            Text(text &#x3D; item)        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上述修改后的代码中，<code>MyApp</code>函数新增了<code>customButtonText</code>参数，外部调用<code>MyApp</code>函数时可以传入一个字符串来指定按钮上显示的文本，如果不传则使用默认值<code>&quot;添加列表项&quot;</code>，这展示了参数传递部分，通过接收外部参数来定制组件的部分表现形式。</p><p>当参数是基本数据类型（如 <code>Int</code>、<code>Boolean</code>、<code>String</code> 等）且在可组合函数内部被用于确定 UI 的显示内容或布局等关键方面时，参数的变化一般会导致 UI 随之变更。例如，我们刚刚的例子，String 的对象直接触发了更新。</p><p>然而，如果参数在函数内部没有被正确地关联到 UI 元素的更新逻辑上，即使参数变化了，UI 也可能不会更新。</p><p>对象参数的情况较为复杂：如果参数是一个对象，仅仅是对象内部某些属性的改变，并不一定会导致 UI 变更。Compose 主要是通过对可组合函数的输入进行比较来判断是否需要重组 UI。对于对象参数，默认情况下是基于对象的引用（地址）进行比较的。<strong>只有当对象的引用发生变化时，Compose 才会认为输入发生了实质性改变，从而可能触发 UI 重组。</strong></p><p>但如果在可组合函数内部手动实现了对对象属性变化的监测和相应的 UI 更新逻辑，那么即使对象地址不变，只要其关键属性发生改变，也可以实现 UI 的更新。例如，使用 <code>mutableStateOf</code> 包装对象或其属性，并在可组合函数中正确处理状态变化，就可以在对象内部属性改变时更新 UI。我们刚刚的 MVVM 例子，就属于此类。所以，在 Compose 中，Model 和 UI 可以充分解耦，<del>比 React 确实更先进。</del></p><h4 id="1-4-3-事件处理"><a href="#1-4-3-事件处理" class="headerlink" title="1.4.3 事件处理"></a>1.4.3 事件处理</h4><p>在按钮的定义部分：<br><code>Button(onClick = &#123; dataList.add(&quot;新的列表项&quot;) &#125;) &#123; Text(&quot;添加列表项&quot;) &#125;</code>（第 36 行左右）：这里定义了按钮组件的点击事件处理逻辑。当按钮被点击时，会执行<code>onClick</code>参数所对应的代码块，也就是向<code>dataList</code>中添加一个新的字符串元素。这个操作改变了前面提到的状态列表，进而触发 UI 的更新。这就是典型的用户交互事件处理，属于事件处理部分，用于定义组件如何响应各种用户操作行为。</p><p>以下是常用的事件处理表格：</p><table><thead><tr><th>事件名称</th><th>描述</th><th>示例代码</th></tr></thead><tbody><tr><td><code>onClick</code></td><td>用于处理点击事件，当用户点击组件时触发相应逻辑</td><td></td></tr></tbody></table><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">import androidx.compose.foundation.layout.Boximport androidx.compose.material.Buttonimport androidx.compose.material.Textimport androidx.compose.runtime.*@Composablefun ButtonExample() &#123;    var clickCount: Int by remember &#123; mutableStateOf(0) &#125;    Box &#123;        Button(            onClick &#x3D; &#123;                &#x2F;&#x2F; 这里是点击按钮后的代码块                clickCount++            &#125;        ) &#123;            &#x2F;&#x2F; 这里是按钮显示文本的代码块            Text(&quot;点击了 $clickCount 次&quot;)        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> |<br>|<code>onLongClick</code> |处理长按事件，用户长按组件时执行特定操作 |</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">@Composablefun LongClickExample() &#123;    var longClickMessage by remember &#123; mutableStateOf(&quot;未长按&quot;) &#125;    Box(        modifier &#x3D; Modifier         .size(100.dp)         .background(Color.Gray)         .onLongClick &#123; longClickMessage &#x3D; &quot;长按了组件&quot; &#125;    ) &#123;        Text(longClickMessage)    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> |<br>|<code>onScroll</code> |当组件可滚动且发生滚动操作时触发，可获取滚动状态信息 |</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">@Composablefun ScrollExample() &#123;    val scrollState &#x3D; rememberScrollState()    Column(modifier &#x3D; Modifier     .fillMaxSize()     .verticalScroll(scrollState)) &#123;        repeat(20) &#123;            Text(&quot;第 $it 项&quot;)        &#125;        Text(&quot;当前滚动偏移量: $&#123;scrollState.value&#125;&quot;)    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> |<br>|<code>onDrag</code> |处理拖动事件，用于实现可拖动组件的交互逻辑 |</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">@Composablefun DragExample() &#123;    var dragPosition by remember &#123; mutableStateOf(Offset.Zero) &#125;    Box(        modifier &#x3D; Modifier          .size(50.dp)          .offset &#123; dragPosition &#125;          .background(Color.Blue)          .draggable(                orientation &#x3D; Orientation.Horizontal,                onDrag &#x3D; &#123; change -&gt;                    dragPosition +&#x3D; change                &#125;            )    ) &#123;        &#x2F;&#x2F; 这里可以添加Box的内容，如果不需要可以保留空块    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> |</p><h4 id="1-4-4-组合和复用"><a href="#1-4-4-组合和复用" class="headerlink" title="1.4.4 组合和复用"></a>1.4.4 组合和复用</h4><p>在<code>MyApp</code>函数中：<br><code>Column &#123;... &#125;</code>（从第 35 行开始到结尾部分）：这里使用<code>Column</code>布局组件来组合内部的按钮和列表项显示部分。<code>Column</code>会将其内部的子组件按照垂直方向依次排列，通过这种方式将按钮和列表展示逻辑组合在一起，形成了一个相对完整的自定义组件功能。并且这个<code>MyApp</code>函数本身就可以在多个地方被复用，比如在不同的<code>Activity</code>的<code>setContent</code>方法中调用，或者在其他更复杂的可组合函数中作为一个子组件被嵌入使用，体现了组件的复用性。通过合理地组合内部组件以及设计良好的函数接口，使得整个组件可以方便地在不同场景下被重复利用，这就是组合和复用部分的体现。</p><h4 id="1-4-5-渲染控制"><a href="#1-4-5-渲染控制" class="headerlink" title="1.4.5 渲染控制"></a>1.4.5 渲染控制</h4><h5 id="条件：if"><a href="#条件：if" class="headerlink" title="条件：if"></a>条件：if</h5><p>在 Jetpack Compose 中，<code>if</code>语句可以根据条件来决定是否渲染某个组件或者组件的一部分。</p><p>基于之前的例子，假设我们想要根据列表<code>dataList</code>是否为空来显示不同的提示信息。修改后的<code>MyApp</code>函数如下：</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">@Composablefun MyApp() &#123;    var dataList by remember &#123; mutableStateListOf&lt;String&gt;() &#125;    Column &#123;        Button(onClick &#x3D; &#123;            dataList.add(&quot;新的列表项&quot;)        &#125;) &#123;            Text(&quot;添加列表项&quot;)        &#125;        if (dataList.isEmpty()) &#123;            Text(&quot;列表为空&quot;)        &#125; else &#123;            dataList.forEach &#123; item -&gt;                Text(text &#x3D; item)            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>当<code>dataList</code>为空时（<code>dataList.isEmpty()</code>为<code>true</code>），只会渲染一个显示 “列表为空” 的<code>Text</code>组件。</li><li>当<code>dataList</code>不为空时，就会遍历<code>dataList</code>并渲染每个列表项对应的<code>Text</code>组件。这种<code>if</code>语句的使用方式使得 UI 的渲染可以根据数据状态的不同而灵活变化，提供了一种简单有效的条件渲染控制。</li></ul><h5 id="遍历：forEach"><a href="#遍历：forEach" class="headerlink" title="遍历：forEach"></a>遍历：forEach</h5><p>在之前的例子中，<code>forEach</code>已经用于遍历<code>dataList</code>来渲染列表项。</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">dataList.forEach &#123; item -&gt;    Text(text &#x3D; item)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>在这里，<code>forEach</code>会对<code>dataList</code>中的每个元素执行一次代码块。对于每个元素，都会创建一个<code>Text</code>组件来显示该元素的内容。这种方式在处理列表、数组等集合类型的数据时非常有用，可以方便地根据集合中的元素数量和内容来动态渲染 UI 组件。</li><li>当<code>dataList</code>的内容发生变化（例如，通过按钮点击添加了新的元素），Compose 会检测到<code>dataList</code>这个状态的变化，并且重新执行依赖于这个状态的<code>forEach</code>部分，从而更新 UI，显示新的列表项。这展示了<code>forEach</code>在与状态管理结合时，如何有效地控制组件的渲染，以适应数据的动态变化。</li></ul><h4 id="1-4-6-布局组件"><a href="#1-4-6-布局组件" class="headerlink" title="1.4.6 布局组件"></a>1.4.6 布局组件</h4><table><thead><tr><th>布局组件</th><th>功能描述</th><th>示例场景</th><th>示例代码（关键部分）</th></tr></thead><tbody><tr><td>Column</td><td>子组件按垂直方向排列</td><td>用户信息展示（用户名、头像、简介垂直堆叠）</td><td></td></tr></tbody></table><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">@Composablefun MyColumn() &#123;    Column &#123;        Text(text &#x3D; &quot;第一行文本&quot;)        Text(text &#x3D; &quot;第二行文本&quot;)        Text(text &#x3D; &quot;第三行文本&quot;)    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> |<br>|Row |子组件按水平方向排列 |工具条中多个按钮排列（如搜索、设置按钮） |</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">Row &#123;    Button(onClick &#x3D; &#123; &#x2F;* 点击事件处理 *&#x2F; &#125;) &#123;        Text(&quot;按钮1&quot;)    &#125;    Button(onClick &#x3D; &#123; &#x2F;* 点击事件处理 *&#x2F; &#125;) &#123;        Text(&quot;按钮2&quot;)    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> |<br>|Box |子组件堆叠，通过<code>Modifier</code>控制位置和对齐 |加载动画覆盖在内容之上 |</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">Box(    modifier &#x3D; Modifier.fillMaxSize()) &#123;    Text(        text &#x3D; &quot;这是内容文本&quot;,        modifier &#x3D; Modifier.align(Alignment.Center)    )    CircularProgressIndicator(        modifier &#x3D; Modifier.align(Alignment.TopEnd)    )&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> |<br>|ConstraintLayout（Compose版） |通过定义子组件间约束关系确定位置，用于复杂布局 |制作有重叠元素和复杂对齐要求的表单 |</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">ConstraintLayout(    modifier &#x3D; Modifier.fillMaxSize()) &#123;    val (button, text) &#x3D; createRefs()    Button(        onClick &#x3D; &#123; &#x2F;* 点击事件处理 *&#x2F; &#125;,        modifier &#x3D; Modifier.constrainAs(button) &#123;            top.linkTo(parent.top)            start.linkTo(parent.start)        &#125;    ) &#123;        Text(&quot;按钮&quot;)    &#125;    Text(        &quot;文本内容&quot;,        modifier &#x3D; Modifier.constrainAs(text) &#123;            top.linkTo(button.bottom)            start.linkTo(parent.start)        &#125;    )&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> |<br>|LazyColumn&#x2F;LazyRow |懒加载，仅加载屏幕可见子组件，用于长列表或长布局 |新闻列表应用（滚动加载新闻项） |</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">LazyColumn &#123;    val dataList &#x3D; listOf(&quot;数据1&quot;, &quot;数据2&quot;, &quot;数据3&quot;, &quot;数据4&quot;, &quot;数据5&quot;)    items(dataList.size) &#123; index -&gt;        Text(dataList[index])    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> |</p><h3 id="1-5-深入学习-Compose"><a href="#1-5-深入学习-Compose" class="headerlink" title="1.5 深入学习 Compose"></a>1.5 深入学习 Compose</h3><h4 id="1-5-1-常见概念解释"><a href="#1-5-1-常见概念解释" class="headerlink" title="1.5.1 常见概念解释"></a>1.5.1 常见概念解释</h4><h5 id="可组合函数（Composable-Functions）"><a href="#可组合函数（Composable-Functions）" class="headerlink" title="可组合函数（Composable Functions）"></a>可组合函数（Composable Functions）</h5><ul><li>定义与用途：这是 Compose 的核心概念。可组合函数是用 Kotlin 编写的函数，通过<mark style="background-color: #BBBFC4"><code>@Composable</code></mark>注解标记。它们用于描述 UI 的一部分，就像构建 UI 的积木块。例如，一个简单的显示文本的可组合函数如下：</li></ul><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">@Composablefun MyText() &#123;    Text(&quot;Hello, Compose!&quot;)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>组合方式：可组合函数可以互相组合来构建复杂的 UI。比如，在一个垂直布局的 UI 中，可以将多个不同的可组合函数组合在一起，像这样：</li></ul><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">@Composablefun MyComplexUI() &#123;    Column &#123;        MyText()        AnotherComposableFunction()    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>理解可组合函数是学习 Compose 开发的基础，因为所有的 UI 构建都是围绕它们展开的。它们使得 UI 开发更具模块化和可维护性，每个函数负责特定的 UI 部分，便于复用和更新。</p><h5 id="状态（State）和重组（Recomposition）"><a href="#状态（State）和重组（Recomposition）" class="headerlink" title="状态（State）和重组（Recomposition）"></a>状态（State）和重组（Recomposition）</h5><ul><li>状态管理：在 Compose 中，状态是驱动 UI 更新的关键。状态可以是简单的数据类型（如布尔值、整数、字符串等）或复杂的数据结构（如列表、自定义对象等）。使用<code>mutableStateOf</code>或<code>mutableStateListOf</code>等函数来创建可变状态。例如：</li></ul><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">@Composablefun Counter() &#123;    var count by remember &#123; mutableStateOf(0) &#125;    Button(onClick &#x3D; &#123; count++ &#125;) &#123;        Text(&quot;Count: $count&quot;)    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>重组机制：当状态发生变化时，Compose 会自动重新执行依赖于该状态的可组合函数，这就是重组。重组是高效的，Compose 会尽可能地只更新受影响的 UI 部分。例如，在上述计数器的例子中，每次点击按钮，<code>count</code>状态改变，包含<code>count</code>显示的<code>Text</code>组件所在的可组合函数会重新执行，更新 UI 显示新的计数。</li></ul><h5 id="布局（Layout）组件"><a href="#布局（Layout）组件" class="headerlink" title="布局（Layout）组件"></a>布局（Layout）组件</h5><ul><li>基本布局组件：Compose 提供了多种布局组件，如<code>Column</code>（垂直布局）、<code>Row</code>（水平布局）、<code>Box</code>（简单的堆叠布局）等。这些布局组件用于控制子组件的排列方式。例如，使用<code>Column</code>可以将多个组件垂直排列：</li></ul><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">@Composablefun VerticalLayout() &#123;    Column &#123;        Text(&quot;Top Text&quot;)        Text(&quot;Bottom Text&quot;)    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>嵌套布局：布局组件可以相互嵌套来实现更复杂的布局。例如，在一个<code>Row</code>布局中嵌套<code>Column</code>布局来创建一个类似表格的结构。理解布局组件的使用和嵌套规则对于构建各种复杂程度的 UI 界面至关重要。</li></ul><h5 id="材质设计（Material-Design）组件和主题（Theme）"><a href="#材质设计（Material-Design）组件和主题（Theme）" class="headerlink" title="材质设计（Material Design）组件和主题（Theme）"></a>材质设计（Material Design）组件和主题（Theme）</h5><ul><li>材质设计组件：Compose 支持 Material Design 规范，提供了许多符合该规范的组件，如<code>Button</code>、<code>TextField</code>、<code>Card</code>等。这些组件不仅具有预定义的外观，还遵循一定的交互规则，使得应用具有一致的、符合设计标准的用户体验。例如，<code>Button</code>组件在不同状态（如按下、禁用等）下有相应的视觉反馈。</li><li>主题应用：主题用于定义应用的整体颜色、字体、形状等外观属性。通过设置主题，可以确保应用中的所有组件具有统一的风格。例如，可以在主题中定义主色调、次色调，然后所有的<code>Button</code>、<code>Text</code>等组件会根据主题来应用相应的颜色。</li></ul><p>我们创建一个简单的界面，包含一个带有特定主题颜色的卡片（Card）组件，卡片中有一个标题（Text）和一个按钮（Button），按钮的颜色也根据主题来设定：</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">import androidx.compose.foundation.layout.Columnimport androidx.compose.material3.Cardimport androidx.compose.material3.MaterialThemeimport androidx.compose.material3.Textimport androidx.compose.material3.Buttonimport androidx.compose.runtime.Composableimport androidx.compose.ui.tooling.preview.Preview@Composablefun MyMaterialUI() &#123;    &#x2F;&#x2F; 定义一个卡片组件，使用主题中的颜色    Card(        &#x2F;&#x2F; 卡片的背景颜色使用主题中的表面颜色        backgroundColor &#x3D; MaterialTheme.colorScheme.surface    ) &#123;        Column &#123;            &#x2F;&#x2F; 标题文本，颜色使用主题中的主色调            Text(                text &#x3D; &quot;这是一个标题&quot;,                color &#x3D; MaterialTheme.colorScheme.primary            )            Button(                &#x2F;&#x2F; 按钮的背景颜色使用主题中的主色调                onClick &#x3D; &#123; &#x2F;* 按钮点击事件处理，这里暂为空 *&#x2F; &#125;,                color &#x3D; MaterialTheme.colorScheme.primary            ) &#123;                Text(&quot;点击我&quot;)            &#125;        &#125;    &#125;&#125;@Preview(showBackground &#x3D; true)@Composablefun DefaultPreview() &#123;    MyMaterialUI()&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，<code>MaterialTheme.colorScheme</code>用于获取主题相关的<strong>颜色方案</strong>。<code>surface</code>颜色用于设置卡片的背景色，<code>primary</code>颜色用于设置标题文本和按钮的颜色。这样，通过主题可以统一管理整个应用的颜色风格，当需要修改主题颜色时，只需要在主题定义处修改相关的颜色值，所有使用该主题颜色的组件都会自动更新。</p><p>在这个例子中，我们使用了<code>Card</code>、<code>Text</code>和<code>Button</code>这三个符合 Material Design 规范的组件。<code>Card</code>组件提供了一种带有阴影效果的容器，用于突出显示内容。<code>Text</code>组件用于显示文本，其颜色等属性可以根据主题灵活设置。<code>Button</code>组件具有默认的外观和交互行为，如按下时的视觉反馈等，符合 Material Design 的设计原则，为用户提供了一致的操作体验。</p><h5 id="副作用（Side-Effects）函数（如-LaunchedEffect、DisposableEffect）"><a href="#副作用（Side-Effects）函数（如-LaunchedEffect、DisposableEffect）" class="headerlink" title="副作用（Side Effects）函数（如 LaunchedEffect、DisposableEffect）"></a>副作用（Side Effects）函数（如 LaunchedEffect、DisposableEffect）</h5><p>用途：在 Compose 中，副作用函数用于处理一些与外部系统交互或者有额外影响的操作。例如，<code>LaunchedEffect</code>用于在可组合函数内部启动协程，以执行异步操作，如从网络获取数据、进行动画播放等。</p><p>我们创建一个界面，在界面加载时从网络获取用户信息，并在获取成功后显示用户的姓名和邮箱：</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">import androidx.compose.foundation.layout.Columnimport androidx.compose.material3.Textimport androidx.compose.runtime.Composableimport androidx.compose.runtime.LaunchedEffectimport androidx.compose.runtime.getValueimport androidx.compose.runtime.mutableStateOfimport androidx.compose.runtime.rememberimport androidx.compose.ui.platform.LocalContextimport kotlinx.coroutines.Dispatchersimport kotlinx.coroutines.withContextimport java.net.URL@Composablefun UserInfoScreen() &#123;    val context &#x3D; LocalContext.current    val (userName, setUserName) &#x3D; remember &#123; mutableStateOf(&quot;&quot;) &#125;    val (userEmail, setUserEmail) &#x3D; remember &#123; mutableStateOf(&quot;&quot;) &#125;    LaunchedEffect(Unit) &#123;        val userInfo &#x3D; withContext(Dispatchers.IO) &#123;            try &#123;                &#x2F;&#x2F; 模拟从网络获取用户信息，这里使用一个简单的URL示例                val url &#x3D; URL(&quot;https:&#x2F;&#x2F;example.com&#x2F;user_info.json&quot;)                val connection &#x3D; url.openConnection()                connection.connect()                val inputStream &#x3D; connection.getInputStream()                &#x2F;&#x2F; 解析JSON数据获取用户姓名和邮箱，这里简化处理，假设数据格式简单                val userInfoString &#x3D; inputStream.bufferedReader().readLine()                val userInfoArray &#x3D; userInfoString.split(&quot;,&quot;)                Pair(userInfoArray[0], userInfoArray[1])            &#125; catch (e: Exception) &#123;                Pair(&quot;&quot;, &quot;&quot;)            &#125;        &#125;        setUserName(userInfo.first)        setUserEmail(userInfo.second)    &#125;    Column &#123;        Text(&quot;用户姓名: $userName&quot;)        Text(&quot;用户邮箱: $userEmail&quot;)    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>LaunchedEffect</code>的作用：在<code>UserInfoScreen</code>这个可组合函数中，<code>LaunchedEffect(Unit)</code>表示这个副作用只会在函数首次组合时触发一次（因为键是<code>Unit</code>）。在<code>LaunchedEffect</code>内部，通过<code>withContext(Dispatchers.IO)</code>在协程的<code>IO</code>调度器下执行从网络获取用户信息的操作。这是因为网络操作是一个耗时的<code>IO</code>操作，不能阻塞主线程。</li><li>状态更新和 UI 更新：获取到用户信息后，通过<code>setUserName</code>和<code>setUserEmail</code>来更新对应的状态。由于这些状态被<code>Text</code>组件所依赖，当状态更新时，Compose 会自动重新执行<code>UserInfoScreen</code>函数中依赖于这些状态的部分（也就是显示用户姓名和邮箱的<code>Text</code>组件），从而更新 UI，将获取到的用户信息显示出来。这样就实现了在界面加载时获取数据并更新 UI 的功能，利用<code>LaunchedEffect</code>处理了网络获取数据这个有副作用的操作。</li></ul><h4 id="1-5-2-修饰符"><a href="#1-5-2-修饰符" class="headerlink" title="1.5.2 修饰符"></a>1.5.2 修饰符</h4><ol><li><p>Compose 修饰符的分类</p><ul><li>布局修饰符：用于控制组件的布局方式，如<code>size</code>、<code>padding</code>、<code>fillMaxSize</code>等。这些修饰符可以改变组件的大小、间距和填充等布局属性。</li><li>外观修饰符：主要影响组件的外观，像<code>background</code>、<code>border</code>、<code>alpha</code>等。它们用于设置组件的背景颜色、边框以及透明度等外观特征。</li><li>行为修饰符：用于处理组件的行为相关属性，例如<code>clickable</code>、<code>draggable</code>、<code>focusable</code>等。这些修饰符使组件能够响应点击、拖动、获取焦点等用户交互行为。</li><li>组合修饰符：用于组合其他修饰符或者创建新的修饰符逻辑，比如<code>then</code>、<code>wrapContentSize</code>等。</li></ul></li><li><p>基本使用</p></li></ol><ul><li>布局修饰符示例 - <code>size</code><ul><li>功能：用于指定组件的宽度和高度。</li></ul></li></ul><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">import androidx.compose.foundation.layout.sizeimport androidx.compose.material3.Textimport androidx.compose.runtime.Composable@Composablefun SizedText() &#123;    Text(&quot;这是一个有固定大小的文本&quot;, modifier &#x3D; size(100.dp, 50.dp))&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，<code>size(100.dp, 50.dp)</code>修饰符应用于<code>Text</code>组件，使得文本显示区域的宽度为<code>100dp</code>，高度为<code>50dp</code>。</p><ul><li>外观修饰符示例 - <code>background</code><ul><li>功能：设置组件的背景颜色。</li></ul></li></ul><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">import androidx.compose.foundation.layout.Boximport androidx.compose.foundation.layout.sizeimport androidx.compose.material3.MaterialThemeimport androidx.compose.material3.Textimport androidx.compose.runtime.Composableimport androidx.compose.ui.Modifierimport androidx.compose.ui.graphics.Color@Composabledef BackgroundBox() &#123;    Box(        modifier &#x3D; Modifier           .size(200.dp)           .background(Color.Green)    ) &#123;        Text(&quot;绿色背景的盒子&quot;)    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解释：这里的<code>Box</code>组件使用<code>background(Color.Green)</code>修饰符，将其背景颜色设置为绿色。<code>size</code>修饰符用于确定<code>Box</code>的大小，以便更好地展示背景颜色效果。</p><ol><li>链式调用 + 效果叠加</li></ol><ul><li>示例：组合行为和外观修饰符实现交互效果叠加<ul><li>（链式调用）同时应用多个修饰符来实现复杂的效果，如设置大小并添加背景颜色。</li><li>（效果叠加）当用户与组件交互时，同时改变外观和行为响应。</li></ul></li></ul><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">import androidx.compose.foundation.clickableimport androidx.compose.foundation.layout.Boximport androidx.compose.foundation.layout.sizeimport androidx.compose.material3.MaterialThemeimport androidx.compose.material3.Textimport androidx.compose.runtime.Composableimport androidx.compose.ui.Modifierimport androidx.compose.ui.graphics.Colorimport androidx.compose.ui.unit.dp@Composabledef ModifiersOverlayBox() &#123;    Box(        modifier &#x3D; Modifier           .size(120.dp)           .background(Color.LightGray)           .clickable &#123; &#x2F;* 点击事件处理 *&#x2F; &#125;           .border(1.dp, Color.Black)    ) &#123;        Text(&quot;可点击、有边框且有背景色的盒子&quot;)    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，<code>Box</code>组件具有灰色背景、黑色边框，并且添加了点击行为。这些修饰符的效果叠加在一起，当用户看到这个组件时，它有特定的外观，当用户与之交互（点击）时，又会触发相应的行为。这种效果叠加方式使得可以通过组合多个修饰符来创建丰富的、具有交互性的组件。</p><h4 id="1-5-3-副作用"><a href="#1-5-3-副作用" class="headerlink" title="1.5.3 副作用"></a>1.5.3 副作用</h4><p>在 1.4 中，我们有提到 LaunchedEffect，它属于副作用的一种。</p><p>在安卓 Jetpack Compose 中，副作用是指在可组合函数内部执行的，会对外部环境产生影响或者依赖于外部环境的操作。由于 Compose 的可组合函数主要是用于描述 UI 的声明式函数，理想情况下应该是无副作用的纯函数。但在实际应用中，像与外部系统交互（如网络请求、读取本地文件）、修改全局状态等操作都属于副作用。</p><h5 id="LaunchedEffect-1"><a href="#LaunchedEffect-1" class="headerlink" title="LaunchedEffect"></a>LaunchedEffect</h5><p>区别与用途：<code>LaunchedEffect</code>是用于在 Compose 中执行挂起函数（通常是异步操作）的副作用函数。它会在可组合函数首次被组合或者其键（<code>keys</code>）发生改变时启动一个协程来执行相应的操作。主要用于处理一次性的异步操作，如在界面加载时从网络获取数据、初始化动画等。</p><p>示例：假设我们有一个界面需要在加载时从网络获取用户信息并显示。</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">import androidx.compose.foundation.layout.Columnimport androidx.compose.material3.Textimport androidx.compose.runtime.Composableimport androidx.compose.runtime.LaunchedEffectimport androidx.compose.runtime.getValueimport androidx.compose.runtime.mutableStateOfimport androidx.compose.runtime.rememberimport androidx.compose.ui.platform.LocalContextimport kotlinx.coroutines.Dispatchersimport kotlinx.coroutines.withContextimport java.net.URL@Composablefun UserInfoScreen() &#123;    val context &#x3D; LocalContext.current    val (userName, setUserName) &#x3D; remember &#123; mutableStateOf(&quot;&quot;) &#125;    val (userEmail, setUserEmail) &#x3D; remember &#123; mutableStateOf(&quot;&quot;) &#125;    LaunchedEffect(Unit) &#123;        val userInfo &#x3D; withContext(Dispatchers.IO) &#123;            try &#123;                &#x2F;&#x2F; 模拟从网络获取用户信息，这里使用一个简单的URL示例                val url &#x3D; URL(&quot;https:&#x2F;&#x2F;example.com&#x2F;user_info.json&quot;)                val connection &#x3D; url.openConnection()                connection.connect()                val inputStream &#x3D; connection.getInputStream()                &#x2F;&#x2F; 解析JSON数据获取用户姓名和邮箱，这里简化处理，假设数据格式简单                val userInfoString &#x3D; inputStream.bufferedReader().readLine()                val userInfoArray &#x3D; userInfoString.split(&quot;,&quot;)                Pair(userInfoArray[0], userInfoArray[1])            &#125; catch (e: Exception) &#123;                Pair(&quot;&quot;, &quot;&quot;)            &#125;        &#125;        setUserName(userInfo.first)        setUserEmail(userInfo.second)    &#125;    Column &#123;        Text(&quot;用户姓名: $userName&quot;)        Text(&quot;用户邮箱: $userEmail&quot;)    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，<code>LaunchedEffect(Unit)</code>表示这个副作用只会在<code>UserInfoScreen</code>可组合函数首次组合时触发一次（因为键是<code>Unit</code>）。在<code>LaunchedEffect</code>内部，通过<code>withContext(Dispatchers.IO)</code>在协程的<code>IO</code>调度器下执行从网络获取用户信息的操作。获取到用户信息后，通过<code>setUserName</code>和<code>setUserEmail</code>来更新对应的状态，从而更新 UI 显示用户信息。</p><h5 id="DisposableEffect"><a href="#DisposableEffect" class="headerlink" title="DisposableEffect"></a>DisposableEffect</h5><p>区别与用途：<code>DisposableEffect</code>主要用于在可组合函数被销毁或者其键（<code>keys</code>）发生改变时，执行清理资源的操作。这对于避免资源泄漏（如取消订阅、关闭文件流等）非常重要。</p><p>示例：假设我们在一个可组合函数中订阅了一个数据流，当可组合函数不再需要时（例如界面被关闭），需要取消订阅以避免内存泄漏。</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">import androidx.compose.foundation.layout.Columnimport androidx.compose.material3.Textimport androidx.compose.runtime.Composableimport androidx.compose.runtime.DisposableEffectimport androidx.compose.runtime.getValueimport androidx.compose.runtime.mutableStateListOfimport androidx.compose.runtime.rememberimport kotlinx.coroutines.flow.Flowimport kotlinx.coroutines.flow.flow@Composablefun DataStreamScreen() &#123;    val dataList &#x3D; remember &#123; mutableStateListOf&lt;String&gt;() &#125;    val dataFlow: Flow&lt;String&gt; &#x3D; flow &#123;        &#x2F;&#x2F; 模拟一个简单的数据流，不断发送数字字符串        var i &#x3D; 0        while (true) &#123;            emit(&quot;Data $i&quot;)            i++        &#125;    &#125;    val job &#x3D; remember &#123;        LaunchedEffect(dataFlow) &#123;            val job &#x3D; kotlinx.coroutines.launch &#123;                dataFlow.collect &#123; value -&gt;                    dataList.add(value)                &#125;            &#125;            onDispose &#123;                job.cancel()            &#125;        &#125;    &#125;    Column &#123;        dataList.forEach &#123; item -&gt;            Text(item)        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，首先创建了一个<code>dataFlow</code>数据流，然后在<code>LaunchedEffect</code>中启动一个协程来收集这个数据流的数据并添加到<code>dataList</code>中。<code>DisposableEffect</code>通过<code>onDispose</code>块来确保在<code>LaunchedEffect</code>中的协程任务（用于收集流数据）在可组合函数不再需要时（例如，界面关闭或者<code>dataFlow</code>发生变化）被取消，从而正确地释放资源，避免内存泄漏。</p><h4 id="1-5-4-智能重组"><a href="#1-5-4-智能重组" class="headerlink" title="1.5.4 智能重组"></a>1.5.4 智能重组</h4><p>从本质上来说，Compose 依赖其 SDK 与编译器，Kotlin 依赖编译器插件的模式来进行实现。Compose 通几个注解帮助编译器进一步识别不会重组的 UI 对象。具体有如下几种：</p><h5 id="ReadOnlyComposable"><a href="#ReadOnlyComposable" class="headerlink" title="@ReadOnlyComposable"></a>@ReadOnlyComposable</h5><p><code>ReadOnlyComposable</code>注解用于标记那些不会修改任何状态的可组合函数。这些函数在被调用时，只是单纯地根据传入的参数构建 UI，不会产生副作用或者改变任何可观察的状态。</p><p>当 Compose 进行重组分析时，知道一个被标记为<code>ReadOnlyComposable</code>的函数是无状态的，就可以在某些情况下避免不必要的重新执行。例如，如果这个函数只是用于简单地格式化和显示文本内容，并且不依赖于任何可能变化的状态，那么在其他状态发生变化时，Compose 可以跳过对这个函数的重新执行，从而提高重组效率。</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">@ReadOnlyComposable@Composablefun FormattedText(text: String) &#123;    Text(text.uppercase())&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，<code>FormattedText</code>函数只是将传入的文本转换为大写并显示，不会修改任何状态。Compose 在重组过程中，如果发现只有其他无关状态发生变化，就可以不重新执行这个函数，因为它的输出只依赖于传入的<code>text</code>参数，而这个参数在没有改变的情况下，UI 显示也不会改变。</p><h5 id="Immutable"><a href="#Immutable" class="headerlink" title="@Immutable"></a>@Immutable</h5><p><code>Immutable</code>注解用于标记数据类型，表示这个数据类型是不可变的。当一个数据类型被标记为<code>Immutable</code>后，Compose 可以更有效地处理对这个数据的引用。例如，对于一个不可变的数据类，一旦创建，其内部的属性就不能被修改。</p><p>在智能重组的场景下，Compose 需要比较数据是否发生变化来决定是否重新执行相关的可组合函数。对于<code>Immutable</code>类型的数据，比较过程更加简单和高效。因为不可变数据的属性不会改变，所以 Compose 可以通过引用比较或者简单的内容比较（如果数据结构简单）来快速确定数据是否发生了变化。如果数据没有变化，依赖于这个数据的可组合函数部分就不需要重组。</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">@Immutabledata class UserInfo(val name: String, val age: Int)@Composablefun UserInfoDisplay(userInfo: UserInfo) &#123;    Column &#123;        Text(&quot;姓名: $&#123;userInfo.name&#125;&quot;)        Text(&quot;年龄: $&#123;userInfo.age&#125;&quot;)    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，<code>UserInfo</code>数据类被标记为<code>Immutable</code>。当<code>UserInfoDisplay</code>可组合函数的<code>userInfo</code>参数发生变化时，Compose 可以通过比较<code>UserInfo</code>对象的引用或者简单的属性比较（因为属性不可变）来快速判断是否需要重新执行这个函数。如果只是其他无关状态改变，而<code>userInfo</code>没有变化，就不需要重组<code>UserInfoDisplay</code>函数部分的 UI。</p><h5 id="Stable"><a href="#Stable" class="headerlink" title="@Stable"></a>@Stable</h5><p><code>Stable</code>注解用于标记类型或者函数，表示它们在 Compose 的重组过程中是稳定的。对于一个被标记为<code>Stable</code>的对象，Compose 可以假设它的内容或者行为在没有明显变化提示的情况下是不变的。这包括对象的属性（如果是一个类）以及它所产生的副作用（如果是一个函数）。</p><p>和<code>Immutable</code>类似，<code>Stable</code>帮助 Compose 在重组分析中做出更高效的决策。如果一个可组合函数的参数是<code>Stable</code>类型，并且在没有明确的变化信号（如状态改变）时，Compose 可以减少对这个函数的重新检查和重新执行。这有助于优化重组过程，避免不必要的 UI 更新。</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">@Stableclass MyStableObject &#123;    val value: String &#x3D; &quot;稳定的值&quot;&#125;@Composablefun MyStableObjectDisplay(myObject: MyStableObject) &#123;    Text(myObject.value)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，<code>MyStableObject</code>类被标记为<code>Stable</code>。<code>MyStableObjectDisplay</code>可组合函数依赖于<code>MyStableObject</code>。在重组过程中，Compose 会认为<code>MyStableObject</code>是稳定的，只要没有明确的变化提示（如通过状态管理机制通知变化），就不会轻易重新执行<code>MyStableObjectDisplay</code>函数，从而提高了智能重组的效率。</p><h5 id="区别-＆-使用场景"><a href="#区别-＆-使用场景" class="headerlink" title="区别 ＆ 使用场景"></a>区别 ＆ 使用场景</h5><table><thead><tr><th>标记类型</th><th>关注重点</th><th>定义描述</th><th>示例</th><th>使用场景</th></tr></thead><tbody><tr><td><code>ReadOnlyComposable</code></td><td>函数行为</td><td>标记可组合函数特性，该函数不会修改任何状态，从函数执行角度强调纯净性，仅根据传入参数构建 UI，无状态修改和副作用</td><td>一个将输入文本转换为大写并显示的函数，只进行数据转换和 UI 展示，不影响外部状态</td><td>1. 纯展示型函数，如格式化日期并显示在文本组件中。</td></tr><tr><td>2. 无状态的 UI 组件构建，如固定样式的图标组件</td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td><code>Immutable</code></td><td>数据类型的不可变性</td><td>用于描述数据类型，被标记的数据类型创建后内部属性不能被修改，是对数据结构本身性质的定义</td><td>一个简单数据类，属性为<code>val</code>且无修改属性方法，整个生命周期内稳定，除非重新创建</td><td>1. 配置数据传递，如应用的主题配置数据类。</td></tr><tr><td>2. 缓存数据和常量数据结构，如预定义的菜单选项列表</td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td><code>Stable</code></td><td>综合的稳定性</td><td>可用于标记类型（如类）或函数。标记类型时表示在重组过程中的稳定性，包括属性和行为；标记函数时表示副作用和返回值等方面的稳定性</td><td>1. 具有复杂内部状态但对外表现稳定的用户配置对象。</td><td></td></tr><tr><td>2. 根据系统时间和固定时间间隔决定是否显示提示信息的函数，在相关条件不变时行为稳定</td><td></td><td></td><td></td><td></td></tr><tr><td>1. 复杂但稳定的对象，如包含多个属性和内部计算逻辑的用户配置对象。</td><td></td><td></td><td></td><td></td></tr><tr><td>2. 有条件稳定的函数，如上述按特定条件决定显示提示信息的函数</td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h4 id="1-5-5-性能优化"><a href="#1-5-5-性能优化" class="headerlink" title="1.5.5 性能优化"></a>1.5.5 性能优化</h4><blockquote><p><a href="https://developer.android.com/develop/ui/compose/performance/bestpractices?hl=zh-cn">https://developer.android.com/develop/ui/compose/performance/bestpractices?hl=zh-cn</a><br>原文档写的很清楚了，我直接 Copy</p></blockquote><h5 id="使用-remember-尽可能减少开销高昂的计算"><a href="#使用-remember-尽可能减少开销高昂的计算" class="headerlink" title="使用 remember 尽可能减少开销高昂的计算"></a>使用 <code>remember</code> 尽可能减少开销高昂的计算</h5><p>可组合函数<a href="https://developer.android.com/develop/ui/compose/mental-model?hl=zh-cn#frequent">可能会非常频繁地运行</a>，与每个帧的运行频率一样高 动画效果因此，您应当在可组合函数的主体部分中尽可能减少计算。</p><p>使用 <a href="https://developer.android.com/develop/ui/compose/state?hl=zh-cn#state-in-composables">存储</a>计算结果 <code>[remember](https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary?hl=zh-cn#remember(kotlin.Function0))</code>。这样，计算只会运行一次， 结果。</p><p>例如，下面的代码显示了经过排序的名称列表，但 进行大量排序：</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">@Composablefun ContactList(    contacts: List&lt;Contact&gt;,    comparator: Comparator&lt;Contact&gt;,    modifier: Modifier &#x3D; Modifier) &#123;    LazyColumn(modifier) &#123;        &#x2F;&#x2F; DON’T DO THIS        items(contacts.sortedWith(comparator)) &#123; contact -&gt;            &#x2F;&#x2F; ...        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><a href="https://github.com/android/snippets/blob/e9e2f2099c03406170d6b72a7974f6d7658ee8e3/compose/snippets/src/main/java/com/example/compose/snippets/performance/PerformanceSnippets.kt#L50-L62">PerformanceSnippets.kt</a></strong></p><p>每次重组 <code>ContactsList</code> 时，都会对整个联系人列表全部排序 即使该列表没有变化如果用户滚动列表 每当出现新行时，可组合函数都会重组。</p><p>如需解决此问题，请在 <code>LazyColumn</code> 外部对列表进行排序，并使用 <code>remember</code> 存储已排序列表：</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">@Composablefun ContactList(    contacts: List&lt;Contact&gt;,    comparator: Comparator&lt;Contact&gt;,    modifier: Modifier &#x3D; Modifier) &#123;    val sortedContacts &#x3D; remember(contacts, comparator) &#123;        contacts.sortedWith(comparator)    &#125;    LazyColumn(modifier) &#123;        items(sortedContacts) &#123;            &#x2F;&#x2F; ...        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><a href="https://github.com/android/snippets/blob/e9e2f2099c03406170d6b72a7974f6d7658ee8e3/compose/snippets/src/main/java/com/example/compose/snippets/performance/PerformanceSnippets.kt#L68-L83">PerformanceSnippets.kt</a></strong></p><p>现在，列表只会在 <code>ContactList</code> 首次组合时执行一次排序。如果联系人或比较器发生变化，则系统会重新生成经过排序的列表。否则，可组合函数会继续使用缓存中的已排序列表。</p><p><strong>注意</strong>：请尽可能将计算代码移到可组合函数的外部。在这种情况下，您可能需要在其他位置（如在 <code>**ViewModel**</code> 中）对列表进行排序，并将已排序列表作为输入提供给可组合函数。</p><h5 id="使用延迟布局键"><a href="#使用延迟布局键" class="headerlink" title="使用延迟布局键"></a>使用延迟布局键</h5><p><a href="https://developer.android.com/develop/ui/compose/lists?hl=zh-cn#lazy">延迟布局</a>可高效地重复使用项，只需重新生成或重组项 。不过，您可以帮助优化延迟布局 重组。</p><p>假设某项用户操作会导致项在列表中移动。例如： 假设您显示了按修改时间排序的 上面显示了最近修改过的备注</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">@Composablefun NotesList(notes: List&lt;Note&gt;) &#123;    LazyColumn &#123;        items(            items &#x3D; notes        ) &#123; note -&gt;            NoteRow(note)        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><a href="https://github.com/android/snippets/blob/e9e2f2099c03406170d6b72a7974f6d7658ee8e3/compose/snippets/src/main/java/com/example/compose/snippets/performance/PerformanceSnippets.kt#L89-L98">PerformanceSnippets.kt</a></strong></p><p>不过，此代码存在问题。假设底部的备注发生了变化。 它现在是最近修改过的备注，因此会移到列表顶部，而其他备注都会向下移动一个位置。</p><p>如果没有您的帮助，Compose 不会意识到未更改的项 <em>moved</em>。相反，Compose 会认为旧的“第 2 项”已被删除，且 为第 3 项、第 4 项以及最下面的一项创建了新的订单。其结果是 Compose 会重组列表中的<strong>每一项</strong>，即使其中只有一项重组 实际上都发生了变化</p><p>此处的解决方案是<strong>提供</strong>**<a href="https://developer.android.com/develop/ui/compose/lists?hl=zh-cn#item-keys">项键</a>**。为 每一项都可让 Compose 避免不必要的重组。在本例中，Compose 可以确定现在位于位置 3 的物品与以前位于位置 2 的物品相同。 由于该项的数据没有任何变化，因此 Compose 不必 重组。</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">@Composablefun NotesList(notes: List&lt;Note&gt;) &#123;    LazyColumn &#123;        items(            items &#x3D; notes,            key &#x3D; &#123; note -&gt;                &#x2F;&#x2F; Return a stable, unique key for the note                note.id            &#125;        ) &#123; note -&gt;            NoteRow(note)        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><a href="https://github.com/android/snippets/blob/e9e2f2099c03406170d6b72a7974f6d7658ee8e3/compose/snippets/src/main/java/com/example/compose/snippets/performance/PerformanceSnippets.kt#L104-L117">PerformanceSnippets.kt</a></strong></p><h5 id="使用-derivedStateOf-限制重组"><a href="#使用-derivedStateOf-限制重组" class="headerlink" title="使用 derivedStateOf 限制重组"></a>使用 <code>derivedStateOf</code> 限制重组</h5><p>在组合中使用状态的一个风险是，如果状态发生变化， 界面的重组次数可能会超出您的实际需求。例如： 假设您要显示一个可滚动列表。您可以检查列表的状态， 哪个项是列表中的第一个可见项：</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">val listState &#x3D; rememberLazyListState()LazyColumn(state &#x3D; listState) &#123;    &#x2F;&#x2F; ...&#125;val showButton &#x3D; listState.firstVisibleItemIndex &gt; 0AnimatedVisibility(visible &#x3D; showButton) &#123;    ScrollToTopButton()&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><a href="https://github.com/android/snippets/blob/e9e2f2099c03406170d6b72a7974f6d7658ee8e3/compose/snippets/src/main/java/com/example/compose/snippets/performance/PerformanceSnippets.kt#L126-L136">PerformanceSnippets.kt</a></strong></p><p>问题在于，当用户滚动列表时，<code>listState</code> 会随着用户拖动手指而不断变化。这意味着该列表会不断重组。不过，您不需要频繁重组代码，只需 无需重组，直至新项显示在底部为止。因此，这将完成大量的额外计算，从而导致界面性能较差。</p><p>解决方案是使用<a href="https://developer.android.com/develop/ui/compose/side-effects?hl=zh-cn#derivedstateof">派生状态</a>。借助派生状态，您可以告知 Compose 哪些状态更改实际上应触发重组。在此示例中 指明您在第一个可见项发生更改时您关心。如果<em>那</em> 状态值发生变化时，界面需要重组，但如果用户尚未重组 使新项显示在顶部，则无需重组。</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">val listState &#x3D; rememberLazyListState()LazyColumn(state &#x3D; listState) &#123;    &#x2F;&#x2F; ...&#125;val showButton by remember &#123;    derivedStateOf &#123;        listState.firstVisibleItemIndex &gt; 0    &#125;&#125;AnimatedVisibility(visible &#x3D; showButton) &#123;    ScrollToTopButton()&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><a href="https://github.com/android/snippets/blob/e9e2f2099c03406170d6b72a7974f6d7658ee8e3/compose/snippets/src/main/java/com/example/compose/snippets/performance/PerformanceSnippets.kt#L145-L159">PerformanceSnippets.kt</a></strong></p><h5 id="尽可能延迟读取"><a href="#尽可能延迟读取" class="headerlink" title="尽可能延迟读取"></a>尽可能延迟读取</h5><p>发现性能问题后，延后读取状态会有所帮助。延后读取状态可以确保 Compose 在重组时重新运行尽可能少的代码。例如，如果界面的状态在可组合项树中向上提升，而您在可组合子项中读取状态，则可以将状态封装在 lambda 函数中。这种方式可以确保仅在实际需要时才会执行读取操作。有关参考，请参阅 <a href="https://github.com/android/compose-samples/pull/778">Jetsnack 中的 示例应用</a>。Jetsnack 实现了类似于工具栏的折叠效果 显示详细信息屏幕要了解这种方法起作用的原因，请参阅这篇博文 <a href="https://medium.com/androiddevelopers/jetpack-compose-debugging-recomposition-bfcf4a6f8d37">Jetpack Compose：调试重组</a>。</p><p>为了实现这种效果，<code>Title</code> 可组合项需要滚动偏移 以便使用 <code>Modifier</code> 自行偏移。这是 进行优化之前的 Jetsnack 代码：</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">@Composablefun SnackDetail() &#123;    &#x2F;&#x2F; ...    Box(Modifier.fillMaxSize()) &#123; &#x2F;&#x2F; Recomposition Scope Start        val scroll &#x3D; rememberScrollState(0)        &#x2F;&#x2F; ...        Title(snack, scroll.value)        &#x2F;&#x2F; ...    &#125; &#x2F;&#x2F; Recomposition Scope End&#125;@Composableprivate fun Title(snack: Snack, scroll: Int) &#123;    &#x2F;&#x2F; ...    val offset &#x3D; with(LocalDensity.current) &#123; scroll.toDp() &#125;    Column(        modifier &#x3D; Modifier            .offset(y &#x3D; offset)    ) &#123;        &#x2F;&#x2F; ...    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><a href="https://github.com/android/snippets/blob/e9e2f2099c03406170d6b72a7974f6d7658ee8e3/compose/snippets/src/main/java/com/example/compose/snippets/performance/PerformanceSnippets.kt#L166-L189">PerformanceSnippets.kt</a></strong></p><p>当滚动状态发生变化时，Compose 会使最近的父项失效 重组作用域。在本例中，最接近的范围是 <code>SnackDetail</code> 可组合项。请注意，<code>Box</code> 是内联函数，因此不是重组 范围。因此 Compose 会重组 <code>SnackDetail</code> 以及其中的所有可组合项 <code>SnackDetail</code>。如果您将代码更改为仅读取 使用它，那么您可以减少需要重组的元素数量。</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">@Composablefun SnackDetail() &#123;    &#x2F;&#x2F; ...    Box(Modifier.fillMaxSize()) &#123; &#x2F;&#x2F; Recomposition Scope Start        val scroll &#x3D; rememberScrollState(0)        &#x2F;&#x2F; ...        Title(snack) &#123; scroll.value &#125;        &#x2F;&#x2F; ...    &#125; &#x2F;&#x2F; Recomposition Scope End&#125;@Composableprivate fun Title(snack: Snack, scrollProvider: () -&gt; Int) &#123;    &#x2F;&#x2F; ...    val offset &#x3D; with(LocalDensity.current) &#123; scrollProvider().toDp() &#125;    Column(        modifier &#x3D; Modifier            .offset(y &#x3D; offset)    ) &#123;        &#x2F;&#x2F; ...    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><a href="https://github.com/android/snippets/blob/e9e2f2099c03406170d6b72a7974f6d7658ee8e3/compose/snippets/src/main/java/com/example/compose/snippets/performance/PerformanceSnippets.kt#L195-L217">PerformanceSnippets.kt</a></strong></p><p>滚动参数现在是一个 lambda。这意味着 <code>Title</code> 仍然可以引用提升的状态，但该值仅在 <code>Title</code> 内部读取，这也是实际需要的。因此，当滚动值发生更改时，最近的重组范围现在是 <code>Title</code> 可组合项 - Compose 不再需要重组整个 <code>Box</code>。</p><p>这是一项非常重大的改进，但是您还可以做得更好！<strong>如果您触发重组只是为了重新布局或重新绘制可组合项，那么您肯定会充满了疑惑。</strong>在本例中，您只是更改了 <code>Title</code> 可组合项的偏移量，而此操作可以在布局阶段完成。</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">@Composableprivate fun Title(snack: Snack, scrollProvider: () -&gt; Int) &#123;    &#x2F;&#x2F; ...    Column(        modifier &#x3D; Modifier            .offset &#123; IntOffset(x &#x3D; 0, y &#x3D; scrollProvider()) &#125;    ) &#123;        &#x2F;&#x2F; ...    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><a href="https://github.com/android/snippets/blob/e9e2f2099c03406170d6b72a7974f6d7658ee8e3/compose/snippets/src/main/java/com/example/compose/snippets/performance/PerformanceSnippets.kt#L222-L231">PerformanceSnippets.kt</a></strong></p><p>以前，该代码使用 <code>[Modifier.offset(x: Dp, y: Dp)](https://developer.android.com/reference/kotlin/androidx/compose/foundation/layout/package-summary?hl=zh-cn#(androidx.compose.ui.Modifier).offset(androidx.compose.ui.unit.Dp,androidx.compose.ui.unit.Dp))</code>，它接受 以参数形式指定偏移量通过切换到 <a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/layout/package-summary?hl=zh-cn#(androidx.compose.ui.Modifier).offset(kotlin.Function1)">lambda 版本的修饰符</a>， 您可以确保该函数在布局阶段读取滚动状态。因此，当滚动状态发生变化时，Compose 可以完全跳过组合阶段，而直接进入布局阶段。<strong>当您将频繁更改的状态变量传递到修饰符中时，应当尽可能使用其 lambda 版本。</strong></p><p>下面给出了此方法的另一个示例。此代码尚未优化：</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">&#x2F;&#x2F; Here, assume animateColorBetween() is a function that swaps between&#x2F;&#x2F; two colorsval color by animateColorBetween(Color.Cyan, Color.Magenta)Box(    Modifier        .fillMaxSize()        .background(color))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><a href="https://github.com/android/snippets/blob/e9e2f2099c03406170d6b72a7974f6d7658ee8e3/compose/snippets/src/main/java/com/example/compose/snippets/performance/PerformanceSnippets.kt#L237-L245">PerformanceSnippets.kt</a></strong></p><p>在此代码中，Box 的背景颜色会在两种颜色之间快速切换。因此，其状态也会非常频繁地变化。随后，可组合项会在后台修饰符中读取此状态。因此，该 Box 在每一帧上都需要重组，因为其颜色在每一帧中都会发生变化。</p><p>如需改进这一点，请使用基于 lambda 的修饰符，在本例中为 <code>[drawBehind](https://developer.android.com/reference/kotlin/androidx/compose/ui/draw/package-summary?hl=zh-cn#(androidx.compose.ui.Modifier).drawBehind(kotlin.Function1))</code>。 这将仅在绘制阶段读取颜色状态。因此 Compose 可以完全跳过组合和布局阶段 - Compose 会直接进入绘制阶段。</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">val color by animateColorBetween(Color.Cyan, Color.Magenta)Box(    Modifier        .fillMaxSize()        .drawBehind &#123;            drawRect(color)        &#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><a href="https://github.com/android/snippets/blob/e9e2f2099c03406170d6b72a7974f6d7658ee8e3/compose/snippets/src/main/java/com/example/compose/snippets/performance/PerformanceSnippets.kt#L252-L259">PerformanceSnippets.kt</a></strong></p><h5 id="避免向后写入"><a href="#避免向后写入" class="headerlink" title="避免向后写入"></a>避免向后写入</h5><p>Compose 有一项核心假设，即您<strong>永远不会向已被读取的状态写入数据</strong>。此操作被称为向后写入，它可能会导致无限次地在每一帧上进行重组。</p><p>以下可组合项展示了此类错误的示例。</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">@Composablefun BadComposable() &#123;    var count by remember &#123; mutableStateOf(0) &#125;    &#x2F;&#x2F; Causes recomposition on click    Button(onClick &#x3D; &#123; count++ &#125;, Modifier.wrapContentSize()) &#123;        Text(&quot;Recompose&quot;)    &#125;    Text(&quot;$count&quot;)    count++ &#x2F;&#x2F; Backwards write, writing to state after it has been read&lt;&#x2F;b&gt;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><a href="https://github.com/android/snippets/blob/e9e2f2099c03406170d6b72a7974f6d7658ee8e3/compose/snippets/src/main/java/com/example/compose/snippets/performance/PerformanceSnippets.kt#L265-L276">PerformanceSnippets.kt</a></strong></p><p>此代码会在可组合项的 前一行。如果运行此代码，您会看到按钮，这会导致重组，则计数器会快速增加， 无限循环，因为 Compose 重组此可组合项，看到状态读取 已过期，所以我们安排了另一次重组。</p><p><strong>您完全可以避免向后写入数据，只需避免在组合中写入状态即可。</strong>请尽可能在响应事件时写入状态，并采用 lambda 的形式，如上文中的 <code>onClick</code> 示例所示。</p><ul><li>**<a href="https://developer.android.com/topic/performance/overview?hl=zh-cn">应用性能指南</a>**：探索最佳应用 提升应用性能的方法、库和工具。</li><li>**<a href="https://developer.android.com/topic/performance/inspecting-overview?hl=zh-cn">检查性能</a>**： 检查应用性能。</li><li>**<a href="https://developer.android.com/topic/performance/benchmarking/benchmarking-overview?hl=zh-cn">基准化分析</a>**： 对应用性能进行基准测试。</li><li>**<a href="https://developer.android.com/topic/performance/appstartup/analysis-optimization?hl=zh-cn">应用启动</a>**： 优化应用启动。</li><li>**<a href="https://developer.android.com/baseline-profiles?hl=zh-cn">基准配置文件</a>**：了解基准配置文件。</li></ul><p>其他参考资料：<a href="https://juejin.cn/post/7263341982407868472">Compose:从重组谈谈页面性能优化思路，狠狠优化一笔许多刚入手Compose的使用者遇到卡顿的时候，可能是不恰当的访 - 掘金</a></p><h2 id="Activity-和-Fragment"><a href="#Activity-和-Fragment" class="headerlink" title="Activity 和 Fragment"></a>Activity 和 Fragment</h2><h3 id="2-1-基本概念"><a href="#2-1-基本概念" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h3><table><thead><tr><th>组件</th><th>使用场景</th><th>优势</th></tr></thead><tbody><tr><td>Activity</td><td>作为应用里最关键的界面展示单元，用于打造完整且独立的用户界面屏幕。像应用的启动界面、主要功能模块展示界面等均通过它实现。</td><td>具备完整生命周期，利于资源管理以及与系统交互；能便捷处理用户操作（如按键按下、屏幕触摸等），也能方便地与其他组件（如服务、广播接收器等）进行交互；Android 系统拥有出色的任务栈管理等针对 Activity 的管理机制，方便应用实现导航和多任务处理。</td></tr><tr><td>Fragment</td><td>在构建可复用的 UI 模块时十分适用，尤其在大屏幕设备（如平板电脑）或复杂多屏应用中表现突出。例如新闻应用里，新闻列表 Fragment 能在不同布局（单栏、双栏布局）中复用，也可在多个相关 Activity 中共享。</td><td>极大提升了 UI 的复用性与灵活性，可依据不同设备配置和屏幕尺寸，灵活组合与替换以达成不同布局效果；Fragment 拥有独立逻辑和视图，便于团队开发与代码维护，不同开发人员可分别负责不同 Fragment 的开发工作 。</td></tr><tr><td>Compose</td><td>适合快速搭建现代化、动态的 UI 界面，对于需要频繁更新 UI 或处理复杂状态管理的应用部分效果显著。比如在实时数据更新（如股票行情应用）或复杂交互（如手势操作驱动 UI 变化）的应用场景中能发挥优势。</td><td>代码更为简洁直观，采用声明式方式构建 UI，降低了传统视图体系中视图操作和状态管理的复杂程度；自动重组机制极大简化 UI 更新流程，提高开发效率；提供丰富的布局和组件库，助力开发者快速实现各类 UI 设计。</td></tr></tbody></table><h3 id="2-2-生命周期"><a href="#2-2-生命周期" class="headerlink" title="2.2 生命周期"></a>2.2 生命周期</h3><table><thead><tr><th>生命周期方法</th><th>调用时机</th><th></th></tr></thead><tbody><tr><td><code>onCreate()</code></td><td>在Activity第一次被创建时调用。通常用于进行初始化操作，如设置布局（通过<code>setContentView</code>或<code>setContent</code>）、初始化视图组件、绑定数据等。</td><td></td></tr><tr><td><code>onStart()</code></td><td>在Activity即将对用户可见时调用。此时Activity已经可见，但还没有获取焦点，用户还不能与之交互。</td><td></td></tr><tr><td><code>onResume()</code></td><td>在Activity获取焦点，用户可以开始与之交互时调用。此时Activity处于活动状态，位于前台。</td><td></td></tr><tr><td><code>onPause()</code></td><td>当系统准备启动或恢复另一个 Activity 时调用。此时当前 Activity 失去焦点，但仍然部分可见。例如，当一个透明或者半透明的 Activity 启动时，原 Activity 就会进入<code>onPause</code>状态。这是一个比较关键的回调，通常用于暂停一些资源消耗大的操作，如暂停动画、停止视频播放等，并且可以保存一些关键数据，防止用户离开该页面后数据丢失或资源浪费。</td><td></td></tr></tbody></table><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">class MainActivity : AppCompatActivity() &#123;    override fun onPause() &#123;        super.onPause()        &#x2F;&#x2F; 暂停视频播放        videoPlayer.pause()        &#x2F;&#x2F; 保存当前页面的编辑状态        val editTextContent &#x3D; editText.text.toString()        savedState.editTextContent &#x3D; editTextContent    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> |<br>|<code>onStop()</code> |当 Activity 完全不可见时调用。比如用户打开了一个新的 Activity，并且这个新 Activity 完全覆盖了当前 Activity，或者用户按下了 “Home” 键将应用退到后台，当前 Activity 就会进入<code>onStop</code>状态。这个回调可以用于释放一些只有在 Activity 可见时才需要的资源，如停止传感器的监听等。 |</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">class SensorActivity : AppCompatActivity() &#123;    private val sensorManager: SensorManager by lazy &#123;        getSystemService(Context.SENSOR_SERVICE) as SensorManager    &#125;    private val accelerometer: Sensor by lazy &#123;        sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER)    &#125;    private val sensorEventListener &#x3D; object : SensorEventListener &#123;        &#x2F;&#x2F; 处理传感器事件的方法    &#125;    override fun onStart() &#123;        super.onStart()        sensorManager.registerListener(sensorEventListener, accelerometer, SensorManager.SENSOR_DELAY_NORMAL)    &#125;    override fun onStop() &#123;        super.onStop()        sensorManager.unregisterListener(sensorEventListener)    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> |<br>|<code>onDestroy()</code> |在Activity被销毁之前调用。用于释放所有占用的资源，如关闭数据库连接、停止服务、注销广播接收器等。 | |<br>|<code>onRestart()</code> |在Activity被停止后，再次启动时调用。它会在<code>onStart()</code>之前被触发，通常用于在Activity重新启动时恢复之前保存的状态。 | |</p><p>Activty 仅关注于自身，如果需要全局的生命周期监听，可能需要使用 ProcessLifecycleOwner。它对于简单地判断应用整体是处于前台还是后台的场景非常方便。例如，在一些需要根据应用前后台状态来调整服务行为的应用中，像应用进入后台时暂停数据同步服务，进入前台时恢复数据同步服务，使用<code>ProcessLifecycleOwner</code>可以快速实现。</p><p>当应用架构基于现代的 Jetpack 组件（如 ViewModel、LiveData 等），并且已经在使用<code>lifecycle - runtime - ktx</code>库来管理组件生命周期时，<code>ProcessLifecycleOwner</code>能够很好地集成到现有的架构中，以一种简洁的方式提供应用生命周期感知。</p><p>首先我们需要先注册（在未注册 <code>lifecycle - runtime - ktx</code> 的情况下）：</p><pre class="line-numbers language-Groovy" data-language="Groovy"><code class="language-Groovy">dependencies &#123;    implementation &#39;androidx.lifecycle:lifecycle-runtime-ktx:2.6.0&#39;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们对比两者的生命周期：</p><table><thead><tr><th>对比维度</th><th>Activity 生命周期</th><th>ProcessLifecycleOwner 生命周期</th></tr></thead><tbody><tr><td>关注对象</td><td>单个Activity从创建到销毁过程中的不同状态变化，比如是否可见、是否可交互等。</td><td>整个应用进程处于前台还是后台的宏观状态。</td></tr><tr><td>关键状态及回调</td><td><code>onCreate</code>：首次创建时调用，用于初始化操作。<code>onStart</code>：即将对用户可见时调用。<code>onResume</code>：获取焦点，可与用户交互时调用。<code>onPause</code>：失去焦点但可能部分可见时调用。<code>onStop</code>：完全不可见时调用。<code>onDestroy</code>：被销毁前调用，用于释放资源。<code>onRestart</code>：停止后再次启动时调用。</td><td><code>ON_START</code>：当应用中有一个Activity进入<code>onStart</code>状态，意味着应用进入前台，触发此事件。<code>ON_STOP</code>：当应用中的最后一个Activity进入<code>onStop</code>状态，意味着应用进入后台，触发此事件。</td></tr><tr><td>触发条件</td><td>由Activity自身在屏幕上的可见性、交互性变化等因素触发，例如启动、切换、按“Home”键等操作导致相应状态改变时触发对应回调。</td><td>通过监测应用内所有Activity的整体状态来触发，关注是否还有Activity处于可见状态（<code>ON_START</code>）或者所有Activity都不可见了（<code>ON_STOP</code>）。</td></tr><tr><td>使用场景</td><td>用于管理单个Activity内的资源初始化、释放，处理Activity自身相关的UI更新、交互逻辑等。例如在<code>onPause</code>暂停视频播放，在<code>onResume</code>恢复播放。</td><td>用于处理应用整体进入前台或后台时的通用逻辑，比如应用进入后台暂停数据同步、传感器监听等服务，进入前台时恢复这些操作。</td></tr><tr><td>代码示例（Kotlin） - 简单示意</td><td></td><td></td></tr></tbody></table><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">class MyActivity : AppCompatActivity() &#123;    override fun onCreate(savedInstanceState: Bundle?) &#123;        super.onCreate(savedInstanceState)        &#x2F;&#x2F; 初始化布局等操作    &#125;    override fun onStart() &#123;        super.onStart()        &#x2F;&#x2F; 准备显示相关操作    &#125;    override fun onResume() &#123;        super.onResume()        &#x2F;&#x2F; 获取焦点，可交互操作    &#125;    override fun onPause() &#123;        super.onPause()        &#x2F;&#x2F; 失去焦点，暂停相关操作    &#125;    override fun onStop() &#123;        super.onStop()        &#x2F;&#x2F; 完全不可见，释放部分资源    &#125;    override fun onDestroy() &#123;        super.onDestroy()        &#x2F;&#x2F; 释放所有资源    &#125;    override fun onRestart() &#123;        super.onRestart()        &#x2F;&#x2F; 重新启动相关操作    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> |</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">import android.os.Bundleimport android.util.Logimport androidx.appcompat.app.AppCompatActivityimport androidx.lifecycle.DefaultLifecycleObserverimport androidx.lifecycle.LifecycleOwnerimport androidx.lifecycle.ProcessLifecycleOwnerclass MyActivity : AppCompatActivity() &#123;    override fun onCreate(savedInstanceState: Bundle?) &#123;        super.onCreate(savedInstanceState)        &#x2F;&#x2F; 使用代码块形式添加生命周期观察者        ProcessLifecycleOwner.get().lifecycle.addObserver(object : DefaultLifecycleObserver &#123;            override fun onStop(owner: LifecycleOwner) &#123;                super.onStop(owner)                Log.d(&quot;MyApp&quot;, &quot;App moved to background&quot;)            &#125;            override fun onStart(owner: LifecycleOwner) &#123;                super.onStart(owner)                Log.d(&quot;MyApp&quot;, &quot;App moved to foreground&quot;)            &#125;        &#125;)    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> |</p><h3 id="2-3-路由与路由数据传递"><a href="#2-3-路由与路由数据传递" class="headerlink" title="2.3 路由与路由数据传递"></a>2.3 路由与路由数据传递</h3><h4 id="2-3-1-Intent-机制与数据传递"><a href="#2-3-1-Intent-机制与数据传递" class="headerlink" title="2.3.1 Intent 机制与数据传递"></a>2.3.1 Intent 机制与数据传递</h4><p><code>Parcel</code> 是 Android 中用于序列化和反序列化对象的一种机制，在传递对象（如通过 <code>Intent</code> 传递）时，对象需要被拆解成可以存储和传输的形式（序列化），<strong>在接收端再重新组装成对象（反序列化）。</strong></p><p>我们创建一个表示用户信息的 <code>User</code> 数据类，并让它实现 <code>Parcelable</code> 接口，以便可以通过 <code>Intent</code> 传递。</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">import android.os.Parcelimport android.os.Parcelabledata class User(    val id: String,    val name: String,    val age: Int) : Parcelable &#123;    &#x2F;&#x2F; 这个构造函数就是在接收端从 Parcel 中读取数据来重新创建 User 对象。    constructor(parcel: Parcel) : this(        parcel.readString()!!,        parcel.readString()!!,        parcel.readInt()    )    override fun writeToParcel(parcel: Parcel, flags: Int) &#123;        parcel.writeString(id)        parcel.writeString(name)        parcel.writeInt(age)    &#125;    override fun describeContents(): Int &#123;        return 0    &#125;    companion object CREATOR : Parcelable.Creator&lt;User&gt; &#123;        override fun createFromParcel(parcel: Parcel): User &#123;            return User(parcel)        &#125;        override fun newArray(size: Int): Array&lt;User?&gt; &#123;            return arrayOfNulls(size)        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>writeToParcel</code> 方法：<ul><li><code>override fun writeToParcel(parcel: Parcel, flags: Int)</code> 负责将 <code>User</code> 对象的各个属性写入到 <code>Parcel</code> 中，以便进行传递。在这个方法里，按照顺序分别调用了 <code>parcel.writeString(id)</code>、<code>parcel.writeString(name)</code> 和 <code>parcel.writeInt(age)</code>，也就是把 <code>id</code>、<code>name</code> 和 <code>age</code> 这三个属性的值依次写入 <code>Parcel</code>，确保在接收端能够按照同样的顺序正确读取并恢复对象。</li></ul></li><li><code>CREATOR</code> 伴生对象及相关方法：<ul><li><code>companion object CREATOR : Parcelable.Creator&lt;User&gt;</code> 是 <code>Parcelable</code> 接口要求实现的一个伴生对象，用于创建 <code>User</code> 类的实例。其中包含两个方法：<ul><li><code>override fun createFromParcel(parcel: Parcel): User</code> 方法会在反序列化时被调用，它的任务就是利用前面提到的从 <code>Parcel</code> 中读取数据的构造函数（<code>constructor(parcel: Parcel)</code>）来创建一个新的 <code>User</code> 对象，也就是返回 <code>User(parcel)</code>。</li><li><code>override fun newArray(size: Int): Array&lt;User?&gt;</code> 方法用于创建一个指定大小的 <code>User</code> 数组，在一些涉及到数组形式的 <code>Parcelable</code> 对象传递场景下会用到，这里简单地返回了一个包含 <code>null</code> 值的指定大小的数组，即 <code>arrayOfNulls(size)</code>。</li></ul></li></ul></li></ul><p>定义两个 Activity，一个是主页面，另一个是用户详情页。主页面包含一个按钮，点击按钮后通过路由导航到用户详情页面，并传递用户数据。</p><p>主页面 Activity 使用 Compose 来构建 UI。</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">class MainActivity : androidx.activity.ComponentActivity() &#123;    override fun onCreate(savedInstanceState: Bundle?) &#123;        super.onCreate(savedInstanceState)        setContent &#123;            MyApplicationTheme &#123;                Surface(                    &#x2F;&#x2F; 省略                ) &#123;&lt;mark style&#x3D;&quot;background-color: #FFE928&quot;&gt;                    &#x2F;&#x2F; 创建路由 Controller&lt;&#x2F;mark&gt;&lt;mark style&#x3D;&quot;background-color: #FFE928&quot;&gt;                    val navController &#x3D; rememberNavController()&lt;&#x2F;mark&gt;&lt;mark style&#x3D;&quot;background-color: #FFE928&quot;&gt;                    &#x2F;&#x2F; 创建 User 对象，在 MainScreen 中跳转时传入 Navigator&lt;&#x2F;mark&gt;&lt;mark style&#x3D;&quot;background-color: #FFE928&quot;&gt;                    val user &#x3D; User(&quot;1&quot;, &quot;John Doe&quot;, 30)&lt;&#x2F;mark&gt;&lt;mark style&#x3D;&quot;background-color: #FFE928&quot;&gt;                    MainScreen(navController, user)&lt;&#x2F;mark&gt;&lt;mark style&#x3D;&quot;background-color: #FFE928&quot;&gt;                    SetupNavigation(navController)&lt;&#x2F;mark&gt;                &#125;            &#125;        &#125;    &#125;&#125;@Composablefun MainScreen(navController: NavController, user: User) &#123;    Column &#123;        Text(text &#x3D; &quot;主页面&quot;)        Button(onClick &#x3D; &#123;&lt;mark style&#x3D;&quot;background-color: #FFE928&quot;&gt;            &#x2F;&#x2F; 跳转其它页面&lt;&#x2F;mark&gt;&lt;mark style&#x3D;&quot;background-color: #FFE928&quot;&gt;            navController.navigate(&quot;user_detail&#x2F;$user&quot;)&lt;&#x2F;mark&gt;        &#125;) &#123;            Text(text &#x3D; &quot;查看用户详情&quot;)        &#125;    &#125;&#125;@Composablefun SetupNavigation(navController: NavController) &#123;    NavHost(        navController &#x3D; navController,        startDestination &#x3D; &quot;main&quot;    ) &#123;        composable(&quot;main&quot;) &#123;            val navBackStackEntry &#x3D; it.currentBackStackEntryAsState().value            val context &#x3D; LocalContext.current            val user &#x3D; navBackStackEntry?.arguments?.getParcelable&lt;User&gt;(&quot;user&quot;)            MainScreen(navController, user?: User(&quot;default&quot;, &quot;Default User&quot;, 0))        &#125;        composable(            route &#x3D; &quot;user_detail&#x2F;&#123;user&#125;&quot;,            arguments &#x3D; listOf(navArgument(&quot;user&quot;) &#123; type &#x3D; NavType.ParcelableType(User::class.java) &#125;)        ) &#123; backStackEntry -&gt;            val receivedUser &#x3D; backStackEntry.arguments?.getParcelable&lt;User&gt;(&quot;user&quot;)            UserDetailScreen(receivedUser)        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 <code>MainActivity</code> 的 <code>SetupNavigation</code> 这个可组合函数中，通过 <code>NavHost</code> 来定义整个应用的导航结构。</p><ul><li><code>NavHost</code> 函数接受 <code>navController</code>（用于控制导航操作）和 <code>startDestination</code>（指定起始的导航页面）作为参数。这里起始页面设置为 <code>&quot;main&quot;</code>。</li><li>在 <code>NavHost</code> 内部，通过 <code>composable</code> 函数来定义各个具体的可导航页面。<ul><li>对于 <code>&quot;main&quot;</code> 页面：<ul><li>首先通过 <code>it.currentBackStackEntryAsState().value</code> 获取当前导航栈的状态信息，进而可以获取传递过来的参数（在这个例子中可能是 <code>User</code> 对象）。</li><li>然后将获取到的 <code>User</code> 对象（或者默认的用户对象，如果没有传递过来有效的对象）传递给 <code>MainScreen</code> 可组合函数来展示主页面的 UI 内容。</li></ul></li><li>对于 <code>&quot;user_detail/&#123;user&#125;&quot;</code> 页面：<ul><li>定义了路由参数 <code>&quot;user&quot;</code>，并且指定其类型为 <code>NavType.ParcelableType(User::class.java)</code>，这样就能接收通过路由传递过来的 <code>User</code> 类型的对象。</li><li>在页面的可组合函数内（通过 <code>backStackEntry</code> 获取参数），将接收到的 <code>User</code> 对象传递给 <code>UserDetailScreen</code> 可组合函数来展示用户详情页面的 UI 内容。</li></ul></li></ul></li></ul><p>之后我们再定义一个用户详情 Activity，同样使用 Compose 构建 UI，用于展示接收到的用户信息，并在页面重建（如屏幕旋转等情况）时恢复数据展示。</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">class UserDetailActivity : androidx.activity.ComponentActivity() &#123;    override fun onCreate(savedInstanceState: Bundle?) &#123;        super.onCreate(savedInstanceState)        setContent &#123;            MyApplicationTheme &#123;                Surface(                    &#x2F;&#x2F; 省略                ) &#123;&lt;mark style&#x3D;&quot;background-color: #FAF390&quot;&gt;                    &#x2F;&#x2F; 从 savedInstanceState  或者 Intent 中获取 User，并加载 UI&lt;&#x2F;mark&gt;&lt;mark style&#x3D;&quot;background-color: #FAF390&quot;&gt;                    val user &#x3D; if (savedInstanceState &#x3D;&#x3D; null) &#123;&lt;&#x2F;mark&gt;&lt;mark style&#x3D;&quot;background-color: #FAF390&quot;&gt;                        intent.getParcelableExtra(&quot;user&quot;)&lt;&#x2F;mark&gt;&lt;mark style&#x3D;&quot;background-color: #FAF390&quot;&gt;                    &#125; else &#123;&lt;&#x2F;mark&gt;&lt;mark style&#x3D;&quot;background-color: #FAF390&quot;&gt;                        savedInstanceState.getParcelable(&quot;user&quot;)&lt;&#x2F;mark&gt;&lt;mark style&#x3D;&quot;background-color: #FAF390&quot;&gt;                    &#125;&lt;&#x2F;mark&gt;&lt;mark style&#x3D;&quot;background-color: #FAF390&quot;&gt;                    UserDetailScreen(user)&lt;&#x2F;mark&gt;                &#125;            &#125;        &#125;    &#125;    &#x2F;&#x2F; 使用 onSaveInstanceState 进行数据恢复    override fun onSaveInstanceState(outState: Bundle) &#123;        super.onSaveInstanceState(outState)        val user &#x3D; intent.getParcelableExtra(&quot;user&quot;)        outState.putParcelable(&quot;user&quot;, user)    &#125;&#125;@Composablefun UserDetailScreen(user: User?) &#123;    var currentUser by remember &#123; mutableStateOf(user) &#125;    LaunchedEffect(key1 &#x3D; user) &#123;        currentUser &#x3D; user    &#125;    Column &#123;        Text(text &#x3D; &quot;用户详情页面&quot;)        currentUser?.let &#123;            Text(text &#x3D; &quot;姓名: $&#123;it.name&#125;&quot;)            Text(text &#x3D; &quot;年龄: $&#123;it.age&#125;&quot;)        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>给到的例子中充分体现了「数据传递」和「数据恢复」两大功能：</p><ul><li>数据传递：从主页面传递 <code>User</code> 对象到用户详情页面时，在 <code>MainScreen</code> 中通过 <code>navController.navigate</code> 把对象放在路由路径里传递，在 <code>SetupNavigation</code> 中针对 <code>&quot;user_detail/&#123;user&#125;&quot;</code> 路由定义的地方，正确地解析并获取传递过来的 <code>User</code> 对象，然后传递给 <code>UserDetailScreen</code> 用于展示。</li><li>数据恢复：在 <code>UserDetailActivity</code> 的 <code>onSaveInstanceState</code> 方法中，依然将接收到的 <code>User</code> 对象保存到 <code>outState</code> 中，以便在页面重建（如屏幕旋转等情况）时能恢复数据。在 <code>UserDetailScreen</code> 可组合函数里，使用 <code>LaunchedEffect</code> 和 <code>remember</code> 等 Compose 特性来处理数据变化，确保当接收到新的用户数据（比如页面重建后恢复的数据）时能正确更新 UI 展示，以此提供良好的用户体验。</li></ul><h4 id="2-3-2-XML、Compose-Navigation-DSL-管理路由"><a href="#2-3-2-XML、Compose-Navigation-DSL-管理路由" class="headerlink" title="2.3.2 XML、Compose Navigation DSL 管理路由"></a>2.3.2 XML、Compose Navigation DSL 管理路由</h4><p>部分老旧项目中仍然使用 XML 管理路由。例如上个 case 就可以像这样使用路由：</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;navigation xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;    xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;app&quot;    xmlns:tools&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;tools&quot;    app:startDestination&#x3D;&quot;main&quot;&gt;    &lt;composable        android:id&#x3D;&quot;main&quot;        android:name&#x3D;&quot;com.example.myapplication.MainScreen&quot;        app:route&#x3D;&quot;main&quot;&gt;    &lt;&#x2F;composable&gt;    &lt;composable        android:id&#x3D;&quot;user_detail&quot;        android:name&#x3D;&quot;com.example.myapplication.UserDetailScreen&quot;        app:route&#x3D;&quot;user_detail&#x2F;&#123;user&#125;&quot;        app:arguments&#x3D;&quot;@array&#x2F;user_detail_arguments&quot;&gt;    &lt;&#x2F;composable&gt;    &lt;action        android:id&#x3D;&quot;action_main_to_user_detail&quot;        app:destination&#x3D;&quot;@id&#x2F;user_detail&quot;        app:popUpTo&#x3D;&quot;@id&#x2F;main&quot;        app:popUpToInclusive&#x3D;&quot;false&quot;&gt;    &lt;&#x2F;action&gt;    &lt;!-- 其他相关配置 --&gt;&lt;&#x2F;navigation&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>传统项目和大型团队协作场景</strong>：在一些已经存在的大型Android项目中，XML路由管理仍然被广泛使用。这些项目可能有较长的开发周期和复杂的团队协作结构。XML提供了一种清晰、易于理解的方式来定义整个应用的导航架构，不同的开发人员可以通过查看XML文件快速了解页面之间的跳转关系。例如，一个拥有多个模块和众多Activity的金融类应用，使用XML来定义路由可以使得模块之间的导航逻辑一目了然。</li><li><strong>与 Android 原生组件集成场景</strong>：当应用需要深度集成Android原生的组件（如通知栏跳转、系统快捷方式跳转等）时，XML路由管理可以更好地与系统原生的Intent机制相结合。例如，通过在XML中定义好的路由路径，当用户点击通知栏中的消息时，系统可以根据XML中的配置准确地跳转到应用内对应的页面。</li></ul><p><strong>Compose Navigation DSL 是逐渐兴起的替代方案或补充方式。</strong></p><ul><li><strong>代码驱动的路由管理（如Compose Navigation DSL）</strong>：在使用Jetpack Compose构建UI的项目中，Compose Navigation DSL提供了一种代码驱动的路由管理方式。开发者可以通过编写Kotlin代码来定义导航图，这种方式更加灵活，并且与Compose的编程风格紧密结合。例如，在一个完全基于Compose构建的小型工具类应用中，通过代码定义路由可以使导航逻辑与UI组件的构建更加紧密地集成在一起。</li><li><strong>动态路由管理（基于运行时条件）</strong>：有些应用需要根据用户权限、设备状态或者业务逻辑动态地生成路由路径。在这种情况下，代码中动态构建路由的方式就显得更加合适。比如，一个具有用户角色权限系统的企业级应用，不同角色的用户登录后，根据其权限动态生成不同的导航菜单和路由路径，这种情况下通过代码动态控制路由比固定的XML路由更加灵活。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Android" scheme="https://blog.pengdonglai.com/categories/Android/"/>
    
    <category term="UI" scheme="https://blog.pengdonglai.com/categories/Android/UI/"/>
    
    
    <category term="Android" scheme="https://blog.pengdonglai.com/tags/Android/"/>
    
    <category term="Kotlin" scheme="https://blog.pengdonglai.com/tags/Kotlin/"/>
    
    <category term="Jetpack Compose" scheme="https://blog.pengdonglai.com/tags/Jetpack-Compose/"/>
    
    <category term="Activity" scheme="https://blog.pengdonglai.com/tags/Activity/"/>
    
  </entry>
  
  <entry>
    <title>N2 日语部分语法点归总（1）</title>
    <link href="https://blog.pengdonglai.com/2024/09/17/japanese-grammar-3/"/>
    <id>https://blog.pengdonglai.com/2024/09/17/japanese-grammar-3/</id>
    <published>2024-09-17T02:35:41.000Z</published>
    <updated>2024-10-09T15:42:34.913Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><button class="btn-small waves-effect waves-light" id="toggleButton">变更测试模式</button></p><script>  let usingHeimu = true;  document.getElementById('toggleButton').addEventListener('click', () => {    usingHeimu = !usingHeimu;    const spans = document.querySelectorAll('span.heimu, span.no-heimu');    spans.forEach(span => {      if (usingHeimu) {        span.classList.remove('no-heimu');        span.classList.add('heimu');      } else {        span.classList.remove('heimu');        span.classList.add('no-heimu');      }    });  });</script><blockquote><p>本文来自于 bilibili UP 主 <a href="https://space.bilibili.com/548121510">当当_suzu</a> 的 <a href="https://www.bilibili.com/video/BV1yY411b7zY">N2 系列视频</a>，这套视频是我见过 N2 系列语法视频中讲的最全的版本，如果有可能大家请尽可能支持原作者！</p><p>本文内容来自于该系列视频讲义。如有侵犯著作权的行为请联系我及时删除。</p></blockquote><h2 id="知识点快速过"><a href="#知识点快速过" class="headerlink" title="知识点快速过"></a>知识点快速过</h2><h3 id="表示评价、判断"><a href="#表示评价、判断" class="headerlink" title="表示评价、判断"></a>表示评价、判断</h3><table><thead><tr><th>含义&#x2F;假名类</th><th>はず</th><th>わけ</th><th>もの</th><th>べき&#x2F;こと</th><th>包含汉字词</th><th>其它</th></tr></thead><tbody><tr><td>应该</td><td>はずだ（有把握的推测）</td><td>わけだ（自然而然的）</td><td>ものだ（道理，常识）</td><td>べきだ（主张）、ことだ（劝告，要求）</td><td>と見える（可见，看来）</td><td>でなくてなんだろう（不是..又是什么呢？）</td></tr><tr><td>一定，表肯定</td><td></td><td></td><td>というものだ “才真是”，表肯定强调</td><td></td><td>に相違ない、に決まっている、に違いない</td><td>にほかならない（正是、不外乎）</td></tr><tr><td>确实是</td><td></td><td></td><td>ものがある 确实是（有这样的特性）</td><td></td><td></td><td></td></tr><tr><td>不应该</td><td>はずがない</td><td>わけがない（没有可能）</td><td>ものではない 不该（违反常识）</td><td></td><td></td><td></td></tr><tr><td>不可能</td><td></td><td></td><td>ものか 表强烈否定，“怎么可能”</td><td></td><td></td><td></td></tr><tr><td>并不是，并非</td><td></td><td>わけではない・わけでもない（并不是、并非）</td><td>というものではない 并不是</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td>というわけではない</td><td></td><td></td><td></td><td></td></tr><tr><td>不能</td><td></td><td>わけにはいかない 不能（受到约束和限制）</td><td></td><td></td><td></td><td></td></tr><tr><td>令人…的是</td><td></td><td></td><td></td><td>ことに</td><td></td><td></td></tr><tr><td>不必</td><td></td><td></td><td></td><td>ことはない</td><td></td><td></td></tr><tr><td>只不过</td><td></td><td></td><td></td><td></td><td></td><td>にすぎない（只不过，强调程度低）</td></tr></tbody></table><p>表示语气：</p><ul><li>～ものだ 表示感叹；</li><li>～たいものだ 表示强烈的愿望；「真想」</li><li>～たものだ 表回忆，过去经常，「总是」</li><li>～のではない（だろか）か &#x3D;&#x3D;否定+疑问（表肯定）&#x3D;&#x3D; …吧（委婉语气）</li></ul><p>表示比较：</p><ul><li>～ほど～ない 没那么…</li><li>～ほど～はない 没有比…更…</li></ul><h3 id="表示时间"><a href="#表示时间" class="headerlink" title="表示时间"></a>表示时间</h3><table><thead><tr><th><strong>正好要</strong></th><th><strong>正在做</strong></th><th><strong>刚做完</strong></th><th><strong>同时做（一件事情在做时）</strong></th><th><strong>一…就</strong></th><th><strong>…之后</strong></th><th><strong>…的时候（值此之际）</strong></th><th><strong>每次（表示频率）</strong></th></tr></thead><tbody><tr><td>～ところだ</td><td>～（ている）ところだ</td><td>～（た）ところ</td><td>～ついでに<br>顺便做某事</td><td>～か～ないかのうちに<br>刚一…就（要完未完之时）</td><td>～うえで</td><td>～にあたって<br>～にあたり</td><td>～たびに</td></tr><tr><td>～ところだ（に、へ）</td><td>～最中<br>正在…的时候（鼎盛期）</td><td></td><td>～うちに<br>趁着（不用于未来）<br>在…的过程中</td><td>～かと思うと<br>～かと思うったら<br>一…就（出乎意料）<br>原以为…（出乎意料）</td><td>～て以来</td><td>～際、～に際し<br>に際して</td><td>（N3）～ごとに</td></tr><tr><td>～ところを<br>即将（表示不利状况）<br>表示尊敬</td><td></td><td></td><td></td><td>～た途端（に）</td><td>～てはじめて</td><td>～をきっかけにして</td><td>（N3）～おきに</td></tr><tr><td></td><td></td><td></td><td></td><td>～次第<br>一…就、取决于…</td><td></td><td>～を契機として<br>～を機に</td><td></td></tr></tbody></table><h2 id="前置知识：活用接续概念"><a href="#前置知识：活用接续概念" class="headerlink" title="前置知识：活用接续概念"></a>前置知识：活用接续概念</h2><h3 id="体言VS用言"><a href="#体言VS用言" class="headerlink" title="体言VS用言"></a>体言VS用言</h3><p>日语中，用言和体言的区别，最根本的区别就是两者内容和用法不同，</p><p>体言：名词、代名词、数词</p><p>用言：动词，形容词，形容动词</p><p>体言的特点：</p><p>1、体言是没有活用（即词尾变化）的独立词。</p><p>2、体言可以后接助词が（は、も等）构成主语，这是体言最大的特点。</p><p>3、体言可以后接助词构成连体修饰语、连用修饰语等，还可以后接断定助动词だ（です）等构成谓语。</p><p>4、体言前面可以加连体修饰语。</p><p>用言的特点：</p><p>1、用言是 有活用（即词尾变化）的独立词。</p><p>2、用言 可以单独构成谓语，这是用言最大的特点。</p><p>3、用言 可以通过自身的词尾变化构成连体修饰语、连用修饰语。</p><p>4、用言前面可以加连用修饰语。</p><h3 id="活用形简述"><a href="#活用形简述" class="headerlink" title="活用形简述"></a>活用形简述</h3><p>简体形、终止形、连体形、连用形、中顿形指的并非某种具体的形式，而是根据接续功能的不同，把一系列活用形式汇总到一起的总称。他们的接续功能如下：</p><ul><li><p>简体形，是用来体现词的核心部分。</p></li><li><p>终止形，是用来放到句末来结句。</p></li><li><p>连体形，是用来修饰名词。</p></li><li><p>连用形，是用来连接其他用言（具体包括动词、形容词、形容动词）。</p></li><li><p>中顿形，是用来连接后半句话。</p></li></ul><p>对于动词而言，“简体形”具体包括：表非过去肯定的辞书形、表过去肯定的た形、表非过去否定的ない形、以及表过去否定的なかった形，共四种。因为这四种形式均可以放在句末结句，也可以直接放在名词前做定语，所以“终止形”即“简体形”，“连体形”也为“简体形”。而动词的“连用形”和“中顿形”一致，ます形去ます和て形均可使用。</p><p>对于形容词而言，简体形同样是四种。因为这四种形式均可以放在句末结句，也可以直接放在名词前做定语，所以“终止形”即“简体形”，“连体形”也为“简体形”。连用形和中顿形是く或くて。</p><p>对于形容动词而言，简体形是词干本身，终止形是词干+だ・である，以及引申出的过去和否定。而连体形是词干+な，连用形和中顿形是で、であり。</p><p>对于名词而言，简体形是词干本身，终止形是词干+だ・である，以及由此引申出的过去和否定。而连体形最常用的是词干+の，也会遇到词干+だった或である的情况，连用形和中顿形是词干+で・であり。</p><h2 id="第一部分：判断、評価"><a href="#第一部分：判断、評価" class="headerlink" title="第一部分：判断、評価"></a>第一部分：判断、評価</h2><h3 id="1-～はずだ"><a href="#1-～はずだ" class="headerlink" title="1. ～はずだ"></a>1. ～はずだ</h3><p>接続：連体形、名詞＋の</p><p>意味：<span class="heimu">应该（有把握的推测）</span></p><p>例文：</p><p>会議は2時に始まるはずです。<span class="heimu">会议应该2点开始。</span></p><p>妹は今年卒業のはずです。<span class="heimu">妹妹应该今年毕业了。</span></p><p><span class="heimu">そのこともう彼に話しましたから、彼は知っているはずだ。</span>那件事情已经跟他说过了，他应该知道。</p><h3 id="2-～はずがない"><a href="#2-～はずがない" class="headerlink" title="2. ～はずがない"></a>2. ～はずがない</h3><p>接続：連体形</p><p>意味：<span class="heimu">不应该</span></p><p>例文：</p><p>夏休み中だから、彼女は忙しいはずがない。<span class="heimu">现在放暑假，她不应该很忙。</span></p><p><span class="heimu">あの人は日本に10年も住んでいるから、日本語が分からないはずがない。</span>那个人在日本住了10年，不可能不懂日语。</p><h3 id="3-～わけだ"><a href="#3-～わけだ" class="headerlink" title="3. ～わけだ"></a>3. ～わけだ</h3><p>接続：連体形</p><p>意味：<span class="heimu">应该（自然而然的应该）；难怪</span></p><p>例文：</p><p>10年もう日本にいたから、日本語が上手なわけだ。<span class="heimu">在日本也10年了，日语应该很熟练了。</span></p><p><span class="heimu">子供さえわかるような問題だったので、自然にすぐ答えられたわけです。</span>是个连孩子都明白的问题，自然立刻就回答上来了。</p><h3 id="4-～わけがない"><a href="#4-～わけがない" class="headerlink" title="4. ～わけがない"></a>4. ～わけがない</h3><p>&#x3D;&#x3D;わけない</p><p>接続：連体形</p><p>意味：<span class="heimu">没有可能这样</span></p><p>例文：</p><p>そんなやさしい彼がそんなことをするわけがない。<span class="heimu">他那么温柔，没有可能做这种事。</span></p><p><span class="heimu">とても難し問題ので、誰にも答えられるわけがない。</span>是个非常难的问题，所以谁都不可能答得出来。</p><h3 id="5-～わけではない・わけでもない"><a href="#5-～わけではない・わけでもない" class="headerlink" title="5. ～わけではない・わけでもない"></a>5. ～わけではない・わけでもない</h3><p>接続：連体形</p><p>意味：<span class="heimu">并不是、并非</span></p><p>例文：</p><p>お酒が嫌いなわけでもないが、医者に注意されたので飲まないことにしている。<span class="heimu">并不是不喜欢酒，只是医生要求注意不能喝。</span></p><p><span class="heimu">このクラスの学生は全員まじめに勉強するわけではない。</span>这个班的学生并非都好好学习。</p><h3 id="6-～というわけではない"><a href="#6-～というわけではない" class="headerlink" title="6. ～というわけではない"></a>6. ～というわけではない</h3><p>接続：用言辞書型、体言</p><p>意味：<span class="heimu">并不是</span></p><p>例文：</p><p>n+次第：取决于</p><p>必ずしも：并非，不一定；后面会经常搭配表示「未必」的固定搭配。</p><p>能力次第に。必ずしも大学卒というわけではない。<span class="heimu">根据能力，而未必是（根据）大学毕业。</span></p><p><span class="heimu">参加したくないというわけでわないが、時間がないです。</span>并不是不想参加，只是没有时间。</p><h3 id="7-～わけにはいかない"><a href="#7-～わけにはいかない" class="headerlink" title="7. ～わけにはいかない"></a>7. ～わけにはいかない</h3><p>～ないわけにはいかない 不得不…</p><p>接続：連体形</p><p>意味：<span class="heimu">不能（受到约束和限制）</span></p><p>例文：</p><p>風邪ひいたが、最近仕事忙しいので、会社を休むわけにはいかない。<span class="heimu">虽然感冒了，但是最近工作很忙，所以不能向公司请假。</span></p><p><span class="heimu">約束したので、行かないわけにはいかない。</span>因为已经约定好了，所以不能不去。</p><h3 id="8-～ものだ"><a href="#8-～ものだ" class="headerlink" title="8. ～ものだ"></a>8. ～ものだ</h3><p>接続：連体形</p><p>（1）意味：<span class="heimu">应该（道理，常识，习惯）</span></p><p>例文：</p><p>良薬は口に苦しいものだ。<span class="heimu">好的药应该就是苦的。良药苦口。</span></p><p><span class="heimu">人のお宅へ伺う時は、電話をしてからいくものだ。</span>到别人家拜访的时候，就应该先打电话。</p><p>（2）意味：<span class="heimu">表示感叹</span></p><p>例文：</p><p>時間の経つは速いものだ。<span class="heimu">时间过得真快啊！</span></p><p><span class="heimu">すごいものだ。</span>真厉害啊！</p><p>（3）意味：<span class="heimu">表示强烈的愿望，「真想」</span></p><p>接続：～たいものだ</p><p>例文：</p><p>子供の頃から、大きくなったら宇宙旅行をしたいものだと思っていた。<span class="heimu">小孩子的时候，想着长大之后去宇宙旅行啊！</span></p><p><span class="heimu">早く国へ帰って家族に会いたいものだ。</span>真想早点回国跟家人见面啊！</p><p>（4）意味：<span class="heimu">表回忆，「总是」</span></p><p>接続：～たものだ</p><p>例文：</p><p>おばあさんは昔よくこう言ったものです。<span class="heimu">奶奶过去经常这样说。</span></p><p><span class="heimu">昔はよくあの公園へ散歩に行ったものだ。</span>过去经常在那个公园散步。</p><h3 id="9-～ものではない"><a href="#9-～ものではない" class="headerlink" title="9. ～ものではない"></a>9. ～ものではない</h3><p>接続：連体形</p><p>意味：<span class="heimu">不该（违反常识）</span></p><p>例文：</p><p>人の悪口をいうもんじゃない。<span class="heimu">我们不该说别人的坏话。</span></p><p><span class="heimu">先生に対してそんなことを言うものではない。</span>不要对老师说那种话。</p><h3 id="10-～というものだ"><a href="#10-～というものだ" class="headerlink" title="10. ～というものだ"></a>10. ～というものだ</h3><p>接続：用言辞書型、体言</p><p>意味：<span class="heimu">「才真是」，表肯定强调</span></p><p>例文：</p><p>自分のことだけでなく、他人のことも考えてやることのできる人、それが大人というものです。<span class="heimu">不仅是自己的事情，能够考虑其他人做的事情的人，才真的是一个大人了。</span></p><p>てやる&#x3D;てあげる</p><p><span class="heimu">成績のいい学生にいろいろチャンス、不公平というものだ。</span>只给成绩好的学生各种机会，就是不公平。</p><h3 id="11-～というものではない"><a href="#11-～というものではない" class="headerlink" title="11. ～というものではない"></a>11. ～というものではない</h3><p>接続：用言辞書型、体言</p><p>意味：<span class="heimu">并不是</span></p><p>例文：</p><p>言葉の勉強は、文法がわかればいいというものではない。<span class="heimu">学习语言并不是学习文法就够了</span></p><p><span class="heimu">お金があれば、何でも買えるというものではない。</span>有钱并不是什么都能买到。</p><h3 id="12-～ものか"><a href="#12-～ものか" class="headerlink" title="12. ～ものか"></a>12. ～ものか</h3><p>PK：ものの（虽然）・ものだ・ものを</p><p>接続：用言辞書型</p><p>意味：<span class="heimu">表强烈否定，「怎么可能」</span></p><p>例文：</p><p>あんなまずい店には二度といくものか。<span class="heimu">那种难吃的店怎么能去吃第二次？</span></p><p><span class="heimu">あんなひとは恋人ができるものか。</span>那种人怎么会有对象？</p><h3 id="13-～ものがある"><a href="#13-～ものがある" class="headerlink" title="13. ～ものがある"></a>13. ～ものがある</h3><p>接続：連体形</p><p>意味：<span class="heimu">确实是（有这样的特性）</span></p><p>例文：</p><p>昨日見た映画はとても感動するものがあります。<span class="heimu">昨天看的电影确实很感动啊。</span></p><p><span class="heimu">さすがに大作家で、どの作品もすばらしいものがある。</span>不愧是大作家，每部作品都很出色。</p><h3 id="14-～べきだ"><a href="#14-～べきだ" class="headerlink" title="14. ～べきだ"></a>14. ～べきだ</h3><p>接続：用言辞書型、する＋べき（だ）&#x3D;すべき（だ）</p><p>意味：<span class="heimu">应该（说话人的主张建议）</span></p><p>例文：&#x3D;&#x3D;やるべきこと&#x3D;&#x3D;</p><p>学生はまず勉強すべきだ。<span class="heimu">学生应该好好学习。</span></p><p><span class="heimu">親に対して、こんな失礼なことを言うべきではない。</span>不能对父母说这种无礼的话。</p><h3 id="15-～ことだ"><a href="#15-～ことだ" class="headerlink" title="15. ～ことだ"></a>15. ～ことだ</h3><p>接続：連体形（可以省略だ）</p><p>意味：<span class="heimu">应该（劝告，要求）</span></p><p>例文：</p><p>合格したければ、よく勉強することだ。<span class="heimu">如果想合格，就要好好学习。</span></p><p><span class="heimu">上手になりたければ、しかり練習することだ。</span>想变得出色的话，就要认真练习了。</p><h3 id="16-～ことに"><a href="#16-～ことに" class="headerlink" title="16. ～ことに"></a>16. ～ことに</h3><p>接続：形容詞・形容詞連体形、動詞た形</p><p>意味：<span class="heimu">令人…的是</span></p><p>例文：</p><p>困ったことに、あの人の名前がどうしても思い出せなかった。<span class="heimu">无论如何都想不起来那个人的名字了。</span></p><p><span class="heimu">不思議なことに、会社をやめたら、よく眠れるようになった。</span>令人不可思议的是，辞职后睡眠变好了。</p><h3 id="17-～ことはない"><a href="#17-～ことはない" class="headerlink" title="17. ～ことはない"></a>17. ～ことはない</h3><p>接続：連体形</p><p>意味：<span class="heimu">不必</span></p><p>例文：</p><p>何も心配することはありません。<span class="heimu">什么也不必担心。</span></p><p><span class="heimu">そのぐらいことで怒ることはないでしょう。</span>什么程度的事情也不必发火呀！（那么点小事情也不必发火呀！）</p><h3 id="18-～ほど～ない"><a href="#18-～ほど～ない" class="headerlink" title="18. ～ほど～ない"></a>18. ～ほど～ない</h3><p>接続：連体形、体言</p><p>意味：<span class="heimu">没那么…</span></p><p>例文：&#x3D;&#x3D;AほどＢない&#x3D;&#x3D;   &#x3D;&#x3D;没A那么B&#x3D;&#x3D;</p><p>今年の夏は暑いが、去年ほどではない。<span class="heimu">今年的夏天好热，没去年那么热。</span></p><p><span class="heimu">想像したほどおもしろくない。</span>没有想象中有趣。</p><h3 id="19-～ほど～はない"><a href="#19-～ほど～はない" class="headerlink" title="19. ～ほど～はない"></a>19. ～ほど～はない</h3><p>接続：体言</p><p>意味：<span class="heimu">没有比…更…</span></p><p>例文：</p><p>健康ほど大切なものはない。<span class="heimu">没有比健康更重要的了。</span></p><p><span class="heimu">彼女ほど綺麗な人はいない。</span>没有比她更漂亮的人了。</p><h3 id="20-～と見える"><a href="#20-～と見える" class="headerlink" title="20. ～と見える"></a>20. ～と見える</h3><p>接続：用言辞書型、体言</p><p>意味：<span class="heimu">可见，看来</span></p><p>例文：</p><p>彼は赤い顔をしていて、相当怒っていると見える。<span class="heimu">他的脸变得红起来了，看起来像是非常生气了。</span></p><p><span class="heimu">雨が降ったと見える。</span>看得出来下雨了。</p><h3 id="21-～にすぎない"><a href="#21-～にすぎない" class="headerlink" title="21. ～にすぎない"></a>21. ～にすぎない</h3><p>（重要）</p><p>接続：用言辞書型、体言</p><p>意味：<span class="heimu">只不过 &#x3D;&#x3D;强调程度低&#x3D;&#x3D;</span></p><p>例文：</p><p>収入は二万円にすぎない。<span class="heimu">收入只不过就两万日元而已。</span></p><p><span class="heimu">ピアノは趣味として練習しているにすぎない。</span>只不过在作为兴趣练习钢琴。</p><h3 id="22-～にほかならない"><a href="#22-～にほかならない" class="headerlink" title="22. ～にほかならない"></a>22. ～にほかならない</h3><p>含义&#x3D;&#x3D;ほかない</p><p>ＰＳ：&#x3D;&#x3D;～（より）ほかはない&#x3D;&#x3D; &#x3D;&#x3D;只好&#x3D;&#x3D;</p><p>接続：体言</p><p>意味：<span class="heimu">正是，不外乎</span></p><p>例文：</p><p>彼に成功をもたらしたものは、今までの努力にほかならない。<span class="heimu">为他带来成功的，正是迄今为止的努力。</span><br><span class="heimu">彼が子供に厳しいのは、子供を深く愛しているにほかならない。</span>他对孩子严厉，正是因为他深深地爱着孩子。</p><h3 id="23-～でなくてなんだろう"><a href="#23-～でなくてなんだろう" class="headerlink" title="23. ～でなくてなんだろう"></a>23. ～でなくてなんだろう</h3><p>接続：体言</p><p>意味：<span class="heimu">不是…又是什么呢？</span></p><p>例文：</p><p>これが愛でなくてなんだろう。<span class="heimu">这不是爱又是什么呢。</span></p><p><span class="heimu">これは命ではなんだろう。</span>这不是命又是什么呢。</p><h3 id="24-～に相違ない"><a href="#24-～に相違ない" class="headerlink" title="24. ～に相違ない"></a>24. ～に相違ない</h3><p>接続：用言辞書型、体言</p><p>意味：<span class="heimu">一定（书面语）</span></p><p>例文：</p><p>私が見たのはこの人に相違ありません。<span class="heimu">我一定要见到那个人。</span></p><h3 id="25-～に決まっている"><a href="#25-～に決まっている" class="headerlink" title="25. ～に決まっている"></a>25. ～に決まっている</h3><p>接続：用言辞書型、体言</p><p>意味：<span class="heimu">一定（语气更强）</span></p><p>例文：</p><p>あの人のいうことは噓に決まっている。<span class="heimu">他说的话肯定是骗人的。</span></p><h3 id="26-～に違いない"><a href="#26-～に違いない" class="headerlink" title="26. ～に違いない"></a>26. ～に違いない</h3><p>接続：用言辞書型、体言</p><p>意味：<span class="heimu">一定（语气略弱且主观）</span></p><p>例文：</p><p>あの男は人の話になんでも「はいはい」と言っている。日本人に違いない。<span class="heimu">那个男人对别人的话什么都说“是是”。一定是日本人。</span></p><p>&#x3D;&#x3D;PS：24～26意思相近且考得多&#x3D;&#x3D;</p><h3 id="27-～のではない（だろか）か"><a href="#27-～のではない（だろか）か" class="headerlink" title="27. ～のではない（だろか）か"></a>27. ～のではない（だろか）か</h3><p>&#x3D;&#x3D;否定+疑问（表肯定）&#x3D;&#x3D;</p><p>接続：連体形</p><p>意味：<span class="heimu">…吧（委婉语气）</span></p><p>例文：</p><p>いったん失敗をしたら、また失敗をするのではないかと考えになる。<span class="heimu">一旦失败了，就会担心说会不会再失败。</span></p><p><span class="heimu">田中さんは昨日来たかな？ 来たんじゃないかと思うけど。</span>昨晚田中来了吗？我是觉得来了的。</p><h2 id="第二部分：時間"><a href="#第二部分：時間" class="headerlink" title="第二部分：時間"></a>第二部分：時間</h2><h3 id="1-～ところだ"><a href="#1-～ところだ" class="headerlink" title="1. ～ところだ"></a>1. ～ところだ</h3><p>接続：動詞辞書型</p><p>意味：<span class="heimu">正好要… 日语没有将来时，这里全部都用原型。</span></p><p>例文：</p><p>いま行くところだ。<span class="heimu">现在就要走了。</span></p><p><span class="heimu">これから食事にするところだ。</span>现在就要开饭。</p><h3 id="2-～（ている）ところだ"><a href="#2-～（ている）ところだ" class="headerlink" title="2. ～（ている）ところだ"></a>2. ～（ている）ところだ</h3><p>接続：て型</p><p>意味：<span class="heimu">正在…</span></p><p>例文：</p><p>今読んでいるところだ。<span class="heimu">现在正在读呢。</span></p><p><span class="heimu">娘は餃子を作っているところだ。</span>女儿正在做饺子。</p><h3 id="3-～（た）ところ"><a href="#3-～（た）ところ" class="headerlink" title="3. ～（た）ところ"></a>3. ～（た）ところ</h3><p>表示强调动作、事实上的刚刚</p><p>&#x3D;&#x3D;～たばかり（区别：心理上认为的刚刚）</p><p>接続：た型</p><p>意味：<span class="heimu">（1）刚刚（2）顺接（对应于转折、让步），自然而然的过渡</span></p><p> 例文：</p><p>今帰ってきたところです。<span class="heimu">现在刚回来。</span></p><p><span class="heimu">おわったところです。</span>现在刚结束。</p><h3 id="4-～ところに"><a href="#4-～ところに" class="headerlink" title="4. ～ところに"></a>4. ～ところに</h3><p>接続：連体形</p><p>意味：<span class="heimu">正要…时，…（在做什么事的时候，被打断了）</span></p><p>例文：</p><p>新聞を読もうとしたところに、電話がかかってきた。<span class="heimu">我正要读新闻的时候，电话来了。</span></p><p>もうとした：た的「将来时」用法。</p><p><span class="heimu">私が出かけるところに、彼が来た。</span>我正要出门的时候，他来了。</p><h3 id="5-～ところへ"><a href="#5-～ところへ" class="headerlink" title="5. ～ところへ"></a>5. ～ところへ</h3><p>接続：ている型・連体形</p><p>意味：<span class="heimu">正要…时，…（被打断）</span></p><p>PS：4、5（～ところに、～ところへ）意思一致。</p><p>例文：</p><p>どうしたらいいかと迷っているところへ、彼がやってきました。<span class="heimu">正当我不知道要怎么做的时候，他来了。</span></p><p><span class="heimu">出かけようとしているところへ、友達が来た。</span>正当我要出门的时候，朋友们来了。</p><h3 id="6-～ところを"><a href="#6-～ところを" class="headerlink" title="6. ～ところを"></a>6. ～ところを</h3><p>（1）接続：連体形</p><p>意味：<span class="heimu">正要…时，…（表示不利的情况）</span></p><p>例文：</p><p>授業でスマホを使っているところを先生に見られてしまった。<span class="heimu">上课的时候使用手机被老师发现了。</span></p><p><span class="heimu">こっそりお酒を飲んでいたところを、彼女に見つかった。</span>正在偷偷喝酒的时候被她发现了。</p><p>（2）接続：連体形、名詞＋の</p><p>意味：<span class="heimu">在…时（表恭敬）</span></p><p>例文：</p><p>お忙しいところを邪魔します。<span class="heimu">在您百忙之中。</span></p><p><span class="heimu">お休みのところを、わざわざおいでくださいまして、ありがとうございました。</span>您休息的时候还特意来一趟，非常感谢。</p><h3 id="7-～最中"><a href="#7-～最中" class="headerlink" title="7. ～最中"></a>7. ～最中</h3><p>接続：連体形、名詞＋の</p><p>意味：<span class="heimu">正在…的时候（鼎盛期）</span></p><p>例文：</p><p>今は暑い最中だ。<span class="heimu">现在是最热的时候。</span></p><p><span class="heimu">相談している最中だ。</span>现在正在商量。</p><h3 id="8-～たびに"><a href="#8-～たびに" class="headerlink" title="8. ～たびに"></a>8. ～たびに</h3><p>接続：連体形、名詞＋の</p><p>意味：<span class="heimu">每当、每次</span></p><p>例文：</p><p>この写真を見るたびに、大学時代を思い出す。<span class="heimu">每当看到这张照片，就会想起大学时光。</span></p><p><span class="heimu">あの人は來るたびに、文句を言う。</span>那个人每次来都要抱怨。</p><h3 id="9-～ついでに"><a href="#9-～ついでに" class="headerlink" title="9. ～ついでに"></a>9. ～ついでに</h3><p>接続：連体形、名詞＋の</p><p>意味：<span class="heimu">…的时候，顺便…</span></p><p>一般来说会有两件事情，ついでに之前，相连的事件不是「顺便做的事情」而是决定了发生的时间节点。ついでに后面接入的才是「顺便」的意思。</p><p>例文：</p><p>散歩のついでに、買い物をしてきた。<span class="heimu">散步的时候，顺便去买点东西。</span></p><p><span class="heimu">銀行に行くついでに、手紙を出す。</span>去银行的时候，顺便寄出了一封信。</p><h3 id="10-～うちに"><a href="#10-～うちに" class="headerlink" title="10. ～うちに"></a>10. ～うちに</h3><p>（1）接続：連体形、名詞＋の</p><p>意味：<span class="heimu">趁着（不用于未来）</span></p><p>例文：</p><p>温かいうちに食べてください。<span class="heimu">趁着东西温暖的时候赶紧吃了。</span></p><p><span class="heimu">若いうちにしっかり勉強しなさい。</span>趁着年轻的时候好好学习。</p><p>（2）接続：連体形、名詞＋の</p><p>意味：<span class="heimu">在…的过程中（发生自然而然的变化）</span></p><p>与中に（なかに）的区别是：中に表示「结果」，而うちに表示过程。都能翻译成…中。</p><p>例文：</p><p>話しているうちに外は暗くなりました。<span class="heimu">在说话的时候外面天暗下来了。</span></p><p><span class="heimu">本を読んでいるうちに、眠くなった。</span>看着看着书睡着了。</p><h3 id="11-～か～ないかのうちに"><a href="#11-～か～ないかのうちに" class="headerlink" title="11. ～か～ないかのうちに"></a>11. ～か～ないかのうちに</h3><p>接続：動詞辞書型</p><p>意味：<span class="heimu">刚一…就（要完未完之时）</span></p><p>例文：</p><p>一つの仕事が終わるか終わらないかのうちに、次の仕事がきた。<span class="heimu">一件工作刚做完的时候，下一件工作就来了。</span></p><p><span class="heimu">終わるか終わらないかのうちに、雨が降り出した。</span>比赛刚一结束就下起了雨。</p><h3 id="12-と思うと"><a href="#12-と思うと" class="headerlink" title="12. と思うと"></a>12. と思うと</h3><p>～かと思うと・～かと思うったら</p><p>（1）接続：た型</p><p>意味：<span class="heimu">一…就（出乎意料）</span></p><p>例文：</p><p>雨が降ったかと思うと、すぐ止んだ。<span class="heimu">雨刚一下，就停止了。</span></p><p><span class="heimu">花は咲いたと思うと、もう散ってしまた。</span>花刚一开，就凋谢了。</p><p>（2）接続：連体形、名詞</p><p>意味：<span class="heimu">原以为…（出乎意料）</span></p><p>例文：</p><p>彼はもう北京へ行ったかと思ったら、まだいかないでいた。<span class="heimu">原以为他也去北京了，没想到他还没去。</span></p><p><span class="heimu">京都は静かなところかと思ったら、東京と同じだ。</span>原来以为京都很安静，没想到和东京一样。</p><h3 id="13-～た途端（に）"><a href="#13-～た途端（に）" class="headerlink" title="13. ～た途端（に）"></a>13. ～た途端（に）</h3><p>接続：た型</p><p>意味：<span class="heimu">一…就</span></p><p>例文：</p><p>部屋に入った途端、電話が鳴りました。<span class="heimu">一进入房间，电话声就响起来了。</span></p><p><span class="heimu">教室に着いた途端、忘れ物にきづいた。</span>一到教室的时候，就发现自己忘带东西了。</p><h3 id="14-～うえで"><a href="#14-～うえで" class="headerlink" title="14. ～うえで"></a>14. ～うえで</h3><p>&#x3D;&#x3D;上で</p><p>接続：た型、名詞＋の</p><p>意味：<span class="heimu">…之后 &#x3D;&#x3D; …基础上</span></p><p>例文：</p><p>両親と話し合った上で決める。<span class="heimu">结合父母的话，在此基础上考虑。</span></p><p><span class="heimu">調査した上で、レポートを書き始めた。</span>取决于调查结果，开始写报告。</p><h3 id="15-～次第"><a href="#15-～次第" class="headerlink" title="15. ～次第"></a>15. ～次第</h3><p>（1）接続：&#x3D;&#x3D;ます型去ます&#x3D;&#x3D;</p><p>意味：<span class="heimu">一…就 &#x3D;&#x3D;强调将来&#x3D;&#x3D;</span></p><p>例文：</p><p>スケジュールを決まり次第、すぐ連絡いたします。<span class="heimu">我一决定这个日程表，就立刻联系你。</span></p><p><span class="heimu">手紙が届き次第、すぐに来てください。</span>收到信之后，就请赶紧过来。</p><p>（2）接続：体言</p><p>意味：<span class="heimu">取决于…</span></p><p>例文：</p><p>天気次第だ。<span class="heimu">取决于天气。</span></p><p><span class="heimu">できるかどうかはきみの努力次第だ。</span>是否能做，取决于你的努力。</p><h3 id="16-～て以来"><a href="#16-～て以来" class="headerlink" title="16. ～て以来"></a>16. ～て以来</h3><p>接続：て型</p><p>意味：<span class="heimu">自…以来（以前项为起点一直持续）</span></p><p>例文：</p><p>別れて以来、五年も経ってしまった。<span class="heimu">分别以来，都已经过了五年了。</span></p><p><span class="heimu">入学して以来、一度も休んだことはない。</span>入学以后一次都没请过假。</p><h3 id="17-～てはじめて"><a href="#17-～てはじめて" class="headerlink" title="17. ～てはじめて"></a>17. ～てはじめて</h3><p>（重要）</p><p>接続：て型</p><p>意味：<span class="heimu">…以后，才（前项是后项的条件）隐含了一个变化的意义。</span></p><p>例文：</p><p>別れてはじめて、君のありがたみがわかる。<span class="heimu">自从分开之后，才知道你的可贵。</span></p><p><span class="heimu">病気になってはいじめて、体が大切であることを知った。</span>生病之后，才知道健康的可贵。</p><h3 id="18-～にあたって・～にあたり"><a href="#18-～にあたって・～にあたり" class="headerlink" title="18. ～にあたって・～にあたり"></a>18. ～にあたって・～にあたり</h3><p>接続：動詞辞書型、名詞</p><p>意味：<span class="heimu">值此之际（书面）</span></p><p>例文：</p><p>新年にあたり、心からの祝いを表します。<span class="heimu">值此新年，表达发自内心的祝福。</span></p><p><span class="heimu">卒業にあたって、先生は私たちにいろいろ話してくれた。</span>毕业的时候，老师向我们说了很多。</p><h3 id="19-～際"><a href="#19-～際" class="headerlink" title="19. ～際"></a>19. ～際</h3><p>接続：連体形、名詞＋の</p><p>意味：<span class="heimu">…的时候</span></p><p>例文：</p><p>ご使用の際に、説明書よく読んでください。<span class="heimu">使用的时候，请读说明书。</span></p><p><span class="heimu">会った際に渡します。</span>见面的时候交给你。</p><h3 id="20-～に際し、に際して"><a href="#20-～に際し、に際して" class="headerlink" title="20. ～に際し、に際して"></a>20. ～に際し、に際して</h3><p>接続：連体形、名詞</p><p>意味：<span class="heimu">当…之际（直面）</span></p><p>例文：</p><p>卒業に際して、先生に心からお礼を申し上げます。<span class="heimu">毕业的时候，对老师发自内心的表示感谢。</span></p><p><span class="heimu">出発に際して、考えを変えました。</span>临出发前改变了自己的想法。</p><h3 id="21-きっかけ、契機"><a href="#21-きっかけ、契機" class="headerlink" title="21. きっかけ、契機"></a>21. きっかけ、契機</h3><p>～をきっかけにして・～を契機として・～を機に</p><p>機、契機（けいき）、きっかけ都有中文中「契机」的意思。</p><p>接続：体言</p><p>意味：<span class="heimu">以…为契机，借…机</span></p><p>例文：</p><p>あの事件をきっかけに戦争が始まった。<span class="heimu">借着那件事件，战争开始了。</span></p><p><span class="heimu">このチャンスを契機として、彼と知り合った。</span>借此机会认识了他。</p><h2 id="第三部分：逆接"><a href="#第三部分：逆接" class="headerlink" title="第三部分：逆接"></a>第三部分：逆接</h2><p>什么是逆接：</p><p>顺接：て、たら等表示「前一件事情结束，后一件事情顺其自然的开始」。</p><p>逆接则刚好相反。比如说「转折」：か，此时后面一个句子表达的意思和前一个句子完全不一样。</p><p>通过逆接「关键词」，可以有效帮我们猜测出前后句子的含义。</p><h3 id="1-～といっても"><a href="#1-～といっても" class="headerlink" title="1. ～といっても"></a>1. ～といっても</h3><p>接続：普通形</p><p>意味：<span class="heimu">虽说</span></p><p>例文：</p><p>安いといっても、10万円はかかるでしょう。<span class="heimu">虽然说很便宜，但是还是花了10万日元啊。</span></p><p><span class="heimu">成績がよくなったといっても、読解の成績だけだ。</span>虽然说成绩提高了，但也只是阅读成绩。</p><h3 id="2-～からといって"><a href="#2-～からといって" class="headerlink" title="2. ～からといって"></a>2. ～からといって</h3><p>接続：連体形</p><p>意味：<span class="heimu">虽说（后项和とは限らない等否定词呼应）</span></p><p>例文：</p><p>とは限らない：未必</p><p>先生だからといって、なんでも知っているとは限らない。<span class="heimu">虽然说是老师，但是知道的知识还是有限的。（未必什么都知道）</span></p><p><span class="heimu">お酒はあまり飲まないからといって、嫌いだというわけではない。</span>虽然说不怎么喝酒，但也并不是讨厌。</p><h3 id="3-～ながら"><a href="#3-～ながら" class="headerlink" title="3. ～ながら"></a>3. ～ながら</h3><p>（1）一边…一边（2）虽然但是（3）n+ながら</p><p>接続：ます型去ます</p><p>意味：<span class="heimu">虽然…但是…</span></p><p>例文：</p><p>やるやると言いながら、結局何もしない。<span class="heimu">虽然说着要做，最后却也什么都没做。</span></p><p>なかなか：轻易、颇，很，非常相当。</p><p><span class="heimu">あの人は小さいながら、なかなか力がある。</span>那个人虽然身材瘦小，但也却很有力气。</p><h3 id="4-～つつ（も）"><a href="#4-～つつ（も）" class="headerlink" title="4. ～つつ（も）"></a>4. ～つつ（も）</h3><p>PS：3和4，意思用法一致。</p><p>接続：ます型去ます</p><p>意味：<span class="heimu">虽然…但是…</span></p><p>例文：</p><p>そう言いつつも、彼女は決して行かないのだ。<span class="heimu">虽然这样说了，但是她却决定不去了。</span></p><p><span class="heimu">タバコをやめようとおもいつつ、いまだに成功していない。</span>虽然想着早点戒烟，但到现在也没有成功。</p><h3 id="5-～ものの"><a href="#5-～ものの" class="headerlink" title="5. ～ものの"></a>5. ～ものの</h3><p>接続：連体形</p><p>意味：<span class="heimu">虽然…但是…（消极）</span></p><p>例文：</p><p>大学は出たものの、就職先が見つからない。<span class="heimu">虽然说上了大学，但是也找不到工作。</span></p><p><span class="heimu">日本に来たものの、日本語が分からなくて、困っている。</span>尽管来日本了，但是还是不懂日语，感觉很困扰。</p><p>からには：既然。</p><h3 id="6-～にもかかわらず"><a href="#6-～にもかかわらず" class="headerlink" title="6. ～にもかかわらず"></a>6. ～にもかかわらず</h3><p>接続：動詞連体形、形容動詞＋てある・形容動詞＋なの</p><p>意味：<span class="heimu">尽管</span></p><p>例文：</p><p>周りは静かなのにもかかわらず、全然眠れなかった。<span class="heimu">尽管周围很安静，但还是完全睡不着。</span></p><p><span class="heimu">大雨にもかかわらず、試合は続いている。</span>尽管下大雨，比赛还是持续进行。</p><h3 id="7-～たところが"><a href="#7-～たところが" class="headerlink" title="7. ～たところが"></a>7. ～たところが</h3><p>（重要）</p><p>接続：た型</p><p>意味：<span class="heimu">可是、但是（表示意外的转折）</span></p><p>例文：</p><p>ブロポーズに行ったところが、彼女は留守だった。<span class="heimu">去求婚，但是她不在。</span></p><p><span class="heimu">財布をあけたところが、お金は入っていなかった。</span>打开了钱包，但是没有钱。</p><h3 id="8-～たところで"><a href="#8-～たところで" class="headerlink" title="8. ～たところで"></a>8. ～たところで</h3><p>接続：た型</p><p>意味：<span class="heimu">即使…也（不）&#x2F;（不过）</span></p><p>例文：</p><p>今更＝今までに</p><p>今更謝ったところで、許さないだろう。<span class="heimu">即使是现在道歉，也不会被原谅了吧。</span></p><p>前面经常加表示「程度」的副词，增强「即使」的意思。例如：たとえ、どんなに、いくら、どれだけ</p><p><span class="heimu">いくら待ったところで、彼は来ないでしょう。</span>即便怎么等，他也不会来了。</p><h3 id="9-～くせに"><a href="#9-～くせに" class="headerlink" title="9. ～くせに"></a>9. ～くせに</h3><p>のに</p><p>需要前后为同一个主语。</p><p>接続：連体形、名詞＋の</p><p>意味：<span class="heimu">明明…却…（抱怨语气类似のに）</span></p><p>例文：</p><p>自分で何もやらないくせに、人のやり方に文句ばかり言う。<span class="heimu">自己明明什么都没有干，但是却抱怨其他人做的不好。</span></p><p>装作：ふりをする</p><p><span class="heimu">知っているくせに、知らないふりをする。</span>明明什么都知道，却装作不知道。</p><h3 id="10-～わりに（は）"><a href="#10-～わりに（は）" class="headerlink" title="10. ～わりに（は）"></a>10. ～わりに（は）</h3><p>（重要）</p><p>&#x3D;割に</p><p>接続：連体形、名詞＋の</p><p>意味：<span class="heimu">前后项相比不相匹配，「但…」</span></p><p>例文：</p><p>日本は狭いわりには、人口が多い。<span class="heimu">日本的领土很小，但是人却很多。</span></p><p><span class="heimu">たくさん食べたわりには、太らない。</span>吃了很多，但是却不饱。</p><h3 id="11-～にしては"><a href="#11-～にしては" class="headerlink" title="11. ～にしては"></a>11. ～にしては</h3><p>接続：連体形、体言</p><p>意味：<span class="heimu">作为…而言，就…来说（与前项标准不太匹配）</span></p><p>例句：</p><p>うまい：除开「美味的；可口的」，还有「进展顺利的；幸运的」的含义。</p><p>彼は日本に来てただ半年にしては、日本語が非常にうまいです。<span class="heimu">他作为「来日本就半年的一个人」，就这个而言日语已经非常好了「进展很顺利」。</span></p><p><span class="heimu">博士にしては、あまりものが知らない人だ。</span>作为博士而言，知道的太少了。</p><h3 id="12-～反面・半面"><a href="#12-～反面・半面" class="headerlink" title="12. ～反面・半面"></a>12. ～反面・半面</h3><p>接続：連体形</p><p>意味：<span class="heimu">叙述同一事物两个不同的侧面</span></p><p>例文：</p><p>輸送に便利な反面、時間がかかる。<span class="heimu">输送便利的方面，花费了（过多的）时间。</span></p><p><span class="heimu">あの先生は学生に厳しい反面、やさしいところもある。</span>那个老师在学生面前严厉的反面，在某些地方也非常温柔。</p><h2 id="随机二次元（可能含NSFW）"><a href="#随机二次元（可能含NSFW）" class="headerlink" title="随机二次元（可能含NSFW）?"></a>随机二次元（可能含NSFW）?</h2><div align="center"><img src="../../../../loading2.svg" data-original="https://moe.starfishdl.site/api/setu/v1"></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="日语学习" scheme="https://blog.pengdonglai.com/categories/%E6%97%A5%E8%AF%AD%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="日本語" scheme="https://blog.pengdonglai.com/tags/%E6%97%A5%E6%9C%AC%E8%AA%9E/"/>
    
    <category term="语法" scheme="https://blog.pengdonglai.com/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>N2 日语部分语法点归总（2）</title>
    <link href="https://blog.pengdonglai.com/2024/09/17/japanese-grammar-4/"/>
    <id>https://blog.pengdonglai.com/2024/09/17/japanese-grammar-4/</id>
    <published>2024-09-17T02:35:41.000Z</published>
    <updated>2024-10-26T08:44:02.308Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><button class="btn-small waves-effect waves-light" id="toggleButton">变更测试模式</button></p><script>  let usingHeimu = true;  document.getElementById('toggleButton').addEventListener('click', () => {    usingHeimu = !usingHeimu;    const spans = document.querySelectorAll('span.heimu, span.no-heimu');    spans.forEach(span => {      if (usingHeimu) {        span.classList.remove('no-heimu');        span.classList.add('heimu');      } else {        span.classList.remove('heimu');        span.classList.add('no-heimu');      }    });  });</script><blockquote><p>本文来自于 bilibili UP 主 <a href="https://space.bilibili.com/548121510">当当_suzu</a> 的 <a href="https://www.bilibili.com/video/BV1yY411b7zY">N2 系列视频</a>，这套视频是我见过 N2 系列语法视频中讲的最全的版本，如果有可能大家请尽可能支持原作者！</p><p>本文内容来自于该系列视频讲义。如有侵犯著作权的行为请联系我及时删除。</p></blockquote><h2 id="第四部分：状態"><a href="#第四部分：状態" class="headerlink" title="第四部分：状態"></a>第四部分：状態</h2><h3 id="1-～てならない"><a href="#1-～てならない" class="headerlink" title="1. ～てならない"></a>1. ～てならない</h3><p>（意义差距大）てはならない &#x3D;&#x3D; 禁止 &#x3D;&#x3D;</p><p>接続：て型</p><p>意味：<span class="heimu">…得不得了</span></p><p>例文：</p><p>お腹が痛くてならない。<span class="heimu">肚子非常痛。</span></p><p><span class="heimu">両親に会いたくてならない。</span>非常想见父母。</p><h3 id="2-～てたまらない"><a href="#2-～てたまらない" class="headerlink" title="2. ～てたまらない"></a>2. ～てたまらない</h3><p>接続：て型</p><p>意味：<span class="heimu">…得不得了</span></p><p>例文：</p><p>一人で日本に来て、今は寂しくてたまらない。<span class="heimu">一个人来到日本，现在非常寂寞。</span></p><p><span class="heimu">試合に勝って、嬉しくてたまらない。</span>比赛胜利了，开心的不得了。</p><h3 id="3-～てしかたがない・てしょうがない"><a href="#3-～てしかたがない・てしょうがない" class="headerlink" title="3. ～てしかたがない・てしょうがない"></a>3. ～てしかたがない・てしょうがない</h3><p>接続：て型</p><p>意味：<span class="heimu">…得不得了</span></p><p>例文：</p><p>北京の夏は暑くてしかたがない。<span class="heimu">北京的夏天热的不得了。</span></p><p><span class="heimu">私の家は学校に遠く、不便でしかたがない。</span>我家到学校很远，非常不方便。</p><p>PS：1～3意思一致，用法相近</p><p>しかたがない（仕方がない）&#x3D;&#x3D; しようがない（仕様がない）均为「没办法」的含义。</p><p>动词的ます型去ます+よう，表示「方法」。しようがない可以这么记忆。</p><h3 id="4-～てはいられない"><a href="#4-～てはいられない" class="headerlink" title="4. ～てはいられない"></a>4. ～てはいられない</h3><p>接続：て型</p><p>可以这么记忆：ている的可能型：ていられる⇒ていられない</p><p>意味：<span class="heimu">不能（暗示要做另外一件事）</span></p><p>例文：</p><p>子供の不行儀に対して、黙ってはいられない。<span class="heimu">对小孩子不礼貌的行为，不能沉默。</span></p><p><span class="heimu">もうすぐＮ2試験だから、のんびり遊んではいられない。</span>马上就要N2考试了，不能自由自在的玩耍了。</p><p>のんびり：无忧无虑，自由自在。</p><h3 id="5-～てばかりいる"><a href="#5-～てばかりいる" class="headerlink" title="5. ～てばかりいる"></a>5. ～てばかりいる</h3><p>接続：て型</p><p>ばかり：一味地… 这个相当于ている中间插入ばかり。</p><p>意味：<span class="heimu">一个劲儿的做…</span></p><p>例文：</p><p>あの人はいつも怒ってばかりいる。<span class="heimu">那个人一个劲的在生气。</span></p><p><span class="heimu">もうすぐＮ2試験だから、遊んでばかりいられない。</span>马上就要N2考试了，不能一个劲的玩耍了。</p><h3 id="6-～ばかりだ"><a href="#6-～ばかりだ" class="headerlink" title="6. ～ばかりだ"></a>6. ～ばかりだ</h3><p>接続：連体形</p><p>意味：<span class="heimu">光是；不断（消极）；只要</span></p><p>例文：</p><p>彼女はなにも言わず、泣くばかりだ。<span class="heimu">她什么也不说，就一个劲的哭。</span></p><p>祖母の病状は悪化するばかりだ。<span class="heimu">祖母的病情在不断恶化。</span></p><p>今はただ祈るばかりだ。<span class="heimu">现在只能一个劲的祈祷了。</span></p><p><span class="heimu">ここの景色の美しさをただ褒めるばかりだ。</span>对于这里的景色我只有赞叹了。</p><h3 id="7-～ずにはいられない"><a href="#7-～ずにはいられない" class="headerlink" title="7. ～ずにはいられない"></a>7. ～ずにはいられない</h3><p>接続：ない型</p><p>双重否定：ずに为否定。いられない：不能。表示为不能不。</p><p>&#x3D;&#x3D; ないではいられません</p><p>意味：<span class="heimu">不能不…（情感油然而生、情不自禁）</span></p><p>例文：</p><p>この映画を見て、誰も感動せずにはいられないでしょう。<span class="heimu">看完这部电影后，无论是谁都不得不感动吧。</span></p><p><span class="heimu">こんなひどいことをされて、怒らないではいられません。</span>遇到如此过分的事情，怎能不生气。</p><p>怒る：おこる</p><p>する的被动形される再变て形「被做了」翻译成遇到大概。</p><h3 id="8-～一方だ"><a href="#8-～一方だ" class="headerlink" title="8. ～一方だ"></a>8. ～一方だ</h3><p>接続：連体形</p><p>意味：<span class="heimu">一直，越来越</span></p><p>例文：</p><p>最近家賃が増える一方だ。<span class="heimu">最近房租一个劲地增长。</span></p><p><span class="heimu">どういうわけか、最近私が太る一方だ。</span>不知道什么原因，最近我一个劲的发胖。</p><h3 id="9-～つもりだ"><a href="#9-～つもりだ" class="headerlink" title="9. ～つもりだ"></a>9. ～つもりだ</h3><p>重要！</p><p>接続：連体形、名詞+の&#x3D;&#x3D;ている、た接続時&#x3D;&#x3D;&#x3D;&#x3D;翻译为：自以为；就当作&#x3D;&#x3D;</p><p>意味：<span class="heimu">自以为；就当作，（N4N5）打算</span></p><p>例文：</p><p>本人はおもしろいつもりだろうが、他の人にはその冗談はわからなかった。<span class="heimu">虽然本人自以为很有趣，但是大家对这个玩笑并不是很理解。</span></p><p>旅行したつもりで、お金を銀行に入れた。<span class="heimu">就当作自己去旅游了，把钱存银行了吧。</span></p><p><span class="heimu">先生になったつもりで、この教科書をもう一度読みなおしなさい。</span>就把自己当老师，把这本教科书重新读一遍吧！</p><p>読み直す：よむおす，重读。</p><h3 id="10-～ようとする"><a href="#10-～ようとする" class="headerlink" title="10. ～ようとする"></a>10. ～ようとする</h3><p>接続：意向形</p><p>意味：<span class="heimu">打算做将要做</span></p><p>例文：</p><p>彼女笑顔は忘れようとしても忘れられません。<span class="heimu">当我打算要忘掉她的笑颜的时候却怎么也忘不掉。</span></p><p><span class="heimu">出かけようとしたところに、電話がかかって来た。</span>准备出门的时候，电话响了。</p><h3 id="11-～ながら"><a href="#11-～ながら" class="headerlink" title="11. ～ながら"></a>11. ～ながら</h3><p>接続：ます型去ます；名詞</p><p>意味：<span class="heimu">一边一边；原封不动</span></p><p>例文：</p><p>お茶を飲みながら話しましょう。<span class="heimu">一边喝茶一边说话。</span></p><p>皮ながら食べる。<span class="heimu">连着皮一起吃。</span></p><p><span class="heimu">テレビを見ながら、食事をしてはいけない。</span>不要一边吃饭一边看电视。</p><h3 id="12-～つつ"><a href="#12-～つつ" class="headerlink" title="12. ～つつ"></a>12. ～つつ</h3><p>接続：ます型去ます</p><p>意味：<span class="heimu">一边一边</span></p><p>例文：</p><p>お酒を飲みつつ、月見をする。<span class="heimu">一边喝酒，一边赏月。</span></p><p><span class="heimu">アルバイトをしつつ、大学に通っている。</span>一边打工一边上大学。</p><h3 id="13-～つつある"><a href="#13-～つつある" class="headerlink" title="13. ～つつある"></a>13. ～つつある</h3><p>接続：ます型去ます</p><p>意味：<span class="heimu">ている（宏观）</span></p><p>例文：</p><p>あの都市の様子は変わりつつある。<span class="heimu">那个城市的样子一直在变。</span></p><p><span class="heimu">自然が破壊されたつつある。</span>自然环境一直遭到破坏。</p><h3 id="14-～ば～ほど"><a href="#14-～ば～ほど" class="headerlink" title="14. ～ば～ほど"></a>14. ～ば～ほど</h3><p>接続：ば型～辞書形</p><p>意味：<span class="heimu">越…越</span></p><p>例文：</p><p>煮れば煮るほど、柔らかくなる。<span class="heimu">越煮就会变得越柔软。</span></p><p><span class="heimu">外国語は練習すればするほど、うまくなる。</span>外语越练习就会变得越熟练。</p><h3 id="15-～中を"><a href="#15-～中を" class="headerlink" title="15. ～中を"></a>15. ～中を</h3><p>接続：連体形、名詞+の</p><p>意味：<span class="heimu">…之中</span></p><p>例文：</p><p>お忙しい中をよくいらっしゃいました。<span class="heimu">感谢您百忙之中欢迎光临。</span></p><p><span class="heimu">雨の中を帰ってきた。</span>冒着雨归来了。</p><h3 id="16-～きり"><a href="#16-～きり" class="headerlink" title="16. ～きり"></a>16. ～きり</h3><p>重要！</p><p>接続：た型</p><p>意味：<span class="heimu">…以后（再没做过）&#x3D;&#x3D;还有接续的话，表以后&#x3D;&#x3D;</span></p><p>例文：</p><p>彼はアメリカへいったきり、帰ってこない。<span class="heimu">他去美国后，就再也没回来了。</span></p><p>作为（语义上的）句尾结束，表再没做过：</p><p>三年前に会ったきりだ。<span class="heimu">三年前见过后再也没见过。</span></p><p><span class="heimu">去年東京に行ったきり、まだ電話をしてくれない。</span>去年去过东京后，还没有来过电话。</p><p>末に：经过…最后，深思熟虑后得出来的结果。</p><h3 id="17-～かのようだ"><a href="#17-～かのようだ" class="headerlink" title="17. ～かのようだ"></a>17. ～かのようだ</h3><p>接続：名詞+てある、辞書形（形容動詞語幹）</p><p>意味：<span class="heimu">仿佛…似的</span></p><p>まるで：简直…好像。和かのようだ结合用的比较多。</p><p>例文：</p><p>深刻な顔をして、まるで世界の終わりがくるかのようだ。<span class="heimu">一脸严肃，仿佛世界末日就要来临。</span></p><p>もてなし：持て成し，接待，宽待的意思。</p><p><span class="heimu">自分の子供が帰ってきたかのようだ、母は友達を親切にもてなしてくれた。</span>仿佛自己的儿子回来一样，母亲亲切的招待了朋友。</p><h3 id="18-～ふりをする"><a href="#18-～ふりをする" class="headerlink" title="18. ～ふりをする"></a>18. ～ふりをする</h3><p>接続：連体形</p><p>ふりをする：振りをする。振り：<span class="heimu">装做，假装</span></p><p>意味：<span class="heimu">装作； 振动，摆动；（外表的）样子，打扮；（舞蹈、戏剧的）动作，姿势；陌生</span></p><p>例文：</p><p>寝たふりをしないで、速く起きて。<span class="heimu">别装作睡觉了，快速爬起来！了。</span></p><p><span class="heimu">彼はいつも忙しいそうなふりをしています。</span>他总是装出一副很忙的样子。</p><h3 id="19-～ところだった"><a href="#19-～ところだった" class="headerlink" title="19. ～ところだった"></a>19. ～ところだった</h3><p>重要！</p><p>接続：辞書形</p><p>意味：<span class="heimu">险些，差点</span></p><p>もう少しで、もうちょっとで：表示「差一点」的意思，经常在前面加这个作为表示。</p><p>例文：</p><p>トラック： truck 卡车、track 田径运动</p><p>ぶつかる：撞上，正当，赶上，适逢</p><p>もう少しで走ったトラックとぶつかるところだった。<span class="heimu">我差点撞上了一辆行驶的卡车。</span></p><p><span class="heimu">もうちょっとでけがをするところだった。</span>差一点就受伤了。</p><h3 id="20-～ことになっている・～こととなっている"><a href="#20-～ことになっている・～こととなっている" class="headerlink" title="20. ～ことになっている・～こととなっている"></a>20. ～ことになっている・～こととなっている</h3><p>接続：連体形</p><p>意味：<span class="heimu">规定（客观）</span></p><p>同：ことにする 表示「决定，主观上的」</p><p>例文：</p><p>両国の首脳会議は来月四日に開くことになっている。<span class="heimu">两国的首脑会议规定在下个月四日召开。</span></p><p><span class="heimu">鈴木さんとの約束では9時までに東京駅に行くことになっている。</span>和铃木先生约定了9点前去东京车站。</p><h3 id="21-～ようになっている"><a href="#21-～ようになっている" class="headerlink" title="21. ～ようになっている"></a>21. ～ようになっている</h3><p>接続：連体形</p><p>意味：<span class="heimu">对机器？结构进行客观描述。感觉翻译的时候，等同于不需要进行翻译。</span></p><p>例文：</p><p>ひとりで：自然的</p><p>この人工衛星はひとりでに速度を緩め、軌道を離れて、地上に降下するようになっている。<span class="heimu">这个人工卫星自然的速度降下来，偏离轨道，降落到地上来。</span></p><p><span class="heimu">何か故障があった場合、その機械はひとりでに電源が切れるようになっている。</span>如果出现了什么故障，那个机械会自动切断电源。</p><h2 id="第五部分：原因、結果"><a href="#第五部分：原因、結果" class="headerlink" title="第五部分：原因、結果"></a>第五部分：原因、結果</h2><p>原因有好的，有不好的；结果也有好的，也有不好的。</p><h3 id="1-～おかげて"><a href="#1-～おかげて" class="headerlink" title="1. ～おかげて"></a>1. ～おかげて</h3><p>接続：連体形、名詞+の</p><p>意味：<span class="heimu">多亏（积极原因）</span></p><p>例文：</p><p>あの人のおかげて、私たちは幸せに暮らせるのだ。<span class="heimu">多亏了那个人，我们才能幸福的生活。</span></p><p><span class="heimu">毎日練習したおかげて、上手になりました。</span>多亏了每天练习，进步很快。</p><h3 id="2-～せいで"><a href="#2-～せいで" class="headerlink" title="2. ～せいで"></a>2. ～せいで</h3><p>接続：連体形、名詞+の</p><p>意味：<span class="heimu">都怪（消极原因）</span></p><p>例文：</p><p>あなたのせいで、私は先生に𠮟られました。<span class="heimu">因为你，我被老师批评了。</span></p><p><span class="heimu">雨のせいで、試合は中止になった。</span>因为下雨，比赛中止了。</p><h3 id="3-～せいか"><a href="#3-～せいか" class="headerlink" title="3. ～せいか"></a>3. ～せいか</h3><p>重要！</p><p>接続：連体形、名詞+の</p><p>意味：<span class="heimu">也许是因为</span></p><p>例文：</p><p>熱のせいか、頭がフラフラしている。<span class="heimu">也许是因为发烧，头摇摇晃晃的。</span></p><p><span class="heimu">暑さのせいか、ぜんぜん食欲がない。</span>也许是因为热，完全没有食欲。</p><h3 id="4-～ために"><a href="#4-～ために" class="headerlink" title="4. ～ために"></a>4. ～ために</h3><p>接続：連体形、名詞+の</p><p>意味：<span class="heimu">由于，原因</span></p><p>例文：</p><p>病気のために、学校を休んだ。<span class="heimu">因为生病，向学校请假了。</span></p><p><span class="heimu">無理をして授業に出席したために、風邪がもっと悪くなってしまた。</span>由于勉强出席上课，感冒变得更严重了。</p><h3 id="5-～だけに"><a href="#5-～だけに" class="headerlink" title="5. ～だけに"></a>5. ～だけに</h3><p>接続：連体形、体言</p><p>意味：<span class="heimu">正因为，结果与原因相匹配（积极，也可消极）</span></p><p>例文：</p><p>重大な事柄だけに、もう一度検討する必要がある。<span class="heimu">正因为是重大的事情，所以有必要再研究一下。</span></p><p><span class="heimu">頑張っただけに、今回の満点はさぞ嬉しいでしょう。</span>正因为努力了，这次考试满分一定很开心吧。</p><h3 id="6-～だけあって、だけのことはある"><a href="#6-～だけあって、だけのことはある" class="headerlink" title="6. ～だけあって、だけのことはある"></a>6. ～だけあって、だけのことはある</h3><p>接続：連体形、体言</p><p>意味：<span class="heimu">不愧是，值得（积极）</span></p><p>例文：</p><p>さうがに彼だけあって、テレビも修理できる。<span class="heimu">不愧是他，还会修电视。</span></p><p><span class="heimu">故宮は世界でも有名なところで、行ってみるだけのことはある。</span>故宫是世界闻名的地方，值得一去。</p><h3 id="7-～ばかりに"><a href="#7-～ばかりに" class="headerlink" title="7. ～ばかりに"></a>7. ～ばかりに</h3><p>接続：連体形</p><p>意味：<span class="heimu">都是因为…才（消极）</span></p><p>例文：</p><p>油断したばかりに、事故を起こしてしまった。<span class="heimu">正因为疏忽大意，才引起了事故。</span></p><p>油断：漫不经心，粗心大意</p><p><span class="heimu">学歴がないばかりに、大手会社に入れないのだ。</span>因为没有学历，所以进不了大公司。</p><h3 id="8-～ことから"><a href="#8-～ことから" class="headerlink" title="8. ～ことから"></a>8. ～ことから</h3><p>接続：連体形</p><p>意味：<span class="heimu">因为（前项是判断依据）</span></p><p>例文：</p><p>二人の顔が似ていることから、親子ではないかと思った。<span class="heimu">因为两个人长得很像，所以我想应该是父子吧？</span></p><p><span class="heimu">この通りは政府機関が多いことから、官庁街と呼ばれている。</span>这条街因为政府机关多，所以被称为官厅街。</p><h3 id="9-～ところから"><a href="#9-～ところから" class="headerlink" title="9. ～ところから"></a>9. ～ところから</h3><p>接続：連体形</p><p>意味：<span class="heimu">因为（前项是判断依据）</span></p><p>例文：</p><p>あまり頭を使いすぎたことから、こんな病気になってしまった。<span class="heimu">由于过度使用脑力，才得了这样的病。</span></p><p><span class="heimu">彼は何でも知っているところから、「百科辞書」というあだ名で呼ばれている。</span>因为他什么都知道，所以被称为「百科词典」。</p><h3 id="10-～ことだから"><a href="#10-～ことだから" class="headerlink" title="10. ～ことだから"></a>10. ～ことだから</h3><p>接続：名詞+の</p><p>意味：<span class="heimu">既然是（他）（表达该名词具有的特点）</span></p><p>例文：</p><p>真面目な田中さんのことだから、きっと試験に合格しますよ。<span class="heimu">既然是认真的田中，考试一定会合格的。</span></p><p><span class="heimu">彼のことだから、どうせ時間通りに来ないだろう。</span>既然是他的话，反正不会按时来的。</p><p>どうせ： 终归，归根到底、反正，横竖</p><p>時間通り（に）：按时，准时</p><h3 id="11-～もの（もん）"><a href="#11-～もの（もん）" class="headerlink" title="11. ～もの（もん）"></a>11. ～もの（もん）</h3><p>接続：だ、です</p><p>整个句子的句尾…</p><p>意味：<span class="heimu">因为（撒娇抱怨语气）</span></p><p>例文：</p><p>だって：句中でも、句首なぜなら（何故なら）、句尾という</p><p>なぜなら放在句首，后面接续表示「原因」，通常前面半句表示「之所以」，表原因所产生的结论。</p><p>だって、先生がそうおっしゃたんだもの。<span class="heimu">是因为是老师这么说的呀。</span></p><p><span class="heimu">だって、重いんだもの。</span>所以说太重了嘛。</p><h3 id="12-～ものだから"><a href="#12-～ものだから" class="headerlink" title="12. ～ものだから"></a>12. ～ものだから</h3><p>&#x3D;&#x3D;ものですから</p><p>接続：連体形</p><p>意味：<span class="heimu">因为（主观强调原因理由）</span></p><p>经常带有「辩解」的语气。</p><p>例文：</p><p>この小説の主人公が大好きものですから、もう何度も読みました。<span class="heimu">因为很喜欢这部小说的主人公，所以已经看了好几遍了。</span></p><p><span class="heimu">眠い、夕べ遅くまで仕事をしていたものですから。</span>好困啊，因为昨晚工作到很晚。</p><h3 id="13-～につき"><a href="#13-～につき" class="headerlink" title="13. ～につき"></a>13. ～につき</h3><p>接続：体言</p><p>意味：<span class="heimu">因为（用于书面语，公文等）</span></p><p>例文：</p><p>工事中につき、立ち入り禁止。<span class="heimu">正在施工，禁止入内。</span></p><p><span class="heimu">大雨につき、今日の試合は中止になった。</span>由于下大雨，今天的比赛中止了。</p><h3 id="14-～以上は"><a href="#14-～以上は" class="headerlink" title="14. ～以上は"></a>14. ～以上は</h3><p>接続：連体形</p><p>意味：<span class="heimu">既然</span></p><p>例文：</p><p>諦める：断念，死心。</p><p>お金がない以上、諦めるしかない。<span class="heimu">既然没钱，就只好作罢。</span></p><p><span class="heimu">約束した以上は、守らなければならない。</span>既然约定好了，就不得不守约。</p><h3 id="15-～うえは"><a href="#15-～うえは" class="headerlink" title="15. ～うえは"></a>15. ～うえは</h3><p>上は。由于うえ有其他意思，需要做区分（仅表示うえ读音）：</p><p>上で：1. 在…之后 2. 在什么领域</p><p>上に：1. 加之</p><p>接続：連体形</p><p>意味：<span class="heimu">既然（语气更重）</span></p><p>例文：</p><p>引き受ける：对付、承担，负责、保证、照料、继承</p><p>引き受けた上は、全力を尽くさなければいけない。<span class="heimu">既然保证下来了，就不得不全力以赴。</span></p><h3 id="16-～からには、からは"><a href="#16-～からには、からは" class="headerlink" title="16. ～からには、からは"></a>16. ～からには、からは</h3><p>接続：連体形</p><p>意味：<span class="heimu">既然</span></p><p>例文：</p><p>試合にでる：参加比赛</p><p>試合にでるからには、勝ってほしい。<span class="heimu">既然要参加比赛，就要赢。</span></p><p>PS：14～16 意思和用法一致</p><h3 id="17-～あまり"><a href="#17-～あまり" class="headerlink" title="17. ～あまり"></a>17. ～あまり</h3><p>N5 语法：あまり…ない：表示不太…</p><p>还有一个表示「多余」的意思。</p><p>接続：連体形、名詞+の</p><p>意味：<span class="heimu">由于过于…（前接有感情色彩的词）</span></p><p>例文：</p><p>心配のあまり、眠れなかった。<span class="heimu">由于过于担心，睡不着。</span></p><p><span class="heimu">働きすぎたあまり、とうとう倒れてしまった。</span>由于过度劳作，终于倒下了。</p><h3 id="18-～あまりの～に、あまりの～で"><a href="#18-～あまりの～に、あまりの～で" class="headerlink" title="18. ～あまりの～に、あまりの～で"></a>18. ～あまりの～に、あまりの～で</h3><p>和上面的区别是，这个放在句首。</p><p>接続：名詞</p><p>意味：<span class="heimu">由于过于…</span></p><p>例文：</p><p>あまりの悲しさに、病気になってしまった。<span class="heimu">由于过于悲伤，生病了。</span></p><p><span class="heimu">あまりの人出で、諦めた。</span>由于太多人，所以放弃了。</p><h3 id="19-～あげく"><a href="#19-～あげく" class="headerlink" title="19. ～あげく"></a>19. ～あげく</h3><p>接続：た型、名詞+の</p><p>意味：<span class="heimu">…的结果（消极结果）</span></p><p>例文：</p><p>散々：厉害；严重（程度副词用于加深程度）、狼狈，凄惨，七零八落</p><p>散々迷ったあげく、結局Ｂ大学にした。<span class="heimu">犹豫了很长时间，最后去了B大学。</span></p><p>考えに考えた：思来想去，想来想去。</p><p><span class="heimu">考えに考えたあげく、会社を辞めることにした。</span>想来想去，最后决定辞职了。</p><h3 id="20-～末"><a href="#20-～末" class="headerlink" title="20. ～末"></a>20. ～末</h3><p>接続：た型、名詞+の</p><p>意味：<span class="heimu">结果（消极，积极）</span></p><p>例文：</p><p>相談の末、一緒にやることにした。<span class="heimu">谈完之后，决定要一起做。</span></p><p><span class="heimu">いろいろ考えた末、行くことにした。</span>考虑了很多，最后决定去。</p><h2 id="第六部分：対象、関係"><a href="#第六部分：対象、関係" class="headerlink" title="第六部分：対象、関係"></a>第六部分：対象、関係</h2><p>特点：大部分为名词接续。经常成组出现。</p><h3 id="1-～において"><a href="#1-～において" class="headerlink" title="1. ～において"></a>1. ～において</h3><p>接続：体言</p><p>意味：<span class="heimu">相当于で（表示「在」的情况下）</span></p><p>例文：</p><p>卒業式は学生センターにおいて行われます。<span class="heimu">毕业典礼在学生中心举行。</span></p><p><span class="heimu">2020年オリンピック大会は東京において、開催されました。</span>2020年奥运会在东京举行。</p><h3 id="2-～における"><a href="#2-～における" class="headerlink" title="2. ～における"></a>2. ～における</h3><p>～における+ｎ</p><p>接続：体言</p><p>意味：<span class="heimu">相当于で、作定语</span></p><p>例文：</p><p>学校における教育は子どもにとっていかに大切であるか？<span class="heimu">在学校的教育对孩子来说有多重要？</span></p><p>いかに：如何，怎样。</p><p><span class="heimu">各分野における発展を期待している。</span>期待在各个领域的发展。</p><h3 id="3-～に関して"><a href="#3-～に関して" class="headerlink" title="3. ～に関して"></a>3. ～に関して</h3><p>接続：体言</p><p>意味：<span class="heimu">关于…</span></p><p>例文：</p><p>両方は国際問題に関して意見を交換した。<span class="heimu">交换了关于两方的国际问题的意见。</span></p><p><span class="heimu">教育改革に関して論文を発表した。</span>发表了关于教育改革的论文。</p><h3 id="4-～について"><a href="#4-～について" class="headerlink" title="4. ～について"></a>4. ～について</h3><p>接続：体言&#x3D;&#x3D;结尾时+の+ｎ&#x3D;&#x3D;</p><p>意味：<span class="heimu">关于…</span></p><p>例文：</p><p>この問題について詳しく説明していただきたいです。<span class="heimu">我想得到您关于这个问题详细说明。</span></p><p>ていただく、てもらう：别人对我做某事。</p><p><span class="heimu">田中先生は日本のことについていろいろ話してくれました。</span>田中先生给我们讲了很多关于日本的事情。</p><h3 id="5-～に対して・に対する"><a href="#5-～に対して・に対する" class="headerlink" title="5. ～に対して・に対する"></a>5. ～に対して・に対する</h3><p>接続：体言</p><p>意味：<span class="heimu">对于；与…相对</span></p><p>vs にはんして：与…相反</p><p>例文：</p><p>客に対してこのような言葉使いをしてはいけない。<span class="heimu">对客人使用这样的话语是不行的。</span></p><p>父は厳しいに対して、母は優しい。<span class="heimu">相比于父亲的严厉，母亲是温柔的。</span></p><p>对于某个方面：対する+n</p><p><span class="heimu">学校は教師に対する要求は厳しい。</span>学校对于老师的要求很严格。</p><h3 id="6-～に比べて"><a href="#6-～に比べて" class="headerlink" title="6. ～に比べて"></a>6. ～に比べて</h3><p>接続：体言</p><p>意味：<span class="heimu">与…相比</span></p><p>PS：に対して有两个主语，に比べて只有一个主语</p><p>和に対して・に対する的区别在于：主语不同。に比べて强调主语，に対して・に対する的「前后」都是完整的。</p><p>例文：</p><p>今年の夏は去年に比べて、少し涼しいようです。<span class="heimu">今年的夏天对比去年，稍微凉快一些。</span></p><h3 id="7-～にとって"><a href="#7-～にとって" class="headerlink" title="7. ～にとって"></a>7. ～にとって</h3><p>接続：体言&#x3D;&#x3D;结尾时+の+ｎ&#x3D;&#x3D;</p><p>意味：<span class="heimu">对…来说</span></p><p>例文：</p><p>これは子どもにとって貴重な経験だ。<span class="heimu">这对孩子来说是宝贵的经验。</span></p><p><span class="heimu">私にとっての第一印象は町の狭いことです。</span>日本给我的第一印象是街道窄。</p><h3 id="8-～によって"><a href="#8-～によって" class="headerlink" title="8. ～によって"></a>8. ～によって</h3><p>接続：体言</p><p>意味：<span class="heimu">因…而（原因）；表依据；表示施加动作的人</span></p><p>例文：</p><p>因…而（原因）：<br>先生によって、教え方が違います。<span class="heimu">由于老师不同，教学方法也不同。</span></p><p>表依据：<br>成績によって、クラスを分ける。<span class="heimu">依据成绩不同，分到不同的班。</span></p><p>表示施加动作的人：<br>この小説は魯迅先生によって書かれたのだ。<span class="heimu">这个小说是鲁迅先生写的。</span></p><p><span class="heimu">地方によって、風俗習慣を違う。</span>依据地区不同，风俗习惯也不同。</p><h3 id="9-～によっては"><a href="#9-～によっては" class="headerlink" title="9. ～によっては"></a>9. ～によっては</h3><p>接続：体言</p><p>意味：<span class="heimu">根据前项也会出现后项的情况，「根据…有时」</span></p><p>例文：</p><p>場合によっては、スケジュールは変更するかもしれない。<span class="heimu">根据场合，计划可能也会有变更。</span></p><p><span class="heimu">人によっては、だまされるかもしれない。</span>有的人可能会上当。</p><h3 id="10-～に基づいて"><a href="#10-～に基づいて" class="headerlink" title="10. ～に基づいて"></a>10. ～に基づいて</h3><p>もと：基</p><p>接続：体言</p><p>意味：<span class="heimu">根据…（在此基础上）</span></p><p>例文：</p><p>今までの経験に基づいて判断する。<span class="heimu">基于迄今为止的禁言进行判断。</span></p><p><span class="heimu">これは実話に基づいて書かれた小説だ。</span>这是一本基于真实的故事写成的小说。</p><h3 id="11-～を基にして"><a href="#11-～を基にして" class="headerlink" title="11. ～を基にして"></a>11. ～を基にして</h3><p>接続：体言</p><p>意味：<span class="heimu">根据…</span></p><p>例文：</p><p>これまでのデーターを基にして研究を行う。<span class="heimu">根据以往的数据进行研究。</span></p><p><span class="heimu">このテレビドラマは伝説を基にして作った。</span>这部电视剧是根据传说进行创作的。</p><h3 id="12-～のもとで・に"><a href="#12-～のもとで・に" class="headerlink" title="12. ～のもとで・に"></a>12. ～のもとで・に</h3><p>もと：下。一般の+もと结合，这个下并不是读した。</p><p>接続：体言</p><p>意味：<span class="heimu">在…下</span></p><p>例文：</p><p>先生の指導のもとで研究を行う。<span class="heimu">在先生的指导下进行研究。</span></p><p><span class="heimu">専門家の指導のもとで創作する。</span>在专家的指导下创作。</p><h3 id="13-～上で"><a href="#13-～上で" class="headerlink" title="13. ～上で"></a>13. ～上で</h3><p>接続：体言+の、連体形</p><p>意味：<span class="heimu">在…的前提下；在…方面上；在…之后</span></p><p>例文：</p><p>在…的前提下：<br>双方の合意の上で結婚した。<span class="heimu">双方都同意的情况下结婚了。</span></p><p>在…方面上：<br>ビザの申請をする上で注意しなければならない。<span class="heimu">在申请签证这一方面需要注意。</span></p><p>在…的前提下：<br>いろいろ考えた上で、会社をやめることにした。<span class="heimu">考虑了很多之后，从会社辞职了。</span></p><p>在…之后：<br><span class="heimu">父と相談した上で、ご返事をします。</span>和父亲商量之后，再给您答复。</p><h3 id="14-～上"><a href="#14-～上" class="headerlink" title="14. ～上"></a>14. ～上</h3><p>接続：体言</p><p>意味：<span class="heimu">…上</span></p><p>表达这个意思的时候需要读じょう。</p><p>例文：</p><p>これは法律上の問題です。<span class="heimu">这是法律上的问题。</span></p><p><span class="heimu">健康上の理由で、会社を休んだ。</span>因为健康的理由没有上班。</p><h3 id="15-～をめぐって、をめぐる"><a href="#15-～をめぐって、をめぐる" class="headerlink" title="15. ～をめぐって、をめぐる"></a>15. ～をめぐって、をめぐる</h3><p>めぐ：巡。Ciallo～(∠・ω&lt; )⌒☆</p><p>接続：体言</p><p>意味：<span class="heimu">围绕着…（可以从「巡」这个字的意思来看）&#x3D;&#x3D;抽象：围绕…问题&#x3D;&#x3D; &#x3D;&#x3D;具体：围绕护城河&#x3D;&#x3D;</span></p><p>例文：</p><p>教育問題をめぐって、話し合います。<span class="heimu">围绕着教育问题，进行讨论。</span></p><p><span class="heimu">環境問題をめぐって、対策を検討する。</span>围绕着环境问题展开对策。</p><h3 id="16-～にわたって"><a href="#16-～にわたって" class="headerlink" title="16. ～にわたって"></a>16. ～にわたって</h3><p>重要！</p><p>わた：渡</p><p>接続：体言</p><p>意味：<span class="heimu">长达（在时间，空间范围内一直）；涉及到（各个方面）</span></p><p>例文：</p><p>长达（在时间，空间范围内一直）：<br>手術は14時間にわたって行われていた。<span class="heimu">手术进行了长达14小时。</span></p><p>涉及到（各个方面）：<br>この研究には多分野にわたって広い知識が必要である。<span class="heimu">这个研究涉及到了多领域，广阔的知识是必要的。</span></p><p>长达（在时间，空间范围内一直）：<br><span class="heimu">彼は3時間にわたって演説していた。</span>他进行了长达3小时的演说。</p><h3 id="17-～を通じて・を通して"><a href="#17-～を通じて・を通して" class="headerlink" title="17. ～を通じて・を通して"></a>17. ～を通じて・を通して</h3><p>接続：体言</p><p>意味：<span class="heimu">通过；整个…（时间范围内一直）</span></p><p>例文：</p><p>テレビを通して広告をする。<span class="heimu">通过电视做广告。</span></p><p>南極は一年を通して寒さが厳しく。<span class="heimu">南极一年到头都很冷。</span></p><p><span class="heimu">これは彼の一生を通して、もっとも苦しい時期だ。</span>这是他一生中最艰难的时刻。</p><p>もっとも：最。</p><h3 id="18-～から～にかけて"><a href="#18-～から～にかけて" class="headerlink" title="18. ～から～にかけて"></a>18. ～から～にかけて</h3><p>接続：体言</p><p>意味：<span class="heimu">从…到…范围内一直</span></p><p>例文：</p><p>東京は5月から8月にかけてよく雨が降る。<span class="heimu">东京从五月到八月经常下雨。</span></p><p><span class="heimu">九州から四国にかけて、大雨が降る。</span>从九州到四国，大雨倾盆。</p><h3 id="19-～かわりに"><a href="#19-～かわりに" class="headerlink" title="19. ～かわりに"></a>19. ～かわりに</h3><p>代：かわ</p><p>（1）接続：体言+の</p><p>意味：<span class="heimu">代替（前面的角色不做，而后面的事情做为代替）</span></p><p>例文：</p><p>BさんはAさんの代わりに主役を演じる。<span class="heimu">B代替A出演了主角。</span></p><p>今日は映画を見に行く代わりに、家で小説でも読もう。<span class="heimu">今天我们不去看电影，（作为代替），在家看小说。</span></p><p><span class="heimu">部長の代わりに、会議に出席した。</span>我代替部长出席了会议。</p><p>（2）接続：連体形</p><p>意味：<span class="heimu">交换；与…相反；不…而… &#x3D;&#x3D;都强调代价&#x3D;&#x3D;</span></p><p>例文：</p><p>日本語を教えてもらう代わりに、中国語を教えてあげよう。<span class="heimu">作为你教我日语的交换，我可以教你中文哟。</span></p><p>このマンションは駅に近い代わりに、家賃が高い。<span class="heimu">这间公寓离车站很近，但代价是租金很高。</span></p><h3 id="20-～にかわって"><a href="#20-～にかわって" class="headerlink" title="20. ～にかわって"></a>20. ～にかわって</h3><p>接続：体言</p><p>意味：<span class="heimu">代替</span></p><p>例文：</p><p>母にかわって挨拶をする。<span class="heimu">代替母亲打招呼。</span></p><p><span class="heimu">部長にかわって、挨拶をする。</span>代替部长打招呼。</p><h3 id="21-～を始め（として）"><a href="#21-～を始め（として）" class="headerlink" title="21. ～を始め（として）"></a>21. ～を始め（として）</h3><p>～を～として：以A为B</p><p>接続：体言</p><p>意味：<span class="heimu">以…为代表（还有其他的）</span></p><p>例文：</p><p>この映画は北京を始め、全国の大都市で上映される。<span class="heimu">这个电影以北京为首，在全国的大城市上映。</span></p><p><span class="heimu">中国を始めとするいろいろなアジアの国がこの会議に出席した。</span>以中国为首，许多亚洲国家出现了这个会议。</p><h3 id="22-～とおり"><a href="#22-～とおり" class="headerlink" title="22. ～とおり"></a>22. ～とおり</h3><p>重要！</p><p>とおり&#x3D;通り</p><p>接続：体言+の；ｎ+どおり；ｖ+とおり</p><p>意味：<span class="heimu">按照…</span></p><p>例文：</p><p>成績表は次のとおりです。<span class="heimu">成绩单如下。</span></p><p>先生の教えどおりにする。<span class="heimu">按照老师的指示去做。</span></p><p>先生が教えたとおり。<span class="heimu">按照老师的指示去做。</span></p><p>ご覧の通り、私の家です。<span class="heimu">如您所见，这是我家。</span></p><h3 id="23-～に応じて"><a href="#23-～に応じて" class="headerlink" title="23. ～に応じて"></a>23. ～に応じて</h3><p>接続：体言</p><p>意味：<span class="heimu">顺应（与前项事实相适应）</span></p><p>例文：</p><p>個人の希望に応じて、個別指導を行う。<span class="heimu">根据个人的希望，进行个别指导。</span></p><p>収入に応じて生活する。<span class="heimu">根据收入生活。</span></p><p><span class="heimu">お客さんの注文に応じて作る。</span>根据客户的订单制作。</p><h3 id="24-～にこたえて"><a href="#24-～にこたえて" class="headerlink" title="24. ～にこたえて"></a>24. ～にこたえて</h3><p>接続：体言</p><p>意味：<span class="heimu">回应（对期待要求等作出回应）</span></p><p>例文：</p><p>みんなの期待にこたえて、彼は新しい記録を立てた。<span class="heimu">为了回应大家的期待，他创立了新的记录。</span></p><p><span class="heimu">アンコールにこたえて、もう一回演じた。</span>应观众的要求，重新演了一次。</p><h3 id="25-～に反して"><a href="#25-～に反して" class="headerlink" title="25. ～に反して"></a>25. ～に反して</h3><p>接続：体言</p><p>意味：<span class="heimu">与…相反；违反</span></p><p>例文：</p><p>予想に反して、出席者が多かった。<span class="heimu">与预想相反，出席的人很多。</span></p><p><span class="heimu">交通規則に反することをしてはいけない。</span>不能做违反交通规则的事。</p><h3 id="26-～に加えて"><a href="#26-～に加えて" class="headerlink" title="26. ～に加えて"></a>26. ～に加えて</h3><p>接続：体言</p><p>意味：<span class="heimu">加之</span></p><p>例文：</p><p>大雪に加えて風まで吹いてきた。<span class="heimu">大雪加上刮风来了。</span></p><p>とうとう：终于。</p><p><span class="heimu">過労に加えて、病気になってとうとう倒れてしまった。</span>加之过劳，他最终生病倒下了。</p><h3 id="27-～に沿って"><a href="#27-～に沿って" class="headerlink" title="27. ～に沿って"></a>27. ～に沿って</h3><p>接続：体言</p><p>&#x3D;そって</p><p>意味：<span class="heimu">沿着（道路，方针，政策）</span></p><p>例文：</p><p>政府の方針に沿って、都市建設の計画を実施する。<span class="heimu">按照政府的方针，实施城市建设的计划。</span></p><p><span class="heimu">カリキュラムに沿って授業をする。</span>按照教学计划授课。</p><h3 id="28-～に従って"><a href="#28-～に従って" class="headerlink" title="28. ～に従って"></a>28. ～に従って</h3><p>接続：体言、辞書形</p><p>&#x3D;したがって</p><p>意味：<span class="heimu">随着；按照，根据</span></p><p>例文：</p><p>経済の発展に従って、人々の生活がよくなった。<span class="heimu">随着经济的发展，人们的生活提高了。</span></p><p>政府の方針に従って、建設の仕事に力を入れた。<span class="heimu">按照政府的方针，加大了建设工作力度。</span></p><p><span class="heimu">登るにしたがって、だんだん寒くなってきた。</span>随着登山，温度越低。</p><h3 id="29-～につれて"><a href="#29-～につれて" class="headerlink" title="29. ～につれて"></a>29. ～につれて</h3><p>接続：体言、辞書形</p><p>意味：<span class="heimu">随着&#x3D;&#x3D;自然变化&#x3D;&#x3D;</span></p><p>時間につれて、愛情が深まった。<span class="heimu">随着时间的变化，爱情越来越深了。</span></p><p><span class="heimu">物価の高騰につれて、生活も苦しくなった。</span>随着物价上涨，生活变得辛苦了。</p><h3 id="30-～に伴って"><a href="#30-～に伴って" class="headerlink" title="30. ～に伴って"></a>30. ～に伴って</h3><p>接続：体言</p><p>意味：<span class="heimu">随着</span></p><p>例文：</p><p>経済発展に伴って環境汚染もひどくなった。<span class="heimu">随着时间的变化，爱情越来越深了。</span></p><p><span class="heimu">人の考え方は環境と年齢に伴ってなった。</span>人的想法会随着环境和年龄而变化。</p><h3 id="31-～とともに"><a href="#31-～とともに" class="headerlink" title="31. ～とともに"></a>31. ～とともに</h3><p>接続：体言、辞書形</p><p>意味：<span class="heimu">与…同时；等于一緒に</span></p><p>例文：</p><p>地震が起こると共に、火災もあちこちで発生した。<span class="heimu">地震的时候，到处也发生了火灾。</span></p><p>あちこち：到处。</p><p>みんなと共に一緒に頑張りましょう。<span class="heimu">大家同时一起加油吧！</span></p><p><span class="heimu">卒業と共に、直ちに結婚する。</span>一毕业就马上结婚。</p><p>直ちに：ただちに、马上…</p><p>PS：27～31有相近的意思，容易出题在一块，注意区分</p><h3 id="32-～にかかわらず"><a href="#32-～にかかわらず" class="headerlink" title="32. ～にかかわらず"></a>32. ～にかかわらず</h3><p>接続：体言</p><p>意味：<span class="heimu">无论…，不管…</span></p><p>例文：</p><p>男女にかかわらず、誰でも申請できます。<span class="heimu">不管男生女生，无论是谁都能申请。</span></p><p><span class="heimu">経験のあるなしにかかわらず、誰でも参加できる。</span>不管有没有经验，谁都能参加。</p><p>PS：にもかかわらず意味：<span class="heimu">尽管</span></p><h3 id="33-～を問わず"><a href="#33-～を問わず" class="headerlink" title="33. ～を問わず"></a>33. ～を問わず</h3><p>接続：体言</p><p>意味：<span class="heimu">无论…，不管…</span></p><p>例文：</p><p>国籍を問わず、誰でも参加することができる。<span class="heimu">不管国籍，无论是谁都能参加。</span></p><p><span class="heimu">距離を問わず、バス代は210円です。</span>不论距离，车票都是210日元。</p><h3 id="34-～抜きで"><a href="#34-～抜きで" class="headerlink" title="34. ～抜きで"></a>34. ～抜きで</h3><p>接続：体言</p><p>抜き：ぬき</p><p>意味：<span class="heimu">取消，略去</span></p><p>例文：</p><p>冗談抜きで、真剣にこの問題を考えなさい。<span class="heimu">不开玩笑了，请认真地思考这个问题。</span></p><p>真剣に：认真地；</p><p><span class="heimu">晩ご飯抜きで、授業に来る学生が多い。</span>不吃晚饭，来上课的学生很多。</p><h3 id="35-～抜きにして"><a href="#35-～抜きにして" class="headerlink" title="35. ～抜きにして"></a>35. ～抜きにして</h3><p>接続：体言</p><p>意味：<span class="heimu">略去</span></p><p>例文：</p><p>冗談抜きにして、真面目に考えてください。<span class="heimu">不开玩笑了，请认真地思考这个问题。</span></p><p><span class="heimu">礼儀を抜きにして、思う存分に飲もう。</span>不用客气，尽情地喝吧。</p><p>思う存分：尽情地，痛痛快快地。</p><h2 id="第七部分：強調、限定"><a href="#第七部分：強調、限定" class="headerlink" title="第七部分：強調、限定"></a>第七部分：強調、限定</h2><h3 id="1-～限りでは"><a href="#1-～限りでは" class="headerlink" title="1. ～限りでは"></a>1. ～限りでは</h3><p>限りでは：かぎりでは</p><p>重要！</p><p>接続：认知类动词</p><p>意味：<span class="heimu">据…所…</span></p><p>例文：</p><p>私の知る限りでは、彼は悪い人ではありません。<span class="heimu">据我所知他不是一个坏人。</span></p><p><span class="heimu">私の調べた限りでは、彼は悪人ではない。</span>据我的调查，他不是一个坏人。</p><h3 id="2-～に限って"><a href="#2-～に限って" class="headerlink" title="2. ～に限って"></a>2. ～に限って</h3><p>2-4 都是 限る 的变形。所以都会有「仅限于」的意思。</p><p>接続：体言</p><p>意味：<span class="heimu">偏偏，只有（这是除了「仅限于」以外，多出来的意思，需要重点记，下同）</span></p><p>例文：</p><p>買いたい時に限って、売り切れだ。<span class="heimu">偏偏在我想买的时候，卖完了。</span></p><p><span class="heimu">出かけようとする日に限って、天気が悪くなる、どうしようかな。</span>偏偏在要外出的日子里天气变化，怎么办呢？</p><h3 id="3-～に限り"><a href="#3-～に限り" class="headerlink" title="3. ～に限り"></a>3. ～に限り</h3><p>（句中）</p><p>接続：体言</p><p>意味：<span class="heimu">只限于…只是…</span></p><p>例文：</p><p>今回に限り、許してやる。<span class="heimu">仅限于这次，原谅你了。</span></p><p><span class="heimu">毎月の最初の日曜日に限り、午前中は休む。</span>每个月只有第一个周日的上午休息。</p><h3 id="4-～に限る"><a href="#4-～に限る" class="headerlink" title="4. ～に限る"></a>4. ～に限る</h3><p>（1）接続：体言</p><p>意味：<span class="heimu">限于</span></p><p>例文：</p><p>今度の活動は女子に限る。<span class="heimu">这次的活动仅限女生。</span></p><p><span class="heimu">発表者は30人もいるから、一人15分に限ります。</span>发表者有30多人，所以每个人只限15分钟。</p><p>&#x3D;&#x3D;（2）接続：辞書形、体言&#x3D;&#x3D;</p><p>意味：<span class="heimu">最好，最佳（普遍认可）</span></p><p>例文：</p><p>疲れた時は寝るに限る。<span class="heimu">在累的时候睡觉最好了。</span></p><p><span class="heimu">夏は冷たいビルに限る。</span>夏天的冰啤酒最好了。</p><h3 id="5-～に限らず"><a href="#5-～に限らず" class="headerlink" title="5. ～に限らず"></a>5. ～に限らず</h3><p>接続：体言</p><p>由限る的否定，变更而来。限于的否定，<span class="heimu">不仅而且</span></p><p>意味：<span class="heimu">不仅而且</span></p><p>例文：</p><p>学部生に限らず、院生の就職も難しくなった。<span class="heimu">不仅是学部生，大学院的学生就职也变得困难了。</span></p><p><span class="heimu">選手たちに限らず、一般人も使える。</span>这个体育馆不仅仅是运动员可以用，一般人也可以使用。</p><h3 id="6-～とは限らない"><a href="#6-～とは限らない" class="headerlink" title="6. ～とは限らない"></a>6. ～とは限らない</h3><p>接続：辞書形、体言</p><p>意味：<span class="heimu">未必…（必ずしも等连用）</span></p><p>必ずしも+…とは限らない&#x2F;わけではない，为前后呼应。都表达原来<span class="heimu">未必</span>的意思，而不是做双重否定。</p><p>例文：</p><p>高いものは必ずしもいいとは限らない。<span class="heimu">贵的东西不一定好。</span></p><p><span class="heimu">中国人だからといって、中国文化を全部知っているとは限らない。</span>虽然说是中国人，也未必对中国文化都了解。</p><h3 id="6-5-～限り"><a href="#6-5-～限り" class="headerlink" title="6.5. ～限り"></a>6.5. ～限り</h3><p>v+限り：意味：<span class="heimu">只要</span></p><p>例文：</p><p>私たちが立ち留まらない限り、道は続く。<span class="heimu">只要我们不停留，就会一直有路。</span></p><h3 id="7-～にとどまらない"><a href="#7-～にとどまらない" class="headerlink" title="7. ～にとどまらない"></a>7. ～にとどまらない</h3><p>接続：体言</p><p>意味：<span class="heimu">不限于，不止于（暗示还波及其他范围）</span></p><p>例文：</p><p>言いたいことはこれだけにとどまらない。<span class="heimu">想说的东西不仅仅限于这些。</span></p><p><span class="heimu">コロナは都市にとどまらず、農村にも広がっている。</span>新冠病毒不仅仅在城市，也在农村扩散开了。</p><h3 id="8-～のみならず"><a href="#8-～のみならず" class="headerlink" title="8. ～のみならず"></a>8. ～のみならず</h3><p>接続：連体形、体言</p><p>意味：<span class="heimu">不仅</span></p><p>例文：</p><p>この漫画は子供のみならず大人にも読んでいる。<span class="heimu">这些漫画不仅仅孩子（能读），大人也能读。</span></p><p><span class="heimu">父のみならず、母までも反対している。</span>不仅仅是父亲，母亲也反对。</p><p>PS：表示「仅仅只」含义：だけ、のみ、ばかり</p><p>在表示否定的情形：</p><p>だけ –&gt; だけでなく　のみ –&gt; のみならず　ばかり –&gt; ばかりでなく、ばかりか</p><h3 id="9-～ばかりでなく"><a href="#9-～ばかりでなく" class="headerlink" title="9. ～ばかりでなく"></a>9. ～ばかりでなく</h3><p>接続：連体形、体言</p><p>意味：<span class="heimu">不仅</span></p><p>例文：</p><p>あの人は英語ばかりでなく、日本語も話せる。<span class="heimu">那个人不仅会说英语，也会说日语。</span></p><p><span class="heimu">この店は価格が高いばかりでなく、サービスも悪い。</span>这家店不仅价格昂贵，服务质量也很差。</p><h3 id="10-～ばかりか"><a href="#10-～ばかりか" class="headerlink" title="10. ～ばかりか"></a>10. ～ばかりか</h3><p>接続：連体形、体言</p><p>意味：<span class="heimu">不但（后项语气更重）</span></p><p>例文：</p><p>私ばかりか、先生でも知らないだろう。<span class="heimu">不仅仅是我，老师也不知道吧。</span></p><p><span class="heimu">自分を反省しないばかりか、責任を他人に押しつける。</span>他不但不反省自己，还把责任推给别人。</p><h3 id="11-～どころか"><a href="#11-～どころか" class="headerlink" title="11. ～どころか"></a>11. ～どころか</h3><p>重要！</p><p>接続：連体形、体言&#x3D;&#x3D;后接程度更甚&#x3D;&#x3D;</p><p>意味：<span class="heimu">不但不…反而（哪里谈得上…）</span></p><p>例文：</p><p><span class="heimu">成績はよくなるどころか、どんどん悪くなった。</span>成绩非但没有变好，还越来越差了。</p><p><span class="heimu">外国語どころか、母国語の文章さえ書けない大学生がいる。</span>别说外语，也有就连母语文章都写不好的大学生。</p><p>それどころか：<span class="heimu">岂止如此。</span></p><h3 id="12-～どころではない"><a href="#12-～どころではない" class="headerlink" title="12. ～どころではない"></a>12. ～どころではない</h3><p>接続：連体形、体言</p><p>意味：<span class="heimu">不是做某事的时候（哪里谈得上…）</span></p><p>例文：</p><p>宿題が多いので、テレビを見るどころではない。<span class="heimu">作业太多了，哪里谈得上看电视呢？</span></p><p><span class="heimu">忙しくて、映画を見るどころではない。</span>太忙了，哪里谈得上看电影。</p><h3 id="13-～上に"><a href="#13-～上に" class="headerlink" title="13. ～上に"></a>13. ～上に</h3><p>接続：連体形、名詞+の</p><p>意味：<span class="heimu">而且，又</span></p><p>例文：</p><p>あの店は料理がまずい上に、値段も高い。<span class="heimu">那个店的料理不仅难吃价格还很高。</span></p><p><span class="heimu">あそこの果物は新鮮な上に、値段も安い。</span>那里的水果不但新鲜，价格还很便宜。</p><h3 id="14-～さえ・でさえ"><a href="#14-～さえ・でさえ" class="headerlink" title="14. ～さえ・でさえ"></a>14. ～さえ・でさえ</h3><p>接続：連体形、体言</p><p>同：すら、でも</p><p>意味：<span class="heimu">甚至，就连</span></p><p>例文：</p><p>これは子どもさえわかることだ。<span class="heimu">连孩子都能理解。</span></p><p><span class="heimu">日本人の苗字は難しい、日本人でさえ困ることはあります。</span>日本人的姓读法很难，连日本人有时都感到很为难。</p><h3 id="15-～ことか"><a href="#15-～ことか" class="headerlink" title="15. ～ことか"></a>15. ～ことか</h3><p>接続：情感言葉連体形</p><p>意味：<span class="heimu">多么（感叹）</span>常和どんなに、どれほど、なんと连用</p><p>例句：</p><p>どんなに便利なことか。<span class="heimu">多么方便啊。</span></p><p><span class="heimu">昨日はあなたに会えてどれほど嬉しかったことか。</span>昨天能见到你不知道有多高兴。</p><h3 id="16-～はもちろん・はもちろんのこと"><a href="#16-～はもちろん・はもちろんのこと" class="headerlink" title="16. ～はもちろん・はもちろんのこと"></a>16. ～はもちろん・はもちろんのこと</h3><p>&#x3D;はもとより（N1）</p><p>接続：名詞</p><p>意味：<span class="heimu">自不必说</span></p><p>例文：</p><p>彼は英語はもちろん、日本語お話せる。<span class="heimu">他英语自不必说，连日语都能说。</span></p><p><span class="heimu">このことに、ちちはもちろん、母まではんたいする。</span>这件事情，爸爸就不用说了，连妈妈都反对。</p><h3 id="17-～はしない"><a href="#17-～はしない" class="headerlink" title="17. ～はしない"></a>17. ～はしない</h3><p>重要！</p><p>&#x3D;&#x3D;接続：ます型去ます&#x3D;&#x3D;</p><p>意味：<span class="heimu">不…（加强否定语气）</span></p><p>例文：</p><p>決して約束を忘れはしないから、心配しないでください。<span class="heimu">绝对不会忘记约定，请不要担心。</span></p><p><span class="heimu">噓なんかつきはしませんよ。</span>绝对不会撒谎的哦。</p><p>嘘を付く：撒谎。</p><h3 id="18-～っこない"><a href="#18-～っこない" class="headerlink" title="18. ～っこない"></a>18. ～っこない</h3><p>重要！</p><p>&#x3D;&#x3D;接続：ます型去ます&#x3D;&#x3D;</p><p>意味：<span class="heimu">不会（可能性不存在）</span></p><p>例文：</p><p>女の心なんて、わかりっこないよ。<span class="heimu">女人的心是不可能知道的。</span></p><p><span class="heimu">こんな難しい問題は解けっこない。</span>这么难的问题解决不了。</p><h3 id="19-～からして"><a href="#19-～からして" class="headerlink" title="19. ～からして"></a>19. ～からして</h3><p>接続：体言</p><p>意味：<span class="heimu">从…来看，单就…而言</span></p><p>例文：</p><p>表情からして、彼は失恋したようだ。<span class="heimu">从表情看来，他失恋了。</span></p><p><span class="heimu">外見からして、金持ちらしい。</span>从外表看，他似乎很富有。</p><p>金持ち：富人。</p><h3 id="20-～こそ"><a href="#20-～こそ" class="headerlink" title="20. ～こそ"></a>20. ～こそ</h3><p>接続：体言</p><p>意味：<span class="heimu">正是，才是 &#x3D;&#x3D;强调&#x3D;&#x3D;</span></p><p>例文：</p><p>努力してこそ、成功できるのだ。<span class="heimu">正是通过努力，才能成功。</span></p><p><span class="heimu">これこそ私が探しているものだ。</span>这正是我要找的。</p><h2 id="随机二次元（可能含NSFW）"><a href="#随机二次元（可能含NSFW）" class="headerlink" title="随机二次元（可能含NSFW）?"></a>随机二次元（可能含NSFW）?</h2><div align="center"><img src="../../../../loading2.svg" data-original="https://moe.starfishdl.site/api/setu/v1"></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="日语学习" scheme="https://blog.pengdonglai.com/categories/%E6%97%A5%E8%AF%AD%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="日本語" scheme="https://blog.pengdonglai.com/tags/%E6%97%A5%E6%9C%AC%E8%AA%9E/"/>
    
    <category term="语法" scheme="https://blog.pengdonglai.com/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>N2 日语部分语法点归总（3）</title>
    <link href="https://blog.pengdonglai.com/2024/09/17/japanese-grammar-5/"/>
    <id>https://blog.pengdonglai.com/2024/09/17/japanese-grammar-5/</id>
    <published>2024-09-17T02:35:41.000Z</published>
    <updated>2024-11-09T15:18:48.313Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><button class="btn-small waves-effect waves-light" id="toggleButton">变更测试模式</button></p><script>  let usingHeimu = true;  document.getElementById('toggleButton').addEventListener('click'， () => {    usingHeimu = !usingHeimu;    const spans = document.querySelectorAll('span.heimu， span.no-heimu');    spans.forEach(span => {      if (usingHeimu) {        span.classList.remove('no-heimu');        span.classList.add('heimu');      } else {        span.classList.remove('heimu');        span.classList.add('no-heimu');      }    });  });</script><blockquote><p>本文来自于 bilibili UP 主 <a href="https://space.bilibili.com/548121510">当当_suzu</a> 的 <a href="https://www.bilibili.com/video/BV1yY411b7zY">N2 系列视频</a>，这套视频是我见过 N2 系列语法视频中讲的最全的版本，如果有可能大家请尽可能支持原作者！</p><p>本文内容来自于该系列视频讲义。如有侵犯著作权的行为请联系我及时删除。</p></blockquote><h2 id="知识点快速记"><a href="#知识点快速记" class="headerlink" title="知识点快速记"></a>知识点快速记</h2><h3 id="可能"><a href="#可能" class="headerlink" title="可能"></a>可能</h3><p>ます型去ます（15&#x2F;19）：</p><ul><li>～かねる、～かねない</li><li>～ようがない</li><li>～得る</li><li>～かけ・～かける</li><li>～がち</li><li>～がる</li><li>～気味</li><li>～きる</li><li>～げ</li><li>～だらけ</li><li>～っぽい</li><li>～抜く</li><li>～向き、～向け</li></ul><p>其余四个：</p><ul><li>～ざるをえない（不得不）</li><li>～恐れがある（恐怕会）</li><li>～にも～ない（想做但是做不到）</li><li>～（より）ほか（は）ない（因为…只好）</li></ul><h3 id="仮定、条件"><a href="#仮定、条件" class="headerlink" title="仮定、条件"></a>仮定、条件</h3><table><thead><tr><th>即使</th><th>作为</th><th>如果</th><th>在…看来</th><th>如果不；没有</th><th>只要…就</th></tr></thead><tbody><tr><td>～たとえ～ても・でも</td><td>～としても</td><td>～としたら・とすると・とすれば</td><td>～にしたら・にすれば</td><td>～てからでないと</td><td>さえ～ば</td></tr><tr><td>～としても</td><td>～にしても</td><td>一旦…的话</td><td></td><td>～ないことには</td><td>～限り</td></tr><tr><td>～にしても</td><td></td><td>～ようものなら</td><td></td><td>～なしには・なくしては</td><td></td></tr><tr><td>～にしろ&#x2F;～にせよ</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h2 id="第八部分：列挙、話題提出"><a href="#第八部分：列挙、話題提出" class="headerlink" title="第八部分：列挙、話題提出"></a>第八部分：列挙、話題提出</h2><h3 id="1-～やら～やら"><a href="#1-～やら～やら" class="headerlink" title="1. ～やら～やら"></a>1. ～やら～やら</h3><p>接続：名詞、辞書形</p><p>意味：<span class="heimu">…啦…啦（列举代表性的事物）</span></p><p>例文：</p><p>家に帰って料理やら洗濯やら何もしなければならない。<span class="heimu">我得回家做饭，洗衣服什么的</span></p><p><span class="heimu">帰国前、買い物やら荷造りやらで、大変忙しかった。</span>回国之前，买东西收拾行李，忙得不可开交。</p><h3 id="2-～も～ば～も"><a href="#2-～も～ば～も" class="headerlink" title="2. ～も～ば～も"></a>2. ～も～ば～も</h3><p>重要！</p><p>接続：ば型</p><p>意味：<span class="heimu">既…又…</span></p><p>例文：</p><p>あの人は給料も高ければ能力もある。<span class="heimu">他工资又高又有能力。</span></p><p><span class="heimu">彼氏はお酒も飲めば、タバコも吸う。</span>我男朋友既喝酒又抽烟。</p><h3 id="3-～につけ～につけ"><a href="#3-～につけ～につけ" class="headerlink" title="3. ～につけ～につけ"></a>3. ～につけ～につけ</h3><p>接続：名詞、辞書形</p><p>意味：<span class="heimu">无论…还是</span></p><p>例文：</p><p>いいにつけ悪いにつけ、成績を先生に伝えるべきだ。<span class="heimu">不管是好是坏，都应该把成绩告诉老师。</span></p><p><span class="heimu">嬉しいにつけ、悲しいにつけ、彼と話したい。</span>无论高兴还是悲伤，我都想和他谈谈。</p><h3 id="4-～にしても～にしても"><a href="#4-～にしても～にしても" class="headerlink" title="4. ～にしても～にしても"></a>4. ～にしても～にしても</h3><p>接続：名詞、辞書形</p><p>意味：<span class="heimu">无论…还是…</span></p><p>例文：</p><p>高いにしても安いにしても、品物さえようければ買う。<span class="heimu">不管贵还是便宜，只要东西好就买。</span></p><p>…さえようければ：只要…好，就…</p><p><span class="heimu">進学にしても、就職にしても、自分で決めなければならない。</span>无论是升学还是就业，都必须由自己决定。</p><h3 id="5-～というと"><a href="#5-～というと" class="headerlink" title="5. ～というと"></a>5. ～というと</h3><p>PS：5-7 可以联合记忆。</p><p>接続：体言</p><p>意味：<span class="heimu">谈起，说到</span></p><p>例文：</p><p>川端康成というと、「雪国」という小説が心に浮かぶ人が多いでしょう。<span class="heimu">一提到川端康成，很多人脑海里就会浮现出《雪国》这部小说。</span></p><p>心に浮かぶ：从心里「浮现」，&#x3D;&#x3D;想起</p><p><span class="heimu">映画というと、「ハリウッド」を思い出す。</span>一提到电影，就想起《好莱坞》。</p><h3 id="6-～といえば"><a href="#6-～といえば" class="headerlink" title="6. ～といえば"></a>6. ～といえば</h3><p>（1）接続：体言</p><p>意味：<span class="heimu">说起</span></p><p>例文：</p><p>日本といえば、すぐ富士山を思い出します。<span class="heimu">说起日本，马上就会想起富士山。</span></p><p><span class="heimu">田中さんといえば、最近仕事を辞めてそうです。</span>说到田中，他最近辞职了。</p><p>（2）接続：体言</p><p>意味：<span class="heimu">要说…的确是…</span></p><p>例文：</p><p>不便といえば不便だが、なんとかやるよ。<span class="heimu">说不方便也确实不方便，但我会想办法的。</span></p><p><span class="heimu">高いといえば高いですが、必需品ですから、買っておいたほうがいいよ。</span>要说贵也确实是贵，但毕竟是必需品，还是买下来比较好。</p><h3 id="7-～といったら"><a href="#7-～といったら" class="headerlink" title="7. ～といったら"></a>7. ～といったら</h3><p>接続：体言</p><p>意味：<span class="heimu">提起，说到（提出话题）</span></p><p>例文：</p><p>その話を聞いたとき彼女の顔といったら、本当に悲しそうだった。<span class="heimu">听到那件事的时候，说起她的脸，真的很悲伤。</span></p><p><span class="heimu">紅葉といったら高尾山、あの景色のうつくしさといったら、言葉で言い表せないほどだ。</span>说到红叶就是高尾山，说起那个景色，简直无法用语言来形容。</p><h3 id="8-～かというと・かといえば・かといったら"><a href="#8-～かというと・かといえば・かといったら" class="headerlink" title="8. ～かというと・かといえば・かといったら"></a>8. ～かというと・かといえば・かといったら</h3><p>接続：体言</p><p>意味：<span class="heimu">从…来讲（以事实为依据谈论自己的看法）</span></p><p>なぜ成績が悪いかというと、普段の勉強が足りないからです。<span class="heimu">为什么成绩不好，是因为平时学习不够。</span></p><p><span class="heimu">大学を卒業したらとうするかといえば、まだ何も決めてないだ。</span>说到大学毕业后怎么办，我什么都还没决定呢。</p><h3 id="9-～からいうと・からいえば・からいって"><a href="#9-～からいうと・からいえば・からいって" class="headerlink" title="9. ～からいうと・からいえば・からいって"></a>9. ～からいうと・からいえば・からいって</h3><p>接続：体言</p><p>意味：<span class="heimu">从…来讲（以事实为依据谈论自己的看法）</span></p><p>例文：</p><p>彼は実力からいうと、大学に入るのは大丈夫だ。<span class="heimu">就他的能力而言，进入大学是没问题的。</span></p><p><span class="heimu">彼女は妹だけど、性格からいうと、私と全然違っている。</span>她是我妹妹，但她的性格和我完全不同。</p><p>だけど：表示转折。</p><h3 id="10-～からすると・からすれば"><a href="#10-～からすると・からすれば" class="headerlink" title="10. ～からすると・からすれば"></a>10. ～からすると・からすれば</h3><p>接続：体言</p><p>意味：<span class="heimu">从…来看（从事物的某个角度衡量）</span></p><p>例文：</p><p>話し方からすると、彼は東京の人ではないようだ。<span class="heimu">从说话的方式来看，他好像不是东京人。</span></p><p><span class="heimu">収入からすると、そんな高いかばんはとても買えない。</span>从我的收入来看，我买不起这么贵的包。</p><h3 id="11-～から見ると・から見れば・から見て"><a href="#11-～から見ると・から見れば・から見て" class="headerlink" title="11. ～から見ると・から見れば・から見て"></a>11. ～から見ると・から見れば・から見て</h3><p>接続：体言</p><p>意味：<span class="heimu">从…看来（角度，看法）</span></p><p>例文：</p><p>親の立場から見ると、子供はいくつになっても子供です。<span class="heimu">从父母的角度来看，孩子不管多大都是孩子。</span></p><p><span class="heimu">服装から見れば、彼は金持ちのようだ。</span>从他的衣服来看，他似乎很富有。</p><h3 id="12-～にしてみれば"><a href="#12-～にしてみれば" class="headerlink" title="12. ～にしてみれば"></a>12. ～にしてみれば</h3><p>重要！</p><p>接続：体言</p><p>意味：<span class="heimu">前接人物，从…视点来看</span></p><p>例文：</p><p>初心者にしてみれば、もっとわかりやすく話してもらいたいだろう。<span class="heimu">在初学者看来，希望能说得更通俗易懂吧。</span></p><p><span class="heimu">私にしてみれば、どうでもいいことだ。</span>在我看来，这是无关紧要的事。</p><p>どうでもいい：怎么都行，无所谓。</p><h3 id="13-～はともかく"><a href="#13-～はともかく" class="headerlink" title="13. ～はともかく"></a>13. ～はともかく</h3><p>ともかく：暂且。类似于一応（いちおう）</p><p>接続：体言、連体形</p><p>意味：<span class="heimu">…暂且不论</span></p><p>例文：</p><p>この店はサービスはともかく、味がわるくない。<span class="heimu">这家店的服务暂且不说，味道是不差的。</span></p><p><span class="heimu">他人のことはともかく、まず自分がどうするかを決めるべきだ。</span>别人的事暂且不论，你应该先决定自己该怎么做。</p><h3 id="14-～ならともく"><a href="#14-～ならともく" class="headerlink" title="14. ～ならともく"></a>14. ～ならともく</h3><p>接続：体言、連体形</p><p>意味：<span class="heimu">如果…另当别论，但是…（情有可原）</span></p><p>勉強しているならともかく、遊んでばかりいては成績がよくなるはずがない。<span class="heimu">学习的话姑且不论，光玩的话成绩不可能变好。</span></p><p><span class="heimu">遅刻ならともかく、欠席はだめだ。</span>迟到还好，不能缺席。</p><h2 id="第九部分：可能"><a href="#第九部分：可能" class="headerlink" title="第九部分：可能"></a>第九部分：可能</h2><h3 id="1-～ざるをえない"><a href="#1-～ざるをえない" class="headerlink" title="1. ～ざるをえない"></a>1. ～ざるをえない</h3><p>ざる：古典语法中的ない。ない型去ない：未然形接续。</p><p>&#x3D;&#x3D;接続：ない型&#x3D;&#x3D;</p><p>意味：<span class="heimu">不得不（违反本意）</span></p><p>例文：</p><p>今回の失敗はこちらにも責任があると言わざるをえない。<span class="heimu">不得不说，这次的失败我们也有责任。</span></p><p><span class="heimu">事故を起こしたのだから、仕事を辞めざるをえない。</span>既然发生了事故，就不得不辞去工作。</p><p>えない：得る。可以看第 8 个语法。</p><h3 id="2-～かねる"><a href="#2-～かねる" class="headerlink" title="2. ～かねる"></a>2. ～かねる</h3><p>かねる＝兼ねる</p><p>&#x3D;&#x3D;接続：ます型去ます&#x3D;&#x3D;</p><p>意味：<span class="heimu">难以，表达否定含义。</span></p><p>例文：</p><p>私一人では決めかねます。<span class="heimu">我一个人难以决定</span></p><p><span class="heimu">せっかく作ってくれた料理なので、まずいと言いかねる。</span>好不容易给我做的饭，不好说难吃。</p><h3 id="3-～かねない"><a href="#3-～かねない" class="headerlink" title="3. ～かねない"></a>3. ～かねない</h3><p>&#x3D;&#x3D;接続：ます型去ます&#x3D;&#x3D;</p><p>意味：<span class="heimu">有可能（消极）表达肯定含义。</span></p><p>例文：</p><p>あの人は金のためにはそんなことをやりかねない。<span class="heimu">为了钱，他会做这样的事。</span></p><p><span class="heimu">早く行かないと、7時の列車に遅れかねない。</span>如果不快点走，就赶不上七点钟的火车了。</p><h3 id="4-～恐れがある"><a href="#4-～恐れがある" class="headerlink" title="4. ～恐れがある"></a>4. ～恐れがある</h3><p>接続：連体形</p><p>意味：<span class="heimu">恐怕会（消极）</span></p><p>例文：</p><p>このまま森を切り続けば、ここは砂漠になる恐れがある。<span class="heimu">如果我们继续砍伐森林，这里可能会变成沙漠。</span></p><p><span class="heimu">台風は5日に沖縄地区に上陸する恐れがある。</span>台风有可能于5日登陆冲绳地区。</p><h3 id="5-～ようがない"><a href="#5-～ようがない" class="headerlink" title="5. ～ようがない"></a>5. ～ようがない</h3><p>&#x3D;&#x3D;接続：ます型去ます&#x3D;&#x3D;</p><p>意味：<span class="heimu">无法…</span></p><p>例文：</p><p>これ以上悩んでもどうしようもない、あきらめよう。<span class="heimu">再烦恼也无济于事，还是放弃吧。</span></p><p>これ以上：再，更加。</p><p>どうしようもない：无济于事。どうしよう：怎么办。</p><p><span class="heimu">その時の寂しさは言いようがない。</span>那时的寂寞是无法形容的。</p><p>言いようがない：无法用言语表达。</p><h3 id="6-～にも～ない"><a href="#6-～にも～ない" class="headerlink" title="6. ～にも～ない"></a>6. ～にも～ない</h3><p>接続：意向形（よう）～（ない）可能形&#x3D;&#x3D;中间一般是同一个动词&#x3D;&#x3D;</p><p>意味：<span class="heimu">想要做…也做不到</span></p><p>例文：</p><p>心配事があるので、寝ようにも寝られない。<span class="heimu">因为有担心的事情，想要睡也睡不了。</span></p><p><span class="heimu">お金がなくて、留学しようにもできない。</span>没有钱，想留学也去不了。</p><h3 id="7-～（より）ほか（は）ない"><a href="#7-～（より）ほか（は）ない" class="headerlink" title="7. ～（より）ほか（は）ない"></a>7. ～（より）ほか（は）ない</h3><p>接続：辞書形</p><p>意味：<span class="heimu">（没有别的办法）只好</span></p><p>例文：</p><p>N2試験に合格するためには、今から真面目に勉強するよりほかはない。<span class="heimu">为了通过 N2 考试，只能从现在开始认真学习。</span></p><p><span class="heimu">いくら焦ってもどうしようもない、このまま待つほかない。</span>再怎么着急也无济于事，只能这样等下去。</p><p>にほかならない：不外乎，正是。</p><h3 id="8-～得る"><a href="#8-～得る" class="headerlink" title="8. ～得る"></a>8. ～得る</h3><p>8-19 为接尾语，需要特别关注接续。</p><p>&#x3D;&#x3D;接続：ます型去ます&#x3D;&#x3D;</p><p>意味：<span class="heimu">能</span></p><p>そんなこと、ありえないよ。<span class="heimu">这样的事情，是不可能的。</span></p><p><span class="heimu">この問題を解きえた人はまだ一人もいない。</span>还没有人能解决这个问题。</p><h3 id="9-～かけ・～かける"><a href="#9-～かけ・～かける" class="headerlink" title="9. ～かけ・～かける"></a>9. ～かけ・～かける</h3><p>&#x3D;&#x3D;接続：ます型去ます&#x3D;&#x3D;</p><p>意味：<span class="heimu">刚刚开始，做了一半（没做完）</span></p><p>例文：</p><p>机には食べかけのパンが残されている。<span class="heimu">桌子上还有吃了一半的面包。</span></p><p><span class="heimu">読みかけた本を返した。</span>把没有读完的书还回去了。</p><h3 id="10-～がち"><a href="#10-～がち" class="headerlink" title="10. ～がち"></a>10. ～がち</h3><p>&#x3D;&#x3D;接続：ます型去ます&#x3D;&#x3D;、体言（后面接续同形容动词）</p><p>意味：<span class="heimu">容易、常常、往往会（消极）</span></p><p>例文：</p><p>これはありがちな間違いだ。<span class="heimu">这是常有的错误。</span></p><p><span class="heimu">彼女は小さいころ病気がちで、あまり外で遊ばなかった。</span>她小时候经常生病，很少在外面玩。</p><h3 id="11-～がる"><a href="#11-～がる" class="headerlink" title="11. ～がる"></a>11. ～がる</h3><p>&#x3D;&#x3D;接続：ます型去ます、形容詞語幹&#x3D;&#x3D;</p><p>日语中描述第三人称的时候，使用たがる。</p><p>本义：1. 想，觉得；うれしがる。感觉快乐；2. 故作；強がる。逞强。</p><p>意味：<span class="heimu">第三人称的感觉，表达「这样」的想法或感受。</span></p><p>例文：</p><p>弟は新しいものを見ると、すぐ欲しがる。<span class="heimu">弟弟一看到新的东西就想要。</span></p><p><span class="heimu">人の嫌がる事はなるべくやめたほうがいい。</span>你最好停止做别人不喜欢的事。</p><h3 id="12-～気味"><a href="#12-～気味" class="headerlink" title="12. ～気味"></a>12. ～気味</h3><p>&#x3D;&#x3D;接続：ます型去ます&#x3D;&#x3D;</p><p>意味：<span class="heimu">有点…倾向</span></p><p>例文：</p><p>今日は少し風邪気味で、頭が痛い。<span class="heimu">今天有点感冒的倾向，头疼。</span></p><p><span class="heimu">初めての演説なので、彼女は少し緊張気味だった。</span>因为是第一次演讲，她显得有些紧张。</p><h3 id="13-～きる"><a href="#13-～きる" class="headerlink" title="13. ～きる"></a>13. ～きる</h3><p>きる＝切る</p><p>きれる＝<span class="heimu">能做完</span>　きれない＝<span class="heimu">不能做完。</span></p><p>&#x3D;&#x3D;接続：ます型去ます&#x3D;&#x3D;</p><p>意味：<span class="heimu">做完</span></p><p>例文：</p><p>この本は一週間で読み切れる。<span class="heimu">这本书一星期读完。</span></p><p><span class="heimu">辞書に頼って、やっとこの小説を読み切った。</span>靠着词典，好不容易读完了这本小说。</p><h3 id="14-～げ"><a href="#14-～げ" class="headerlink" title="14. ～げ"></a>14. ～げ</h3><p>&#x3D;&#x3D;接続：ます型去ます、い形容詞去い、な形容詞去な&#x3D;&#x3D;</p><p>变完后相当于形容动词去用。</p><p>意味：<span class="heimu">…的样子</span></p><p>例文：</p><p>家の外で子猫が悲しげにほえている。<span class="heimu">家外面小猫伤心地叫着。</span></p><p><span class="heimu">このぐないのことで怒るのは、大人げがない。</span>为这件事生气，没有大人风度。</p><h3 id="15-～だらけ"><a href="#15-～だらけ" class="headerlink" title="15. ～だらけ"></a>15. ～だらけ</h3><p>接続：体言</p><p>意味：<span class="heimu">满是（抽象，具体）</span></p><p>例文：</p><p>彼は借金だらけ、何度も自殺を図った。<span class="heimu">他负债累累，多次企图自杀。</span></p><p><span class="heimu">この文章は間違いだらけ、直しようがない。</span>这篇文章错误百出，无从修改。</p><p>まみれ：<span class="heimu">だらけ表示「具体」的用法。「表面」的东西。</span></p><h3 id="16-～っぽい"><a href="#16-～っぽい" class="headerlink" title="16. ～っぽい"></a>16. ～っぽい</h3><p>&#x3D;&#x3D;接続：ます型去ます&#x3D;&#x3D; &#x3D;&#x3D;名词&#x3D;&#x3D;</p><p>意味：<span class="heimu">有前项的特性（可以翻译为像…一样）（接名词），状态；容易变得…样。（ます型去ます）</span></p><p>例文：</p><p>彼女はもう大学を卒業したが、子供っぽいところがまだある。<span class="heimu">她已经大学毕业了，但她仍然有孩子气。</span></p><p>子供っぽい：像孩子一样。不用于描述小孩子（类比的，不能描述对象）。不过らしい是可以这么用的。</p><p><span class="heimu">田中さんは忘れっぽくなりました。</span>田中先生最近变得健忘了。</p><h3 id="17-～抜く"><a href="#17-～抜く" class="headerlink" title="17. ～抜く"></a>17. ～抜く</h3><p>接続：ます型去ます</p><p>意味：<span class="heimu">（通过努力）做到最后</span></p><p>例文：</p><p>ついに2000メートルを走りぬいた。<span class="heimu">终于跑了2000米。</span></p><p><span class="heimu">決めた以上、最後までやり抜くべきだ。</span>既然已经决定了，就该干到底。</p><h3 id="18-～向き"><a href="#18-～向き" class="headerlink" title="18. ～向き"></a>18. ～向き</h3><p>接続：体言</p><p>意味：<span class="heimu">适合于（性质适合某类人或事物）；朝向</span></p><p>例文：</p><p>子供向きの料理もあれば、大人向きの料理もある。<span class="heimu">既有面向孩子的菜，也有面向大人的菜。</span></p><p><span class="heimu">あの酒は女性向きで、あまり強くない。</span>那种酒适合女人喝，不是很烈。</p><h3 id="19-～向け"><a href="#19-～向け" class="headerlink" title="19. ～向け"></a>19. ～向け</h3><p>接続：体言</p><p>意味：<span class="heimu">以…为对象（目的）</span></p><p>例文：</p><p>輸出向けの製品はみんな厳しい品質検査を受けている。<span class="heimu">以出口为目的的产品都经过严格的质量检验。</span></p><p><span class="heimu">これは中国の日本語学習者向けに作られた教材で、すごく面白い。</span>这是面向中国的日语学习者制作的教材，非常有趣。</p><h2 id="第十部分：仮定、条件"><a href="#第十部分：仮定、条件" class="headerlink" title="第十部分：仮定、条件"></a>第十部分：仮定、条件</h2><h3 id="1-～たとえ～ても・でも"><a href="#1-～たとえ～ても・でも" class="headerlink" title="1. ～たとえ～ても・でも"></a>1. ～たとえ～ても・でも</h3><p>接続：て型</p><p>除开たとえ，どんなに、どれだけ也能作为前面的接续。</p><p>意味：<span class="heimu">即使，就算</span></p><p>例文：</p><p>たとえ負けても、気を落としてはいけない。<span class="heimu">即使输了也不能沮丧。</span></p><p><span class="heimu">たとえ高くても、買わなければならない。</span>即使贵也得买。</p><h3 id="2-～としても"><a href="#2-～としても" class="headerlink" title="2. ～としても"></a>2. ～としても</h3><p>（1）接続：連体形、体言</p><p>意味：<span class="heimu">即使，就算</span></p><p>例文：</p><p>大地震が起こったとしても、このビルは大丈夫でしょう。<span class="heimu">即使发生了大地震，这栋楼也是没问题的吧。</span></p><p>（2）接続：身份地位的名词</p><p>意味：<span class="heimu">就算作为…</span></p><p>例文：</p><p>田中先生は詩人としても有名だ。<span class="heimu">田中先生就算作为诗人也很有名。</span></p><p><span class="heimu">校長としても規則を守るべきだ。</span>就算作为校长也不能违反规定。</p><h3 id="3-～にしても"><a href="#3-～にしても" class="headerlink" title="3. ～にしても"></a>3. ～にしても</h3><p>接続：連体形、体言</p><p>意味：<span class="heimu">即使…；无论…都（连接疑问词）；作为…也</span></p><p>接疑问词的时候，一般都是用にしても。</p><p>例文：</p><p>だれにしても、同じでしょう。<span class="heimu">无论是谁都是一样的。</span></p><p><span class="heimu">忙しいにしても、電話ぐらいはくれればいいのに。</span>即使再忙，至少给我打个电话吧。</p><h3 id="4-～にしろ-～にせよ"><a href="#4-～にしろ-～にせよ" class="headerlink" title="4. ～にしろ&#x2F;～にせよ"></a>4. ～にしろ&#x2F;～にせよ</h3><p>接続：連体形、体言</p><p>意味：<span class="heimu">即使（约等于にしても，略正式）</span></p><p>例文：</p><p>冗談にせよ、そんな話をすべきではない。<span class="heimu">即使（约等于にしても，略正式）</span></p><p><span class="heimu">どんなに辛いにしろ、最後まで頑張らなければならない。</span>就算再辛苦，也要坚持到最后。</p><p>3、4 符合起来也很常用。～にせよ～にせよ：无论…还是…。</p><h3 id="5-～としたら・とすると・とすれば"><a href="#5-～としたら・とすると・とすれば" class="headerlink" title="5. ～としたら・とすると・とすれば"></a>5. ～としたら・とすると・とすれば</h3><p>重要！</p><p>接続：辞書型</p><p>意味：<span class="heimu">如果</span></p><p>例文：</p><p>Ｘは3だとすれば、Ｙは5になる。<span class="heimu">如果X是3，Y就是5。</span></p><p><span class="heimu">証言は正しいとすれば、彼は無罪だ。</span>如果证词无误，他就无罪。</p><p>前面有可能会有仮に（かりに），后面接入的表示「假设」可以用这样的副词。也可以用とする＝当作。</p><h3 id="6-～にしたら・にすれば"><a href="#6-～にしたら・にすれば" class="headerlink" title="6. ～にしたら・にすれば"></a>6. ～にしたら・にすれば</h3><p>接続：体言</p><p>意味：<span class="heimu">在…看来</span></p><p>例文：</p><p>いくら大きくなっても、親にしたらまだ子供なのだ。<span class="heimu">即使年龄变大，在父母看来还是个孩子。</span></p><p><span class="heimu">生活が苦しくても、彼と一緒にいられることは、彼女にしたら最大の幸福だ。</span>即使生活艰苦，能和他在一起生活，从她来看就是最大的幸福了。</p><h3 id="7-～ようものなら"><a href="#7-～ようものなら" class="headerlink" title="7. ～ようものなら"></a>7. ～ようものなら</h3><p>接続：意向形</p><p>意味：<span class="heimu">一旦…的话</span></p><p>例文：</p><p>ちょっとミスしようものなら、命が危ない。<span class="heimu">稍有差错，就有生命危险。</span></p><p><span class="heimu">本当のことを話そうものなら、大変になる。</span>一旦要说真话，可不得了。</p><h3 id="8-～てからでないと"><a href="#8-～てからでないと" class="headerlink" title="8. ～てからでないと"></a>8. ～てからでないと</h3><p>接続：て型</p><p>てから：<span class="heimu">在…之后。</span>，这个相当于てから的否定+と。</p><p>意味：<span class="heimu">不在…之后的话，就无法…</span></p><p>例文：</p><p>みんなと相談してからでないと、一人で決められない。<span class="heimu">不和大家商量之后，就不能一个人做决定。</span></p><p><span class="heimu">親になってからでないと、親としての苦しさが分からない。</span>不成为父母，就不知道作为父母的痛苦。</p><h3 id="9-～ないことには"><a href="#9-～ないことには" class="headerlink" title="9. ～ないことには"></a>9. ～ないことには</h3><p>接続：否定型</p><p>意味：<span class="heimu">如果不…（就不能）…</span></p><p>例文：</p><p>やってみないことには、その面白さがわからないでしょう。<span class="heimu">如果不尝试一下的话，就不知道它的有趣之处吧。</span></p><p>やってみないことには：<span class="heimu">如果不尝试一下的话</span></p><p>面白さ：有趣之处。</p><p><span class="heimu">N2に合格しないことには、この大学に入れない。</span>考上 n2就进不了这所大学。</p><p>PS：8～9 一个意思</p><h3 id="10-～なしには・なくしては"><a href="#10-～なしには・なくしては" class="headerlink" title="10. ～なしには・なくしては"></a>10. ～なしには・なくしては</h3><p>接続：体言</p><p>意味：<span class="heimu">没有…（就不能）…</span></p><p>例文：</p><p>愛なしにはなんの人生か。</p><p>政府からの許可なしには、この計画が実施できないんだろう。</p><h3 id="11-さえ～ば"><a href="#11-さえ～ば" class="headerlink" title="11. さえ～ば"></a>11. さえ～ば</h3><p>重要！</p><p>接続：体言＋でさえあれば、体言＋さえ＋ば形、動詞連用形＋さえすれば、形容詞連用形＋さえあれば、形容動詞語幹＋でさえあれば</p><p>意味：<span class="heimu">只要…</span></p><p>例文：（只要）</p><p>無事でさえあれば、何よりです。</p><p>お金さえあれば、何でも買える。</p><p>この問題を解決しさえすれば、あとは簡単だ。</p><p>安くさえあれば、ちょっと狭くても構わない。</p><h3 id="12-～限り"><a href="#12-～限り" class="headerlink" title="12. ～限り"></a>12. ～限り</h3><p>接続：連体形</p><p>意味：<span class="heimu">只要</span></p><p>例文：</p><p>用事がない限り、必ず参加します。</p><p>暇がある限り、彼と一緒にいたい。</p><h2 id="第十一部分：その他"><a href="#第十一部分：その他" class="headerlink" title="第十一部分：その他"></a>第十一部分：その他</h2><h3 id="1-～ずつ"><a href="#1-～ずつ" class="headerlink" title="1. ～ずつ"></a>1. ～ずつ</h3><p>接続：数量詞</p><p>意味：<span class="heimu">每…</span></p><p>例文：</p><p>五人ずつでグループを作る。</p><p>一人に3枚ずつあげる。</p><h3 id="2-～おきに"><a href="#2-～おきに" class="headerlink" title="2. ～おきに"></a>2. ～おきに</h3><p>接続：数量詞</p><p>意味：<span class="heimu">每隔</span></p><p>例文：</p><p>1メートルおきに気を一本植える。</p><p>3時間おきに薬を飲んでください。</p><h3 id="3-～ごとに"><a href="#3-～ごとに" class="headerlink" title="3. ～ごとに"></a>3. ～ごとに</h3><p>接続：体言、連体形</p><p>意味：<span class="heimu">每…(频度)</span></p><p>例文：</p><p>このバスは五分ごとに出る。</p><p>日曜日ごとにプールに行く。</p><p>五人ごとにグループを作る。</p><h3 id="4-～なんて"><a href="#4-～なんて" class="headerlink" title="4. ～なんて"></a>4. ～なんて</h3><p>接続：辞書形、体言</p><p>意味：<span class="heimu">など口语，表示列举，或轻蔑不以为然的语气</span></p><p>例文：</p><p>こんなところで君に会うなんて、びっくりしたよ。</p><h3 id="5-～なんか"><a href="#5-～なんか" class="headerlink" title="5. ～なんか"></a>5. ～なんか</h3><p>接続：辞書形、体言</p><p>意味：<span class="heimu">など口语，什么的</span></p><p>例文：</p><p>小説を読んだりなんかして、暇をつぶす。</p><h3 id="6-～っけ"><a href="#6-～っけ" class="headerlink" title="6. ～っけ"></a>6. ～っけ</h3><p>接続：過去式</p><p>意味：<span class="heimu">「来着」。表示回忆；对记忆不清的事实进行证实</span></p><p>例文：</p><p>昨日の朝ごはん、何食べたっけ。</p><p>三年前はどこで働いたんだっけ。</p><h3 id="7-～ようではないか"><a href="#7-～ようではないか" class="headerlink" title="7. ～ようではないか"></a>7. ～ようではないか</h3><p>接続：意向形</p><p>意味：<span class="heimu">号召劝诱，…吧</span></p><p>例文：</p><p>最後まで頑張ってみようじゃないか</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="形式体言（N2-特别爱考）"><a href="#形式体言（N2-特别爱考）" class="headerlink" title="形式体言（N2 特别爱考）"></a>形式体言（N2 特别爱考）</h3><h4 id="こと"><a href="#こと" class="headerlink" title="こと"></a>こと</h4><ol><li><p>Vる、ない + ことがある<br>语法：表示有时、偶尔会发生。<br>例句：朝ごはんを食べないことがある。<br>翻译：有时不吃早餐。</p></li><li><p>Vた + ことがある</p></li><li><p>Vた + ことがない<br>语法：表示有某种经历（不可用于日常）。<br>例句：日本へ行ったことがある。<br>翻译：有去过日本的经历。</p></li></ol><p>语法：表示没有某种经历。<br>例句：日本へ行ったことがない。<br>翻译：没有去过日本的经历。</p><ol start="4"><li><p>Vる + ことにする<br>语法：表示主观决定（自己）。<br>例句：日本へ行くことにする。<br>翻译：决定去日本。</p></li><li><p>Vる + ことにしている<br>语法：表示长期坚持或习惯。<br>例句：甘いものを食べないことにしている。<br>翻译：决定不吃甜食。</p></li><li><p>Vる + ことになる</p></li><li><p>Vる + ことになる<br>语法：表示客观决定（公司）或商定。<br>例句：結婚することになった。<br>翻译：决定结婚。</p></li></ol><p>语法：表示会变得…<br>例句：人工知能に依頼しすぎると、脳は退化することになる。<br>翻译：如果过度依赖人工智能，大脑会退化。</p><ol start="8"><li><p>Vる + ことになっている<br>语法：表示规定、规章制度。<br>例句：週末は休講することになっている。<br>翻译：规定周末停课。</p></li><li><p>Vる + ことができる</p></li><li><p>Vる + ことができない<br>语法：表示能力或许可。<br>例句：泳ぐことができる。<br>翻译：能游泳。</p></li></ol><p>语法：表示没有能力或许可。<br>例句：寮でご飯を作ることができない。<br>翻译：不能在宿舍做饭。</p><ol start="11"><li><p>～ないことは (も) ない<br>语法：表示不是不…<br>例句：できないことはない。<br>翻译：并不是说不能做。</p></li><li><p>～ことは～が<br>语法：是倒是，但…<br>例句：できることはできるが。<br>翻译：能做是能做，但…</p></li><li><p>Vる・ない + ことだ</p></li><li><p>Vる・ない + こと<br>语法：表示应该（建议、劝说，上对下）。<br>例句：早く寝ることだ。<br>翻译：应该早点睡。</p></li></ol><p>语法：表示应该（轻微命令、要求、叮嘱）。<br>例句：親の話を聞くこと。<br>翻译：听父母的话。</p><p>（ことだ）还有吃惊的意思。</p><ol start="15"><li><p>～ことだし<br>语法：表示正因为；也是（因为）…（所以）就…吧。<br>例句：今日は休みだし、映画でも見に行こう。<br>翻译：今天放假，不如去看个电影吧。</p></li><li><p>～ことなしには<br>语法：表示如果没有…就没有…<br>例句：努力することなしには成功できない。<br>翻译：没有努力就无法成功。</p></li><li><p>Vること（も）なく<br>语法：表示不…<br>例句：彼は一日も休むことなく働いている。<br>翻译：他一天都没有休息地工作。</p></li><li><p>とのことだ</p></li><li><p>ということだ</p></li><li><p>ということだ<br>语法：表示听说。<br>例句：明日、雨が降るとのことだ。<br>翻译：听说明天会下雨。</p></li></ol><p>语法：表示听说或总结。<br>例句：出席しないということだ。<br>翻译：听说不出席。</p><p>语法：也就是说…<br>例句：明日、雨が降るということだ。<br>翻译：也就是说明天会下雨。</p><ol start="21"><li><p>～ことに<br>语法：表示令人…的是。<br>例句：嬉しいことに、合格した。<br>翻译：令人高兴的是，通过了。</p></li><li><p>ことか<br>语法：表示感叹、多么…<br>例句：なんときれいなことか。<br>翻译：多么漂亮啊。</p></li><li><p>人 + のことだから<br>语法：表示因为是他&#x2F;她嘛，根据对某人的了解进行判断。<br>例句：森さんのことだから、また遅刻するだろう。<br>翻译：因为是森先生，想必又会迟到了。</p></li><li><p>たことにする<br>语法：表示当做、权当。<br>例句：見なかったことにする。<br>翻译：就当没看见。</p></li><li><p>ことから</p></li><li><p>ことから<br>语法：表示原因、依据。<br>例句：彼女の顔色が悪いことから、貧血ではないかと思う。<br>翻译：根据她脸色不好，觉得可能是贫血。</p></li></ol><p>语法：表示名称由来。<br>例句：彼はOOスターに似ていることから、小OOと呼ばれている。<br>翻译：因为他像某个明星，所以被叫做小OO。</p><ol start="27"><li>Vることはない</li><li>Vることはない</li><li>Vることはない<br>语法：表示没必要。<br>例句：気にすることはないよ。<br>翻译：没必要在意。</li></ol><p>语法：表示某事不会做（语气比较坚决）。<br>例句：あのレストランはまずいから、二度と行くことはない。<br>翻译：那家餐厅不好，绝对不会再去。</p><p>语法：表示某事不会发生，不可能发生。<br>例句：こんな晴れているんだから、雨が降ることはないよ。<br>翻译：今天这么晴天，不可能下雨。</p><h4 id="もの"><a href="#もの" class="headerlink" title="もの"></a>もの</h4><h4 id="ところ"><a href="#ところ" class="headerlink" title="ところ"></a>ところ</h4><ol><li><p>原型或意志型 &#x2F; ている &#x2F; た + ところだ<br>语法：表示动作进行的时间阶段。<br>例句：今、勉強しているところだ。<br>翻译：现在正在学习。</p></li><li><p>のところ<br>语法：表示现在、当前或最近的状态。<br>例句：今のところ、問題はない。<br>翻译：目前没有问题。</p></li><li><p>たところ（が）<br>语法：表示意外的结果或情况。<br>例句：行ってみたところ、閉まっていた。<br>翻译：我去了一趟，但发现关门了。</p></li><li><p>たところ<br>语法：表示偶然的发现。<br>例句：新しいレストランを見つけたところだ。<br>翻译：刚好发现了一家新餐厅。</p></li><li><p>ところを<br>语法：表示在某个时刻或状态下，通常带有感谢或歉意的语气。<br>例句：忙しいところを手伝ってくれてありがとう。<br>翻译：在你忙的时候帮了我，谢谢。</p></li><li><p>ところだった &#x2F; でした<br>语法：表示差一点就发生某事。<br>例句：もう少し遅れていたら、遅刻するところだった。<br>翻译：再晚一点的话，差点就迟到了。</p></li><li><p>ところを見ると<br>语法：根据某种情况或样子进行推测。<br>例句：彼の様子を見ると、何か悩んでいるようだ。<br>翻译：从他的样子来看，好像有什么烦恼。</p></li><li><p>ところまで<br>语法：表示到达某个极限。<br>例句：ここが私たちの努力のところまでだ。<br>翻译：这就是我们努力的极限。</p></li><li><p>ていたところだ &#x2F; ～ところに～ &#x2F; ～ところへ～<br>语法：表示正当…的时候。<br>例句：出かけようとしていたところに、友達が来た。<br>翻译：正要出门的时候，朋友来了。</p></li><li><p>ところで<br>语法：表示话题转换或引入新话题。<br>例句：ところで、あなたの週末はどうでしたか？<br>翻译：对了，你的周末过得怎么样？</p></li><li><p>どころか<br>语法：表示不仅如此，反而更是（通常用于否定）。<br>例句：彼は遅刻どころか、まだ家にいる。<br>翻译：他不仅没有迟到，反而还在家里。</p></li><li><p>ところに<br>语法：表示正当…的时候（通常用于描述突发事件）。<br>例句：ちょうどその時、電話がかかってきたところに。<br>翻译：就在那个时候，电话打来了。</p></li><li><p>ところで<br>语法：再次引入话题，类似于「说到」。<br>例句：ところで、あなたはどの映画が好きですか？<br>翻译：顺便问一下，你喜欢哪部电影？</p></li><li><p>どころか<br>语法：强调与预期相反的情况。表示不仅…，反而…（通常用于否定）。<br>例句：彼女は料理が下手どころか、焼き焦がすこともある。<br>翻译：她不仅厨艺差，有时还会把食物烤焦。<br>例句：遊ぶどころか、勉強しなければならない。<br>翻译：不仅不能玩，反而必须学习。</p></li></ol><ul><li><p>うえ</p></li><li><p>うち</p></li><li><p>まま</p></li><li><p>わけ</p></li><li><p>つもり</p></li><li><p>限り</p></li><li><p>次第</p></li></ul><h3 id="相似语法"><a href="#相似语法" class="headerlink" title="相似语法"></a>相似语法</h3><ul><li><p>双重否定</p></li><li><p>三个「非常」</p></li><li><p>四个「随着」</p></li><li><p>する</p></li><li><p>言う</p></li><li><p>ばかり</p></li><li><p>一…就…</p></li></ul><h4 id="に动词て"><a href="#に动词て" class="headerlink" title="に动词て"></a>に动词て</h4><ol><li><p>において<br>语法：表示在某方面、某场所。<br>例句：この問題において、私たちは意見が一致した。<br>翻译：在这个问题上，我们意见一致。</p></li><li><p>にこたえて<br>语法：表示回应…<br>例句：要望にこたえて、新しいサービスを開始しました。<br>翻译：为了回应需求，开始了新服务。</p></li><li><p>にあたって<br>语法：表示在…之际，在…时候。<br>例句：卒業にあたって、感謝の言葉を述べた。<br>翻译：在毕业之际，表达了感谢之词。</p></li><li><p>に向かって<br>语法：表示朝向某个方向或目标。<br>例句：目標に向かって努力する。<br>翻译：朝着目标努力。</p></li><li><p>に際して<br>语法：表示在…之际，通常用于正式场合。<br>例句：旅行に際して、必要なものを確認してください。<br>翻译：在旅行之前，请确认所需物品。</p></li><li><p>にしたがって<br>语法：表示随着某事物的变化而变化。<br>例句：年齢にしたがって、体力が衰えてきた。<br>翻译：随着年龄的增长，体力逐渐减退。</p></li><li><p>に対して<br>语法：表示对比或对某事物的反应。<br>例句：彼の意見に対して、異議を唱える。<br>翻译：对他的意见提出异议。</p></li><li><p>においても<br>语法：表示即使在…情况下。<br>例句：この問題においても、違う意見がある。<br>翻译：在这个问题上，也存在不同的意见。</p></li><li><p>に基づいて<br>语法：表示基于某种依据或根据。<br>例句：データに基づいて、結論を出します。<br>翻译：基于数据得出结论。</p></li><li><p>によって<br>语法：表示通过某种手段或方法。<br>例句：インターネットによって、情報を得る。<br>翻译：通过互联网获取信息。</p></li><li><p>に至って<br>语法：表示到达某种状态或结果。<br>例句：この問題は深刻な事態に至った。<br>翻译：这个问题已经发展到了严重的地步。</p></li></ol><ul><li><p>を动词</p></li><li><p>くらいvsほど</p></li></ul><h3 id="复合词"><a href="#复合词" class="headerlink" title="复合词"></a>复合词</h3><ul><li><p>きり·きる</p></li><li><p>抜き·抜く</p></li><li><p>得る</p></li><li><p>かねる</p></li><li><p>かける</p></li><li><p>がち</p></li><li><p>ぎみ</p></li><li><p>っぽい</p></li><li><p>だらけ</p></li><li><p>っこない</p></li></ul><h3 id="放中间的"><a href="#放中间的" class="headerlink" title="放中间的"></a>放中间的</h3><ul><li><p>あげ</p></li><li><p>あまりに</p></li><li><p>甲斐があって</p></li><li><p>からこそ</p></li><li><p>最中に</p></li><li><p>際に</p></li><li><p>つつ</p></li><li><p>てからでないと</p></li><li><p>はともかく</p></li><li><p>にかかわらず</p></li><li><p>につき</p></li><li><p>につけ</p></li><li><p>のみならず</p></li><li><p>はもとより</p></li><li><p>反面</p></li><li><p>も～ば～も</p></li><li><p>矢先に</p></li><li><p>ようでは</p></li><li><p>わりには</p></li></ul><h3 id="放结尾的"><a href="#放结尾的" class="headerlink" title="放结尾的"></a>放结尾的</h3><ul><li><p>かのようだ</p></li><li><p>ざるを得ない</p></li><li><p>つつある</p></li><li><p>に過ぎない</p></li><li><p>に決まっている</p></li><li><p>に違いない</p></li><li><p>に越したことはない</p></li><li><p>にほかならない</p></li><li><p>ほかはない</p></li><li><p>べき</p></li><li><p>まい</p></li><li><p>ようがない</p></li><li><p>ようじゃないか</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="日语学习" scheme="https://blog.pengdonglai.com/categories/%E6%97%A5%E8%AF%AD%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="日本語" scheme="https://blog.pengdonglai.com/tags/%E6%97%A5%E6%9C%AC%E8%AA%9E/"/>
    
    <category term="语法" scheme="https://blog.pengdonglai.com/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>柚子社☆各OP分析</title>
    <link href="https://blog.pengdonglai.com/2024/08/31/tenshi-souzou-reboot-op/"/>
    <id>https://blog.pengdonglai.com/2024/08/31/tenshi-souzou-reboot-op/</id>
    <published>2024-08-31T04:18:41.000Z</published>
    <updated>2024-10-07T11:43:27.440Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>Ciallo ～(∠・ω&lt; )⌒★</p></blockquote><p>这篇博客本来想写一些关于天使☆纷扰的一些东西的，但众所周知，我非常不善于将这些东西表达感受出来，因为我很难不保证自己的感受为了照顾受众有一些同质化想法，那并不是我想要的。上次我正好有过一篇关于 OP 的分析，我觉得正好就将这篇博客的方向进行调整，争取让大家<s>柚子厨</s>读完之后<s>可以去公共场合展现自我。</s></p><p>希望大家可以从解析中有一些获得感！</p><p>无论你对柚子厨有什么看法，我都接受你最恶意的那一种，诶嘿~</p><h2 id="天使☆騒々-RE-BOOT"><a href="#天使☆騒々-RE-BOOT" class="headerlink" title="天使☆騒々 RE-BOOT!"></a>天使☆騒々 RE-BOOT!</h2><p>天使☆嚣嚣，是柚子社第12部正式作品。它在日本的正式名称为：天使☆騒々 RE-BOOT! 由于中文版目前还没个准信，所以我接受目前市面上的所有翻译，不要吵起来！！</p><p>关于这一作确实是有很多想说的，当然不全是好的评价，也没有什么自我感动，小作文啥的那更是绝对不会有。所以你想看那种深度内容，真情实感流露，建议再去互联网上找找哦 (∠・ω&lt; )⌒★。</p><p>歌曲名称：FUN FUN RE-BOOT</p><h3 id="传教时间"><a href="#传教时间" class="headerlink" title="传教时间"></a>传教时间</h3><p>这一作的 OP 我觉得可以在所有柚子的作品中，排进前三。为了方便传教，本文也贴一个官方的 OP 放到这里：</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 56.3%; margin: 20px 0"><iframe loading="lazy" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://www.youtube.com/embed/0R62qm0YQi8?si=DDUArjSwj69-pY9z" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe></div><p>当然，它只有前面的一小半部分。所以我这里也顺便给个 OP 的全语音版本：</p><audio src="audio1.mp3" controls loop preload="metadata">  你的浏览器不支持 audio 标签。</audio><h3 id="歌词讲解"><a href="#歌词讲解" class="headerlink" title="歌词讲解"></a>歌词讲解</h3><p>不过在我们分析 OP 前，可能还是需要把歌词说了什么，给弄懂。日语大神可以跳过第一部分，如果你不会日语或者日语没那么强，可以看看我写的分析。嗯嗯，果然还是忍不住也抱着学习的态度看看歌词呢：</p><p class="hiragana"><span class="ruby"><span class="rb">飛</span><span class="rt">と</span></span>び<span class="ruby"><span class="rb">出</span><span class="rt">だ</span></span>そう<span class="ruby"><span class="rb">新</span><span class="rt">あたら</span></span>しい <span class="ruby"><span class="rb">望</span><span class="rt">のぞ</span></span>む<span class="ruby"><span class="rb">世界</span><span class="rt">せかい</span></span>へ<br>FUN FUN RE-BOOT!<br></p><details>  <summary>点我查看解析</summary>  <div>飞向那个全新的、令人向往的世界吧！</div>  <div>飛び出そう：飞出去吧！</div>  <div>望む：令人羡慕，向往的</div>  <div>へ：N5语法，表示为「去」的含义</div></details><br><p class="hiragana"><span class="ruby"><span class="rb">平凡</span><span class="rt">へいぼん</span></span>だった<span class="ruby"><span class="rb">毎日</span><span class="rt">まいにち</span></span>に<span class="ruby"><span class="rb">舞</span><span class="rt">ま</span></span>い<span class="ruby"><span class="rb">降</span><span class="rt">お</span></span>りた<br><span class="ruby"><span class="rb">アンビリバブー</span><span class="rt">Unbelievable</span></span>！？<span class="ruby"><span class="rb">血</span><span class="rt">ち</span></span>も<span class="ruby"><span class="rb">沸</span><span class="rt">わ</span></span>き<span class="ruby"><span class="rb">立</span><span class="rt">た</span></span>つ<span class="ruby"><span class="rb">運命</span><span class="rt">うんめい</span></span><br>ゲームみたいにありえない<span class="ruby"><span class="rb">話</span><span class="rt">はなし</span></span>も<br><span class="ruby"><span class="rb">信</span><span class="rt">しん</span></span>じちゃう<span class="ruby"><span class="rb">魔法</span><span class="rt">まほう</span></span>かけてあげましょう<br></p><details>  <summary>点我查看解析</summary>  <div>在平凡无奇的每天就此降临。很神奇吧？让人热血沸腾的命运。</div>  <div>就连游戏里的，让人难以置信的故事，也让人忍不住相信。</div>  <div>就让我来为你施下魔法。</div>  <div>平凡だった：N5，な形容词过去式</div>  <div>みたい：N4语法，像那样的。区别于ように等</div>  <div>ちゃう：てしまう的缩略语口语用法</div>  <div>魔法かけて：N5语法，かける有「施加、发动」这里为发动魔法的意思</div>  <div>あげましょう：N4语法，あげる。区别于くれる、もらう</div></details><br><p class="hiragana"><span class="ruby"><span class="rb">異</span><span class="rt">こと</span></span>なる<span class="ruby"><span class="rb">力</span><span class="rt">ちから</span></span><span class="ruby"><span class="rb">掛</span><span class="rt">か</span></span>け<span class="ruby"><span class="rb">合</span><span class="rt">あ</span></span>わせ<span class="ruby"><span class="rb">生</span><span class="rt">う</span></span>み<span class="ruby"><span class="rb">出</span><span class="rt">だ</span></span>す<span class="ruby"><span class="rb">奇跡</span><span class="rt">きせき</span></span><br>ちょっと<span class="ruby"><span class="rb">凹</span><span class="rt">へこ</span></span>んだって、<span class="ruby"><span class="rb">イッツオーライ</span><span class="rt">It's alright</span></span><br><span class="ruby"><span class="rb">必</span><span class="rt">かなら</span></span>ずまた<span class="ruby"><span class="rb">立</span><span class="rt">た</span></span>ち<span class="ruby"><span class="rb">上</span><span class="rt">あ</span></span>がるよ <span class="ruby"><span class="rb">絶対</span><span class="rt">ぜったい</span></span><br>FUN FUN RE-BOOT!<br></p><details>  <summary>点我查看解析</summary>  <div>奇异的力量结合起来就产生了奇迹。哪怕稍微有挫折，依然也没有关系吧</div>  <div>一定会重新振作起来的，绝对。Fun Fun-Reboot！</div>  <div>就让我来为你施下魔法。</div>  <div>掛け合わせ：可以表示乘法，在这里表示「力量汇合」</div>  <div>必ずまた：一定会重新...</div>  <div>立ち上がる：站起来，这里笔者引申出来「振作」的意思</div></details><br><p class="hiragana"><span class="ruby"><span class="rb">ピンチ</span><span class="rt">Pinch</span></span>は<span class="ruby"><span class="rb">チャンス</span><span class="rt">Chance</span></span>に<span class="ruby"><span class="rb">上書</span><span class="rt">うわが</span></span>きして<br>どんな<span class="ruby"><span class="rb">世界</span><span class="rt">せかい</span></span>でも<span class="ruby"><span class="rb">大丈夫</span><span class="rt">だいじょうぶ</span></span><br><span class="ruby"><span class="rb">騒</span><span class="rt">さわ</span></span>がしいくらいがちょうどいいかもね<br><span class="ruby"><span class="rb">前世</span><span class="rt">ぜんせ</span></span>よりも<span class="ruby"><span class="rb">深</span><span class="rt">ふか</span></span>く<br><span class="ruby"><span class="rb">繋</span><span class="rt">つな</span></span>がる<span class="ruby"><span class="rb">愛</span><span class="rt">あい</span></span>を<span class="ruby"><span class="rb">コンティニュー</span><span class="rt">Continue</span></span><br></p><details>  <summary>点我查看解析</summary>  <div>逆境也会被重新改写为机会，无论是在哪个世界都没有关系</div>  <div>就算稍微有些吵闹，说不定正合我们的心意</div>  <div>相比于前世更加深沉，更紧密的爱，一直延续</div>  <div>上書きして：上書きる、改写，覆写</div>  <div>でも：どな...でも、无论怎样的...</div>  <div>くらい：名词接续，表示程度</div>  <div>ちょうど：表示正好。除此之外，它还有「稍微」的含义</div>  <div>ちょうどいいかもね：也许正合我意</div></details><br><p class="hiragana"><span class="ruby"><span class="rb">アクシデント</span><span class="rt">Accident</span></span> まさかの<span class="ruby"><span class="rb">展開</span><span class="rt">てんかい</span></span>も<br><span class="ruby"><span class="rb">最後</span><span class="rt">さいご</span></span>には<span class="ruby"><span class="rb">笑</span><span class="rt">わら</span></span>い<span class="ruby"><span class="rb">話</span><span class="rt">ばなし</span></span>にしよう<br><span class="ruby"><span class="rb">現実</span><span class="rt">げんじつ</span></span>は<span class="ruby"><span class="rb">小説</span><span class="rt">しょうせつ</span></span>よりも<span class="ruby"><span class="rb">奇</span><span class="rt">き</span></span>なりだそうで<br><span class="ruby"><span class="rb">楽</span><span class="rt">たの</span></span>しむしかないみたいね<br><span class="ruby"><span class="rb">私</span><span class="rt">わたし</span></span>たちの<span class="ruby"><span class="rb">ノンフィクション</span><span class="rt">Non-fiction</span></span><br></p><details>  <summary>点我查看解析</summary>  <div>突发事件预料外的展开，到最后也变成了笑谈</div>  <div>现实也许会比小说里面变得更加奇怪</div>  <div>好像也只能找些乐子了，这是我们的纪实文学</div>  <div>まさか：名词，意料之外的</div>  <div>なり：「…だ」、「…である」也，表示断定</div>  <div>しかない：動詞原形+しかない，只能，只得</div>  <div>しかないみたい：只能像那样了啊...</div></details><br><p class="hiragana"><span class="ruby"><span class="rb">重</span><span class="rt">かさ</span></span>ねた<span class="ruby"><span class="rb">心</span><span class="rt">こころ</span></span>を<span class="ruby"><span class="rb">一</span><span class="rt">ひと</span></span>つにして<br><span class="ruby"><span class="rb">予測</span><span class="rt">よそく</span></span><span class="ruby"><span class="rb">不可能</span><span class="rt">ふかのう</span></span>な<span class="ruby"><span class="rb">日常</span><span class="rt">にちじょう</span></span>も<br><span class="ruby"><span class="rb">山</span><span class="rt">やま</span></span>あり<span class="ruby"><span class="rb">谷</span><span class="rt">たに</span></span>あり<span class="ruby"><span class="rb">忙</span><span class="rt">いそが</span></span>しいけれど<br><span class="ruby"><span class="rb">攻略</span><span class="rt">こうりゃく</span></span>しよう キミと<br></p><details>  <summary>点我查看解析</summary>  <div>让重叠的心，合而为一</div>  <div>就连难以预测的日常，也会有高山低谷，让人手忙脚乱</div>  <div>让我们一起去攻略吧！</div>  <div>一つにして：合而为一</div>  <div>けれど：N4语法，虽然...可是，但是，表示转折</div></details><br><p class="hiragana">This is mana. Nobody can take. <span class="ruby"><span class="rb">平穏</span><span class="rt">へいおん</span></span>な<span class="ruby"><span class="rb">日々</span><span class="rt">ひび</span></span><span class="ruby"><span class="rb">取</span><span class="rt">と</span></span>り<span class="ruby"><span class="rb">戻</span><span class="rt">もど</span></span>すまで<br>そう This is mana. Nobody can take. キミの<span class="ruby"><span class="rb">隣</span><span class="rt">となり</span></span>にいるよ <span class="ruby"><span class="rb">当</span><span class="rt">あ</span></span>たり<span class="ruby"><span class="rb">前</span><span class="rt">まえ</span></span><br><span class="ruby"><span class="rb">机上</span><span class="rt">きじょう</span></span>の<span class="ruby"><span class="rb">空論</span><span class="rt">くうろん</span></span>より<span class="ruby"><span class="rb">逆風</span><span class="rt">ぎゃくふう</span></span>を<span class="ruby"><span class="rb">逆</span><span class="rt">ぎゃく</span></span>に<span class="ruby"><span class="rb">追</span><span class="rt">お</span></span>い<span class="ruby"><span class="rb">風</span><span class="rt">かぜ</span></span>に<span class="ruby"><span class="rb">変</span><span class="rt">か</span></span>えたなら<span class="ruby"><span class="rb">行</span><span class="rt">い</span></span>こう<br>(その<span class="ruby"><span class="rb">胸</span><span class="rt">むね</span></span>に<span class="ruby"><span class="rb">宿</span><span class="rt">やど</span></span>るは<span class="ruby"><span class="rb">強大</span><span class="rt">きょうだい</span></span>すぎる<span class="ruby"><span class="rb">パワー</span><span class="rt">Power</span></span>、<span class="ruby"><span class="rb">誰</span><span class="rt">だれ</span></span>の<span class="ruby"><span class="rb">手</span><span class="rt">て</span></span>にも<span class="ruby"><span class="rb">絶対</span><span class="rt">ぜったい</span></span>に<span class="ruby"><span class="rb">渡</span><span class="rt">わた</span></span>させはしないよ)<br>この<span class="ruby"><span class="rb">手</span><span class="rt">て</span></span>で（いつでも）<span class="ruby"><span class="rb">守</span><span class="rt">まも</span></span>るよ(<span class="ruby"><span class="rb">守</span><span class="rt">まも</span></span>る You are my big)<br>Shine！<br></p><details>  <summary>点我查看解析</summary>  <div>（这是无法被夺走的魔法力量）直至重新回到平稳的日子，</div>  <div>（这是无法被夺走的魔法力量）我会陪在你的身边，这是当然</div>  <div>不再纸上谈兵，而是逆转（逆风）变成顺风车，那么走吧！</div>  <div>（强大的力量寄宿在你的胸中，绝对不可以交给任何人手中）</div>  <div>我会亲手（一直都）将其守护（守护，你对于我而言，最璀璨的光）</div>  <div>取り戻す：收回，更为正式的「戻す」</div>  <div>隣にいる：陪在...的身边</div>  <div>当たり前：理所当然，自然</div>  <div>空論：空谈；机上の空論：纸上谈兵</div>  <div>逆風：除了字面意思「逆风」，可以表达「逆境、不利状况」的意思。逆風を逆に：逆风翻盘</div>  <div>追い風：和逆風是反义词，字面意思「顺风」，可以表达「顺境」的意思</div>  <div>変える：はげ山を水田に変える：将秃山变成水田。注意に和を的用法</div>  <div>～過ぎる：N4语法。同にくい等可以接在ます后，也能接名词、形容词词干、形容动词词干</div>  <div>この手で：用这双手。可以引申出「亲手」的意思。あの手この手で：千方百计</div></details><br><p class="hiragana"><span class="ruby"><span class="rb">不思議</span><span class="rt">ふしぎ</span></span>な<span class="ruby"><span class="rb">力</span><span class="rt">ちから</span></span>が<span class="ruby"><span class="rb">シンクロ</span><span class="rt">Sync</span></span>して<br><span class="ruby"><span class="rb">交差</span><span class="rt">こうさ</span></span>した<span class="ruby"><span class="rb">私</span><span class="rt">わたし</span></span>たちの<span class="ruby"><span class="rb">世界</span><span class="rt">せかい</span></span><br><span class="ruby"><span class="rb">何度</span><span class="rt">なんど</span></span>も<span class="ruby"><span class="rb">逢</span><span class="rt">あ</span></span>いたい、<span class="ruby"><span class="rb">エンドロール</span><span class="rt">End Roll</span></span>はまだ<br><span class="ruby"><span class="rb">知</span><span class="rt">し</span></span>らないままで、Let's RE-BOOT!<br></p><details>  <summary>点我查看解析</summary>  <div>不可思议的力量同步，在我们的世界交叉汇集</div>  <div>想和你数次相遇，我们还未结束</div>  <div>此刻仍是未知，让我们重启</div>  <div>何度も：需要区分「何度」和「何度も」，前者表示「多少次」，有疑问翻译；后者表示「好几次」。还有一个「何度でも」不管几次。</div>  <div>～はまだ：まだ名词活用，和原来的意思保持一致。还没有...</div></details><br><p class="hiragana"><span class="ruby"><span class="rb">ピンチ</span><span class="rt">Pinch</span></span>は<span class="ruby"><span class="rb">チャンス</span><span class="rt">Chance</span></span>に<span class="ruby"><span class="rb">上書</span><span class="rt">うわが</span></span>きして<br>どんな<span class="ruby"><span class="rb">世界</span><span class="rt">せかい</span></span>でも<span class="ruby"><span class="rb">大丈夫</span><span class="rt">だいじょうぶ</span></span><br><span class="ruby"><span class="rb">騒</span><span class="rt">さわ</span></span>がしいくらいがちょうどいいかもね<br><span class="ruby"><span class="rb">前世</span><span class="rt">ぜんせ</span></span>よりも<span class="ruby"><span class="rb">深</span><span class="rt">ふか</span></span>く<br><span class="ruby"><span class="rb">繋</span><span class="rt">つな</span></span>がる<span class="ruby"><span class="rb">愛</span><span class="rt">あい</span></span>を<span class="ruby"><span class="rb">コンティニュー</span><span class="rt">Continue</span></span><br></p><details>  <summary>点我查看解析</summary>  <div>逆境也会被重新改写为机会，无论是在哪个世界都没有关系</div>  <div>就算稍微有些吵闹，说不定正合我们的心意</div>  <div>相比于前世更加深沉，更紧密的爱，一直延续</div>  <div>上書きして：上書きる、改写，覆写</div>  <div>でも：どな...でも、无论怎样的...</div>  <div>くらい：名词接续，表示程度</div>  <div>ちょうど：表示正好。除此之外，它还有「稍微」的含义</div>  <div>ちょうどいいかもね：也许正合我意</div></details><h3 id="歌词分析"><a href="#歌词分析" class="headerlink" title="歌词分析"></a>歌词分析</h3><p>咕咕咕</p><h2 id="千恋＊万花"><a href="#千恋＊万花" class="headerlink" title="千恋＊万花"></a>千恋＊万花</h2><p>千恋＊万花是由 YUZU SOFT 制作的一部美少女游戏，是我入坑的第一部 Galgame！我永远喜欢朝武芳乃！！</p><p>柚子社白毛赛高！！柚子社（芳乃、宁宁）+崩坏星穹铁道（流萤）成功让我变成白毛控。</p><p>歌曲名称：恋ひ恋ふ縁（以恋结缘）</p><h3 id="传教时间-1"><a href="#传教时间-1" class="headerlink" title="传教时间"></a>传教时间</h3><p>贴一个官方的 OP 放到这里：</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 56.3%; margin: 20px 0"><iframe loading="lazy" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="//player.bilibili.com/player.html?isOutside=true&aid=1756355771&bvid=BV1L4421S7Kr&cid=1631476281&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe></div><p>全语音版本：</p><audio src="audio2.mp3" controls loop preload="metadata">  你的浏览器不支持 audio 标签。</audio><h3 id="歌词讲解-1"><a href="#歌词讲解-1" class="headerlink" title="歌词讲解"></a>歌词讲解</h3><p class="hiragana"><span class="ruby"><span class="rb">誠</span><span class="rt">まこと</span></span> <span class="ruby"><span class="rb">意地</span><span class="rt">いじ</span></span>の<span class="ruby"><span class="rb">悪</span><span class="rt">わる</span></span>い<span class="ruby"><span class="rb">神</span><span class="rt">かみ</span></span>の<span class="ruby"><span class="rb">所業</span><span class="rt">しょぎょう</span></span>か？<br><span class="ruby"><span class="rb">奇跡</span><span class="rt">きせき</span></span>？<span class="ruby"><span class="rb">縁</span><span class="rt">えにし</span></span>？<span class="ruby"><span class="rb">袂</span><span class="rt">たもと</span></span><span class="ruby"><span class="rb">触合</span><span class="rt">ふれあ</span></span>う<span class="ruby"><span class="rb">不思議</span><span class="rt">ふしぎ</span></span><br><span class="ruby"><span class="rb">花</span><span class="rt">はな</span></span>ひとひら<span class="ruby"><span class="rb">揺</span><span class="rt">ゆ</span></span>れて、<span class="ruby"><span class="rb">不意</span><span class="rt">ふい</span></span>に<span class="ruby"><span class="rb">宿</span><span class="rt">やど</span></span>ってた<br>うなじ<span class="ruby"><span class="rb">解</span><span class="rt">ほど</span></span>いてく<span class="ruby"><span class="rb">春風</span><span class="rt">はるかぜ</span></span><br></p><details>  <summary>点我查看解析</summary>  <div>难道是天意（神）不善，在戏谑人间？</div>  <div>奇迹还是缘分？这是不可思议的相遇。</div>  <div>摇曳的花儿，不经意地掩住自己，春风在脑后轻轻吹拂。（花儿丛中掩，春风抚我心）</div>  <div>誠（まこと）：真实，真诚，诚然。这里是问句的语句助词，很类似于向神明问「为什么」的虔诚感觉。</div>  <div>意地（いじ）：心术，用心；固执，倔强；志气，气魄。表达「神」可能是故意为之的意思。</div>  <div>所業：所作所为、行径。悪い神の所業：邪恶的神所作所为引申出「戏谑人间」的意思。</div>  <div>ひとひら：一片一枚，等同于いちまい。一片薄而平的一张。</div>  <div>不意に：不经意地。</div>  <div>うなじ：后脑勺。</div>  <div>解く：ほどく、とく。前一种意思包含了解开，还愿的意思。后一种在生活中用的更多：解开，拆开，解职等。</div></details><br><p class="hiragana"><span class="ruby"><span class="rb">戯</span><span class="rt">たわむ</span></span>れはそこそこに<br><span class="ruby"><span class="rb">恋手</span><span class="rt">こいて</span></span>ほどきしてくだしゃんせ<br><span class="ruby"><span class="rb">湯気</span><span class="rt">ゆげ</span></span>にほんのり<span class="ruby"><span class="rb">頬染</span><span class="rt">ほほそ</span></span>めて<br><span class="ruby"><span class="rb">夜風</span><span class="rt">よかぜ</span></span>に<span class="ruby"><span class="rb">願</span><span class="rt">ねが</span></span>ふ<br></p><details>  <summary>点我查看解析</summary>  <div>不要调笑他人，恋爱的绝妙之处需要向他人请教。</div>  <div>水汽渐渐粘上脸颊，心愿随夜风飘荡。</div></details><br><p class="hiragana">いざ！！<span class="ruby"><span class="rb">蝶</span><span class="rt">ちょう</span></span>と<span class="ruby"><span class="rb">舞</span><span class="rt">まい</span></span>ひ <span class="ruby"><span class="rb">花</span><span class="rt">はな</span></span>となりて<br><span class="ruby"><span class="rb">衣</span><span class="rt">きぬ</span></span>を<span class="ruby"><span class="rb">乱</span><span class="rt">みだ</span></span>して<span class="ruby"><span class="rb">祓</span><span class="rt">はら</span></span>いましょう<br>あやなしココロの<span class="ruby"><span class="rb">穢</span><span class="rt">けが</span></span>れ<br><span class="ruby"><span class="rb">故</span><span class="rt">ゆえ</span></span>！！<span class="ruby"><span class="rb">刀</span><span class="rt">とう</span></span>となり <span class="ruby"><span class="rb">楯</span><span class="rt">たて</span></span>となりて<br>この<span class="ruby"><span class="rb">想</span><span class="rt">おも</span></span>ひ<span class="ruby"><span class="rb">護</span><span class="rt">まも</span></span>り<span class="ruby"><span class="rb">賜</span><span class="rt">たま</span></span>え<br><span class="ruby"><span class="rb">君</span><span class="rt">きみ</span></span>が<span class="ruby"><span class="rb">恋</span><span class="rt">こい</span></span>の<span class="ruby"><span class="rb">門</span><span class="rt">もん</span></span>を<span class="ruby"><span class="rb">歩</span><span class="rt">あや</span></span>めた<br></p><details>  <summary>点我查看解析</summary>  <div>来吧，愿化作飞舞的花，</div>  <div>与蝶共舞，衣襟飘逸把禊祓除，</div>  <div>却仍旧不明白心中的污秽。</div>  <div>那便化作剑与盾，想着守护这心意，</div>  <div>你的恋障已经被铲除。</div></details><br><p class="hiragana"><span class="ruby"><span class="rb">恋</span><span class="rt">こい</span></span>の<span class="ruby"><span class="rb">罠</span><span class="rt">わな</span></span>は<span class="ruby"><span class="rb">密</span><span class="rt">ひそ</span></span>やかに<span class="ruby"><span class="rb">仕掛</span><span class="rt">しか</span></span>けなきゃ<br><span class="ruby"><span class="rb">次</span><span class="rt">つぎ</span></span>の<span class="ruby"><span class="rb">一手</span><span class="rt">いって</span></span> すけすけだから<span class="ruby"><span class="rb">困</span><span class="rt">こま</span></span>る<br><span class="ruby"><span class="rb">鍛錬</span><span class="rt">たんれん</span></span>じゃどうにもなんない<br><span class="ruby"><span class="rb">揺</span><span class="rt">ゆ</span></span>れる<span class="ruby"><span class="rb">心模様</span><span class="rt">こころもよう</span></span><br>どっちが<span class="ruby"><span class="rb">先</span><span class="rt">さき</span></span>だ？<span class="ruby"><span class="rb">恋煩</span><span class="rt">こいわずら</span></span>い<br></p><details>  <summary>点我查看解析</summary>  <div>恋爱的陷阱就是要机关算尽，</div>  <div>下一招却透露着困扰纠缠（下一招却马脚百出）。</div>  <div>锻炼也对摇摆不定的心态无济于事，</div>  <div>哪一个先陷入相思病（恋爱烦恼）呢？</div>  <div>すけすけ：透露着。すけすけだから：从...中透露出。</div>  <div>じゃ（では）どうにもなんない：无可奈何、无济于事。</div>  <div>どっち：哪一个。</div></details><br><p class="hiragana"><span class="ruby"><span class="rb">覚悟</span><span class="rt">かくご</span></span>して<span class="ruby"><span class="rb">通</span><span class="rt">とお</span></span>りゃんせ<br><span class="ruby"><span class="rb">夜道</span><span class="rt">よみち</span></span>と<span class="ruby"><span class="rb">乙女</span><span class="rt">おとめ</span></span>にご<span class="ruby"><span class="rb">用心</span><span class="rt">ようじん</span></span>♪<br><span class="ruby"><span class="rb">湯気</span><span class="rt">ゆげ</span></span>の<span class="ruby"><span class="rb">薫</span><span class="rt">かお</span></span>り<span class="ruby"><span class="rb">漂</span><span class="rt">ただよ</span></span>わせ、<span class="ruby"><span class="rb">誘</span><span class="rt">いざな</span></span>う<span class="ruby"><span class="rb">夜宴</span><span class="rt">やえん</span></span><br></p><details>  <summary>点我查看解析</summary>  <div>带着觉悟迈开步伐，小心夜路和少女哦！</div>  <div>散发着蒸汽香气，在引诱你前往夜宴处。</div>  <div>通りゃんせ：日本童谣，意思表示「步行」。通りゃんせ→お通りなさい→通りなさい。<a href="https://m.youtube.com/watch?v=fjMlnLxqir0">童谣链接</a></div>  <div>用心：注意，小心，提防。</div></details><br><p class="hiragana"><span class="ruby"><span class="rb">実</span><span class="rt">げ</span></span>に！<span class="ruby"><span class="rb">本日</span><span class="rt">ほんじつ</span></span>は<span class="ruby"><span class="rb">デート</span><span class="rt">Date</span></span><span class="ruby"><span class="rb">日和</span><span class="rt">ひより</span></span><br>しどけなく<span class="ruby"><span class="rb">誘</span><span class="rt">さそ</span></span>いましょ？<br><span class="ruby"><span class="rb">憑</span><span class="rt">つ</span></span>きませ、<span class="ruby"><span class="rb">偲</span><span class="rt">しの</span></span>ぶ<span class="ruby"><span class="rb">恋夢</span><span class="rt">こいゆめ</span></span><br></p><details>  <summary>点我查看解析</summary>  <div>其实！今天是约会的好日子。</div>  <div>何不不受拘束地放手邀约呢？</div>  <div>绝美恋梦请快快附身吧（快快显现）！</div>  <div>日和：天气，趋势，晴天</div>  <div>しどけない：杂乱，散乱、幼小的；这里的意思引申出「不受拘束地」</div>  <div>憑き：本质为付く，表示附身吧！的意思。后面ませ为ます型尊敬语。</div>  <div>偲ぶ：回忆，追忆，想念、欣赏</div>x</details><br><p class="hiragana"><span class="ruby"><span class="rb">故</span><span class="rt">ゆえ</span></span>！！<span class="ruby"><span class="rb">静</span><span class="rt">せい</span></span>となり <span class="ruby"><span class="rb">動</span><span class="rt">どう</span></span>となりて<br><span class="ruby"><span class="rb">我</span><span class="rt">われ</span></span>を<span class="ruby"><span class="rb">導</span><span class="rt">みちび</span></span>き<span class="ruby"><span class="rb">賜</span><span class="rt">たま</span></span>え<br><span class="ruby"><span class="rb">君</span><span class="rt">きみ</span></span>の<span class="ruby"><span class="rb">剣</span><span class="rt">けん</span></span>が<span class="ruby"><span class="rb">ハート</span><span class="rt">Heart</span></span>を<span class="ruby"><span class="rb">射抜</span><span class="rt">いぬ</span></span>いた<br></p><details>  <summary>点我查看解析</summary>  <div>所以！无论是动还是静，</div>  <div>都请引导我走上正途吧！</div>  <div>導く：引导，指导</div>  <div>導き賜え：请...做。复合动词尊敬语。请引导我走上正途。我的心早已被你的剑所俘获了。</div>  <div>射抜いた：射貫く，（枪弹，箭等）射穿</div></details><br><p class="hiragana">いざ！！<span class="ruby"><span class="rb">蝶</span><span class="rt">ちょう</span></span>と<span class="ruby"><span class="rb">舞</span><span class="rt">まい</span></span>ひ <span class="ruby"><span class="rb">花</span><span class="rt">はな</span></span>となりて<br><span class="ruby"><span class="rb">衣</span><span class="rt">きぬ</span></span>を<span class="ruby"><span class="rb">乱</span><span class="rt">みだ</span></span>して<span class="ruby"><span class="rb">祓</span><span class="rt">はら</span></span>いましょう<br><span class="ruby"><span class="rb">前世</span><span class="rt">ぜんせ</span></span>から<span class="ruby"><span class="rb">繋</span><span class="rt">つな</span></span>がる<span class="ruby"><span class="rb">運命</span><span class="rt">さだめ</span></span><br><span class="ruby"><span class="rb">故</span><span class="rt">ゆえ</span></span>！！<span class="ruby"><span class="rb">刀</span><span class="rt">とう</span></span>となり <span class="ruby"><span class="rb">花</span><span class="rt">はな</span></span>と<span class="ruby"><span class="rb">生</span><span class="rt">い</span></span>きて<br>この<span class="ruby"><span class="rb">愛</span><span class="rt">あい</span></span> <span class="ruby"><span class="rb">護</span><span class="rt">まも</span></span>り<span class="ruby"><span class="rb">賜</span><span class="rt">たまもの</span></span>え<br><span class="ruby"><span class="rb">君</span><span class="rt">きみ</span></span>はもう<span class="ruby"><span class="rb">縁</span><span class="rt">えにし</span></span>に<span class="ruby"><span class="rb">選</span><span class="rt">えら</span></span>ばれた<br></p><details>  <summary>点我查看解析</summary>  <div>来吧，愿化作飞舞的花，</div>  <div>与蝶共舞，衣襟飘逸把禊祓除，</div>  <div>前世开始紧密相连的命运。</div>  <div>那便化作剑，和花一起同生共死，</div>  <div>请守护好这份爱，姻缘已然选择了你啊！</div></details><h2 id="サノバウィッチ"><a href="#サノバウィッチ" class="headerlink" title="サノバウィッチ"></a>サノバウィッチ</h2><p>《魔女的夜宴》（日语：サノバウィッチ）是由柚子社制作发行的恋爱文字冒险游戏，于2015年2月27日发售。</p><p>虽然不是我最喜欢的一作，但是论推的角色平均好感，这一作的几位女主确实都很值得推，质量放废萌作中相当好。</p><p>歌曲名称：恋せよ乙女！（恋爱吧少女！）</p><h3 id="传教时间-2"><a href="#传教时间-2" class="headerlink" title="传教时间"></a>传教时间</h3><p>贴一个官方的 OP 放到这里：</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 56.3%; margin: 20px 0"><iframe loading="lazy" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://www.youtube.com/embed/W7ARsYs-Gq0?si=jKoSPGCQQRrar70x" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe></div><p>全语音版本：</p><audio src="audio4.mp3" controls loop preload="metadata">  你的浏览器不支持 audio 标签。</audio><h3 id="歌词讲解-2"><a href="#歌词讲解-2" class="headerlink" title="歌词讲解"></a>歌词讲解</h3><p class="hiragana">ミントソーダのその<span class="ruby"><span class="rb">先</span><span class="rt">さき</span></span>に <span class="ruby"><span class="rb">雨雲</span><span class="rt">あまぐも</span></span>を<span class="ruby"><span class="rb">連</span><span class="rt">つ</span></span>れてきた。。。<br><span class="ruby"><span class="rb">今</span><span class="rt">いま</span></span>にも<span class="ruby"><span class="rb">降</span><span class="rt">ふ</span></span>り<span class="ruby"><span class="rb">出</span><span class="rt">だ</span></span>しそうね ゆっくり<span class="ruby"><span class="rb">話</span><span class="rt">はなし</span></span><span class="ruby"><span class="rb">聞</span><span class="rt">き</span></span>こう!<br></p><details>  <summary>点我查看解析</summary></details><br><p class="hiragana"><span class="ruby"><span class="rb">小</span><span class="rt">ちい</span></span>さな<span class="ruby"><span class="rb">声</span><span class="rt">こえ</span></span>で<span class="ruby"><span class="rb">震</span><span class="rt">ふる</span></span>えながら <span class="ruby"><span class="rb">悲</span><span class="rt">かな</span></span>しみのその<span class="ruby"><span class="rb">先</span><span class="rt">さき</span></span>に<span class="ruby"><span class="rb">行</span><span class="rt">い</span></span>くなんて<br><span class="ruby"><span class="rb">晴</span><span class="rt">は</span></span>れわたる<span class="ruby"><span class="rb">空</span><span class="rt">そら</span></span>に <span class="ruby"><span class="rb">呪文</span><span class="rt">じゅもん</span></span>をかけよう!<br></p><details>  <summary>点我查看解析</summary></details><br><p class="hiragana"><span class="ruby"><span class="rb">心</span><span class="rt">こころ</span></span>のカケラ<span class="ruby"><span class="rb">集</span><span class="rt">あつ</span></span>めて <span class="ruby"><span class="rb">胸</span><span class="rt">むね</span></span>を<span class="ruby"><span class="rb">焦</span><span class="rt">こ</span></span>がす<span class="ruby"><span class="rb">痛</span><span class="rt">いた</span></span>みにkiss<br><span class="ruby"><span class="rb">明日</span><span class="rt">あした</span></span>は <span class="ruby"><span class="rb">追</span><span class="rt">お</span></span>い<span class="ruby"><span class="rb">風</span><span class="rt">かぜ</span></span>! <span class="ruby"><span class="rb">君</span><span class="rt">きみ</span></span>の<span class="ruby"><span class="rb">未来</span><span class="rt">みらい</span></span> <span class="ruby"><span class="rb">光</span><span class="rt">ひかり</span></span>に<span class="ruby"><span class="rb">包</span><span class="rt">つつ</span></span>まれるよ<br><span class="ruby"><span class="rb">涙</span><span class="rt">なみだ</span></span>は<span class="ruby"><span class="rb">宝石</span><span class="rt">ほうせき</span></span> <span class="ruby"><span class="rb">恋</span><span class="rt">こい</span></span>せよ<span class="ruby"><span class="rb">乙女</span><span class="rt">おとめ</span></span><span class="ruby"><span class="rb">達</span><span class="rt">たち</span></span>!<br></p><details>  <summary>点我查看解析</summary></details><br><p class="hiragana"><span class="ruby"><span class="rb">強</span><span class="rt">つよ</span></span>くて<span class="ruby"><span class="rb">頭</span><span class="rt">あたま</span></span>もよくて <span class="ruby"><span class="rb">完璧</span><span class="rt">かんぺき</span></span>な<span class="ruby"><span class="rb">人</span><span class="rt">ひと</span></span>だって<br><span class="ruby"><span class="rb">一人</span><span class="rt">ひとり</span></span>で<span class="ruby"><span class="rb">怯</span><span class="rt">おび</span></span>えていたり <span class="ruby"><span class="rb">逃</span><span class="rt">に</span></span>げる<span class="ruby"><span class="rb">時</span><span class="rt">とき</span></span>もあるよ<br></p><details>  <summary>点我查看解析</summary></details><br><p class="hiragana">そんな<span class="ruby"><span class="rb">時</span><span class="rt">とき</span></span>には<span class="ruby"><span class="rb">会</span><span class="rt">あ</span></span>いに<span class="ruby"><span class="rb">来</span><span class="rt">き</span></span>てね いつでもお<span class="ruby"><span class="rb">悩</span><span class="rt">なや</span></span>み<span class="ruby"><span class="rb">解決</span><span class="rt">かいけつ</span></span>するわ<br><span class="ruby"><span class="rb">抱</span><span class="rt">だ</span></span>きしめ<span class="ruby"><span class="rb">合</span><span class="rt">あ</span></span>えたら <span class="ruby"><span class="rb">呪文</span><span class="rt">じゅもん</span></span><span class="ruby"><span class="rb">奏</span><span class="rt">かな</span></span>でる<br></p><details>  <summary>点我查看解析</summary></details><br><p class="hiragana"><span class="ruby"><span class="rb">壊</span><span class="rt">こわ</span></span>れたカケラ<span class="ruby"><span class="rb">見</span><span class="rt">み</span></span>つけて <span class="ruby"><span class="rb">瞳</span><span class="rt">ひとみ</span></span><span class="ruby"><span class="rb">閉</span><span class="rt">と</span></span>じて<span class="ruby"><span class="rb">笑顔</span><span class="rt">えがお</span></span>のkiss<br><span class="ruby"><span class="rb">海</span><span class="rt">うみ</span></span>よりも<span class="ruby"><span class="rb">深</span><span class="rt">ふか</span></span>い <span class="ruby"><span class="rb">愛</span><span class="rt">あい</span></span>があること<span class="ruby"><span class="rb">君</span><span class="rt">きみ</span></span>だけに<span class="ruby"><span class="rb">伝</span><span class="rt">つた</span></span>えたい<br><span class="ruby"><span class="rb">言葉</span><span class="rt">ことば</span></span>より<span class="ruby"><span class="rb">先</span><span class="rt">さき</span></span>に <span class="ruby"><span class="rb">届</span><span class="rt">とど</span></span>けこの<span class="ruby"><span class="rb">恋心</span><span class="rt">こいごころ</span></span><br></p><details>  <summary>点我查看解析</summary></details><br><p class="hiragana"><span class="ruby"><span class="rb">心</span><span class="rt">こころ</span></span>のカケラ<span class="ruby"><span class="rb">集</span><span class="rt">あつ</span></span>めて いつもときめいて<span class="ruby"><span class="rb">笑顔</span><span class="rt">えがお</span></span>で<br><span class="ruby"><span class="rb">明日</span><span class="rt">あした</span></span>は <span class="ruby"><span class="rb">追</span><span class="rt">お</span></span>い<span class="ruby"><span class="rb">風</span><span class="rt">かぜ</span></span>! <span class="ruby"><span class="rb">君</span><span class="rt">きみ</span></span>の<span class="ruby"><span class="rb">未来</span><span class="rt">みらい</span></span> <span class="ruby"><span class="rb">光</span><span class="rt">ひかり</span></span>に<span class="ruby"><span class="rb">包</span><span class="rt">つつ</span></span>まれるよ<br><span class="ruby"><span class="rb">涙</span><span class="rt">なみだ</span></span>は<span class="ruby"><span class="rb">宝石</span><span class="rt">ほうせき</span></span> <span class="ruby"><span class="rb">恋</span><span class="rt">こい</span></span>せよ<span class="ruby"><span class="rb">乙女</span><span class="rt">おとめ</span></span><span class="ruby"><span class="rb">達</span><span class="rt">たち</span></span>!<br></p><details>  <summary>点我查看解析</summary></details><h2 id="RIDDLE-JOKER"><a href="#RIDDLE-JOKER" class="headerlink" title="RIDDLE JOKER"></a>RIDDLE JOKER</h2><p>《RIDDLE JOKER》是由柚子社制作的第十部Galgame，于2018年3月30日发售，Steam 版于2020年12月18日发售。</p><p>最甜的骨科之一。我永远喜欢在原七海！！</p><p>歌曲名称：astral ability</p><h3 id="传教时间-3"><a href="#传教时间-3" class="headerlink" title="传教时间"></a>传教时间</h3><p>贴一个官方的 OP 放到这里：</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 56.3%; margin: 20px 0"><iframe loading="lazy" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://www.youtube.com/embed/0EJ7HvJYe1M?si=elxO37miM2t138eY" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe></div><p>全语音版本：</p><audio src="audio3.mp3" controls loop preload="metadata">  你的浏览器不支持 audio 标签。</audio><h3 id="歌词讲解-3"><a href="#歌词讲解-3" class="headerlink" title="歌词讲解"></a>歌词讲解</h3><p class="hiragana"><span class="ruby"><span class="rb">秘密</span><span class="rt">ひみつ</span></span> <span class="ruby"><span class="rb">秘</span><span class="rt">ひ</span></span>めたるこのability<br>コントロールさせて <span class="ruby"><span class="rb">未知</span><span class="rt">みち</span></span>なる<span class="ruby"><span class="rb">世界</span><span class="rt">せかい</span></span>へ<br>さぁ<span class="ruby"><span class="rb">明日</span><span class="rt">あす</span></span>を<span class="ruby"><span class="rb">信</span><span class="rt">しん</span></span>じて<br></p><details>  <summary>点我查看解析</summary></details><br><p class="hiragana"><span class="ruby"><span class="rb">特殊</span><span class="rt">とくしゅ</span></span>だけど specialじゃない<br><span class="ruby"><span class="rb">気付</span><span class="rt">きづ</span></span>けば<span class="ruby"><span class="rb">手</span><span class="rt">て</span></span>にしていた<span class="ruby"><span class="rb">能力</span><span class="rt">のうりょく</span></span><br><span class="ruby"><span class="rb">普通</span><span class="rt">ふつう</span></span>に<span class="ruby"><span class="rb">見</span><span class="rt">み</span></span>えて normalじゃない<br>それがそうreality<br></p><details>  <summary>点我查看解析</summary></details><br><p class="hiragana"><span class="ruby"><span class="rb">同</span><span class="rt">おな</span></span>じ<span class="ruby"><span class="rb">時</span><span class="rt">とき</span></span> <span class="ruby"><span class="rb">瞬間</span><span class="rt">しゅんかん</span></span>を (<span class="ruby"><span class="rb">共</span><span class="rt">とも</span></span>に<span class="ruby"><span class="rb">過</span><span class="rt">す</span></span>ごし)<br><span class="ruby"><span class="rb">共有</span><span class="rt">きょうゆう</span></span>してゆけたなら (<span class="ruby"><span class="rb">少</span><span class="rt">すこ</span></span>しずつでも)<br>きっとそこで<span class="ruby"><span class="rb">生</span><span class="rt">う</span></span>まれる (<span class="ruby"><span class="rb">絆</span><span class="rt">きずな</span></span>がある)<br><span class="ruby"><span class="rb">潜入</span><span class="rt">せんにゅう</span></span>してまでも <span class="ruby"><span class="rb">通</span><span class="rt">とお</span></span>したいもの<br></p><details>  <summary>点我查看解析</summary></details><br><p class="hiragana">どんな<span class="ruby"><span class="rb">危険</span><span class="rt">きけん</span></span><span class="ruby"><span class="rb">待</span><span class="rt">ま</span></span>ち<span class="ruby"><span class="rb">受</span><span class="rt">う</span></span>けてても<br><span class="ruby"><span class="rb">譲</span><span class="rt">ゆず</span></span>れない (<span class="ruby"><span class="rb">確</span><span class="rt">たし</span></span>かな) ものがある<br><span class="ruby"><span class="rb">誰</span><span class="rt">だれ</span></span>かのこと<span class="ruby"><span class="rb">護</span><span class="rt">まも</span></span>るだけじゃなく<br>しっかりと (<span class="ruby"><span class="rb">自分</span><span class="rt">じぶん</span></span>も) <span class="ruby"><span class="rb">護</span><span class="rt">まも</span></span>らなきゃ<br><span class="ruby"><span class="rb">秘密</span><span class="rt">ひみつ</span></span> <span class="ruby"><span class="rb">秘</span><span class="rt">ひ</span></span>めたるこのability<br><span class="ruby"><span class="rb">意味</span><span class="rt">いみ</span></span>がある (<span class="ruby"><span class="rb">意味</span><span class="rt">いみ</span></span>を) それを (それを)<br><span class="ruby"><span class="rb">証明</span><span class="rt">しょうめい</span></span>してみせる<br>その<span class="ruby"><span class="rb">力</span><span class="rt">ちから</span></span><span class="ruby"><span class="rb">信</span><span class="rt">しん</span></span>じて<br></p><details>  <summary>点我查看解析</summary></details><br><p class="hiragana"><span class="ruby"><span class="rb">夢</span><span class="rt">ゆめ</span></span>みたいでも dreamじゃない<br><span class="ruby"><span class="rb">自然</span><span class="rt">しぜん</span></span>と<span class="ruby"><span class="rb">手</span><span class="rt">て</span></span>にしていた<span class="ruby"><span class="rb">能力</span><span class="rt">のうりょく</span></span><br><span class="ruby"><span class="rb">日常</span><span class="rt">にちじょう</span></span>でも everydayじゃない<br>それもそうreality<br></p><details>  <summary>点我查看解析</summary></details><br><p class="hiragana"><span class="ruby"><span class="rb">怪</span><span class="rt">あや</span></span>しい<span class="ruby"><span class="rb">影</span><span class="rt">かげ</span></span>がどこかで (<span class="ruby"><span class="rb">動</span><span class="rt">うご</span></span>き<span class="ruby"><span class="rb">出</span><span class="rt">だ</span></span>して)<br>スリルを<span class="ruby"><span class="rb">感</span><span class="rt">かん</span></span>じたって (たじろがないわ)<br><span class="ruby"><span class="rb">決</span><span class="rt">けっ</span></span>して<span class="ruby"><span class="rb">一人</span><span class="rt">ひとり</span></span>じゃないと (<span class="ruby"><span class="rb">思</span><span class="rt">おも</span></span>えるから)<br><span class="ruby"><span class="rb">背筋</span><span class="rt">せすじ</span></span>を<span class="ruby"><span class="rb">伸</span><span class="rt">の</span></span>ばして<span class="ruby"><span class="rb">歩</span><span class="rt">ある</span></span>いて<span class="ruby"><span class="rb">行</span><span class="rt">ゆ</span></span>ける<br></p><details>  <summary>点我查看解析</summary></details><br><p class="hiragana"><span class="ruby"><span class="rb">想像</span><span class="rt">そうぞう</span></span><span class="ruby"><span class="rb">超</span><span class="rt">こ</span></span>える<span class="ruby"><span class="rb">物</span><span class="rt">もの</span></span>がこの<span class="ruby"><span class="rb">世</span><span class="rt">よ</span></span>には<br>まだもっと (<span class="ruby"><span class="rb">確</span><span class="rt">たし</span></span>かに) <span class="ruby"><span class="rb">溢</span><span class="rt">あふ</span></span>れてる<br><span class="ruby"><span class="rb">経験</span><span class="rt">けいけん</span></span>して<span class="ruby"><span class="rb">学</span><span class="rt">まな</span></span>んで<span class="ruby"><span class="rb">行</span><span class="rt">ゆ</span></span>きながら<br>しっかりと (<span class="ruby"><span class="rb">自分</span><span class="rt">じぶん</span></span>も) <span class="ruby"><span class="rb">進</span><span class="rt">すす</span></span>まなきゃ<br><span class="ruby"><span class="rb">秘密</span><span class="rt">ひみつ</span></span> <span class="ruby"><span class="rb">秘</span><span class="rt">ひ</span></span>めたるこのability<br>コントロール (<span class="ruby"><span class="rb">制御</span><span class="rt">せいぎょ</span></span>) させて (させて)<br><span class="ruby"><span class="rb">未知</span><span class="rt">みち</span></span>なる<span class="ruby"><span class="rb">世界</span><span class="rt">せかい</span></span>へ<br>さぁ<span class="ruby"><span class="rb">明日</span><span class="rt">あす</span></span>を<span class="ruby"><span class="rb">信</span><span class="rt">しん</span></span>じて<br></p><details>  <summary>点我查看解析</summary></details><br><p class="hiragana">(この<span class="ruby"><span class="rb">瞳</span><span class="rt">ひとみ</span></span>) <span class="ruby"><span class="rb">瞳</span><span class="rt">ひとみ</span></span>をこらして <span class="ruby"><span class="rb">前</span><span class="rt">まえ</span></span>を<span class="ruby"><span class="rb">見</span><span class="rt">み</span></span>つめて<br>どんな<span class="ruby"><span class="rb">危険</span><span class="rt">きけん</span></span><span class="ruby"><span class="rb">待</span><span class="rt">ま</span></span>ち<span class="ruby"><span class="rb">受</span><span class="rt">う</span></span>けてても<br><span class="ruby"><span class="rb">譲</span><span class="rt">ゆず</span></span>れない (<span class="ruby"><span class="rb">確</span><span class="rt">たし</span></span>かな) ものがある<br><span class="ruby"><span class="rb">誰</span><span class="rt">だれ</span></span>かのこと<span class="ruby"><span class="rb">護</span><span class="rt">まも</span></span>るだけじゃなく<br>しっかりと (<span class="ruby"><span class="rb">自分</span><span class="rt">じぶん</span></span>も) <span class="ruby"><span class="rb">護</span><span class="rt">まも</span></span>らなきゃ<br><span class="ruby"><span class="rb">秘密</span><span class="rt">ひみつ</span></span> <span class="ruby"><span class="rb">秘</span><span class="rt">ひ</span></span>めたるこのability<br><span class="ruby"><span class="rb">意味</span><span class="rt">いみ</span></span>がある (<span class="ruby"><span class="rb">意味</span><span class="rt">いみ</span></span>を) それを (それを)<br><span class="ruby"><span class="rb">証明</span><span class="rt">しょうめい</span></span>してみせる<br>その<span class="ruby"><span class="rb">力</span><span class="rt">ちから</span></span><span class="ruby"><span class="rb">信</span><span class="rt">しん</span></span>じて<br></p><details>  <summary>点我查看解析</summary></details><h2 id="天色＊アイルノーツ"><a href="#天色＊アイルノーツ" class="headerlink" title="天色＊アイルノーツ"></a>天色＊アイルノーツ</h2><p>《天色幻想岛》（日文：天色＊アイルノーツ），是YUZU SOFT于2013年7月26日所发售的恋爱冒险游戏，为其第七部作品。</p><p><s>臭 mmr 二次元见识少，师生恋都玩的这么花了么。</s></p><p>歌曲名称：Blue-Love Chime</p><h3 id="传教时间-4"><a href="#传教时间-4" class="headerlink" title="传教时间"></a>传教时间</h3><p>贴一个官方的 OP 放到这里：</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 56.3%; margin: 20px 0"><iframe loading="lazy" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://www.youtube.com/embed/kHrNOxcT1lc?si=LMt3zZ3Q69wIgujN" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe></div><h3 id="歌词讲解-4"><a href="#歌词讲解-4" class="headerlink" title="歌词讲解"></a>歌词讲解</h3><p class="hiragana">どこまでも <span class="ruby"><span class="rb">穏</span> <span class="rt">おだ</span></span> やか に<br><span class="ruby"><span class="rb">流</span> <span class="rt">なが</span></span> れ てく <span class="ruby"><span class="rb">日常</span> <span class="rt">にちじょう</span></span><br>それ は とても <span class="ruby"><span class="rb">青</span> <span class="rt">あお</span></span> くっ て<br><span class="ruby"><span class="rb">美</span> <span class="rt">うつく</span></span> しい <span class="ruby"><span class="rb">シーン</span> <span class="rt">しーん</span></span></p><details>  <summary>点我查看解析</summary></details><br><p class="hiragana">やわらか な <span class="ruby"><span class="rb">日差</span> <span class="rt">ひざ</span></span> し の <span class="ruby"><span class="rb">中</span> <span class="rt">なか</span></span><br><span class="ruby"><span class="rb">君</span> <span class="rt">くん</span></span> が <span class="ruby"><span class="rb">微笑</span> <span class="rt">ほほえ</span></span> ん で<br>ふい に <span class="ruby"><span class="rb">胸</span> <span class="rt">むね</span></span> が きゅんと し た の<br><span class="ruby"><span class="rb">私</span> <span class="rt">わたし</span></span> の <span class="ruby"><span class="rb">中</span> <span class="rt">なか</span></span> で <span class="ruby"><span class="rb">何</span> <span class="rt">なに</span></span> か が <span class="ruby"><span class="rb">音</span> <span class="rt">おと</span></span> を<br><span class="ruby"><span class="rb">立</span> <span class="rt">た</span></span> て て <span class="ruby"><span class="rb">変</span> <span class="rt">か</span></span> わっ て いく よ<br></p><details>  <summary>点我查看解析</summary></details><br><p class="hiragana">こんな やさしい <span class="ruby"><span class="rb">想</span> <span class="rt">おも</span></span> い が<br>ずっと <span class="ruby"><span class="rb">続</span> <span class="rt">つづ</span></span> き ます よう に と<br><span class="ruby"><span class="rb">握</span> <span class="rt">にぎ</span></span> っ た <span class="ruby"><span class="rb">左手</span> <span class="rt">ひだりて</span></span> に <span class="ruby"><span class="rb">力</span> <span class="rt">ちから</span></span> を <span class="ruby"><span class="rb">込</span> <span class="rt">こ</span></span> め て<br><span class="ruby"><span class="rb">走</span> <span class="rt">はし</span></span> り <span class="ruby"><span class="rb">出</span> <span class="rt">だ</span></span> し た ん だ<br></p><details>  <summary>点我查看解析</summary></details><br><p class="hiragana"><span class="ruby"><span class="rb">響</span> <span class="rt">ひび</span></span> き <span class="ruby"><span class="rb">渡</span> <span class="rt">わた</span></span> る <span class="ruby"><span class="rb">鐘</span> <span class="rt">かね</span></span> の <span class="ruby"><span class="rb">音</span> <span class="rt">ね</span></span> が<br><span class="ruby"><span class="rb">恋</span> <span class="rt">こい</span></span> の <span class="ruby"><span class="rb">始</span> <span class="rt">はじ</span></span> まり を <span class="ruby"><span class="rb">告</span> <span class="rt">つ</span></span> げる<br>ねぇ <span class="ruby"><span class="rb">私</span> <span class="rt">わたし</span></span> <span class="ruby"><span class="rb">君</span> <span class="rt">くん</span></span> の こと が <span class="ruby"><span class="rb">大好</span> <span class="rt">だいす</span></span> き だ<br></p><details>  <summary>点我查看解析</summary></details><br><p class="hiragana"><span class="ruby"><span class="rb">キラキラ</span> <span class="rt">きらきら</span></span> と <span class="ruby"><span class="rb">輝</span> <span class="rt">かがや</span></span> き <span class="ruby"><span class="rb">出</span> <span class="rt">だ</span></span> し た<br><span class="ruby"><span class="rb">恋心</span> <span class="rt">こいごころ</span></span> は そう まるで <span class="ruby"><span class="rb">宝石</span> <span class="rt">ほうせき</span></span> の よう で<br>（ <span class="ruby"><span class="rb">魔法</span> <span class="rt">まほう</span></span> みたい に ）<br>ふたり の <span class="ruby"><span class="rb">未来</span> <span class="rt">みらい</span></span> <span class="ruby"><span class="rb">彩</span> <span class="rt">いろど</span></span> る<br></p><details>  <summary>点我查看解析</summary></details><br><p class="hiragana"><span class="ruby"><span class="rb">石畳</span> <span class="rt">いしだたみ</span></span> の <span class="ruby"><span class="rb">街並</span> <span class="rt">まちな</span></span> み <span class="ruby"><span class="rb">肩</span> <span class="rt">かた</span></span> <span class="ruby"><span class="rb">並</span> <span class="rt">なら</span></span> べ て <span class="ruby"><span class="rb">歩</span> <span class="rt">ある</span></span> く<br><span class="ruby"><span class="rb">今</span> <span class="rt">いま</span></span> まで <span class="ruby"><span class="rb">知</span> <span class="rt">し</span></span> ら なかっ た<br>ぬくもり が ある<br></p><details>  <summary>点我查看解析</summary></details><br><p class="hiragana"><span class="ruby"><span class="rb">想像</span> <span class="rt">そうぞう</span></span> も し て なかっ た よ<br><span class="ruby"><span class="rb">当</span> <span class="rt">あ</span></span> たり <span class="ruby"><span class="rb">前</span> <span class="rt">まえ</span></span> の この <span class="ruby"><span class="rb">景色</span> <span class="rt">けしき</span></span> が<br><span class="ruby"><span class="rb">違</span> <span class="rt">ちが</span></span> っ て <span class="ruby"><span class="rb">見</span> <span class="rt">み</span></span> える なんて<br><span class="ruby"><span class="rb">初</span> <span class="rt">はじ</span></span> めて の <span class="ruby"><span class="rb">気持</span> <span class="rt">きも</span></span> ち に <span class="ruby"><span class="rb">戸惑</span> <span class="rt">とまど</span></span> い ながら<br><span class="ruby"><span class="rb">恥</span> <span class="rt">は</span></span> ずかしく なる よ<br></p><details>  <summary>点我查看解析</summary></details><br><p class="hiragana"><span class="ruby"><span class="rb">君</span> <span class="rt">くん</span></span> に は <span class="ruby"><span class="rb">バレ</span> <span class="rt">ばれ</span></span> ない よう に<br>その <span class="ruby"><span class="rb">横顔</span> <span class="rt">よこがお</span></span> を <span class="ruby"><span class="rb">見</span> <span class="rt">み</span></span> て いる<br>「 <span class="ruby"><span class="rb">ドキドキ</span> <span class="rt">どきどき</span></span> 」<br><span class="ruby"><span class="rb">聞</span> <span class="rt">き</span></span> こえ そう な くらい に<br><span class="ruby"><span class="rb">スピード</span> <span class="rt">すぴーど</span></span> を <span class="ruby"><span class="rb">上</span> <span class="rt">あ</span></span> げ て ゆく よ<br></p><details>  <summary>点我查看解析</summary></details><br><p class="hiragana">あの <span class="ruby"><span class="rb">澄</span> <span class="rt">す</span></span> み <span class="ruby"><span class="rb">渡</span> <span class="rt">わた</span></span> る <span class="ruby"><span class="rb">空</span> <span class="rt">そら</span></span> の よう に<br><span class="ruby"><span class="rb">嘘偽</span> <span class="rt">うそいつわ</span></span> り ない <span class="ruby"><span class="rb">想</span> <span class="rt">おも</span></span> い<br>ねぇ <span class="ruby"><span class="rb">君</span> <span class="rt">きみ</span></span> に <span class="ruby"><span class="rb">伝</span> <span class="rt">つた</span></span> え たい よ<br>いい かな ？<br></p><details>  <summary>点我查看解析</summary></details><br><p class="hiragana">きっと <span class="ruby"><span class="rb">隠</span> <span class="rt">かく</span></span> し き れ て なく て<br>ふい に ぶつかっ た <span class="ruby"><span class="rb">視線</span> <span class="rt">しせん</span></span><br>もう <span class="ruby"><span class="rb">逸</span> <span class="rt">そ</span></span> らさ ない よ<br>（ まっすぐ に <span class="ruby"><span class="rb">見</span> <span class="rt">み</span></span> て ）<br>ふたり の <span class="ruby"><span class="rb">ストーリー</span> <span class="rt">すとーりー</span></span> <span class="ruby"><span class="rb">描</span> <span class="rt">えが</span></span> こ う<br></p><details>  <summary>点我查看解析</summary></details><br><p class="hiragana"><span class="ruby"><span class="rb">響</span> <span class="rt">ひび</span></span> き <span class="ruby"><span class="rb">渡</span> <span class="rt">わた</span></span> る <span class="ruby"><span class="rb">鐘</span> <span class="rt">かね</span></span> の <span class="ruby"><span class="rb">音</span> <span class="rt">ね</span></span> が<br><span class="ruby"><span class="rb">恋</span> <span class="rt">こい</span></span> の <span class="ruby"><span class="rb">始</span> <span class="rt">はじ</span></span> まり を <span class="ruby"><span class="rb">告</span> <span class="rt">つ</span></span> げる<br>ねぇ <span class="ruby"><span class="rb">私</span> <span class="rt">わたし</span></span> <span class="ruby"><span class="rb">君</span> <span class="rt">くん</span></span> の こと が <span class="ruby"><span class="rb">大好</span> <span class="rt">だいす</span></span> き だ<br></p><details>  <summary>点我查看解析</summary></details><br><p class="hiragana"><span class="ruby"><span class="rb">キラキラ</span> <span class="rt">きらきら</span></span> と <span class="ruby"><span class="rb">輝</span> <span class="rt">かがや</span></span> き <span class="ruby"><span class="rb">出</span> <span class="rt">だ</span></span> し た<br><span class="ruby"><span class="rb">恋心</span> <span class="rt">こいごころ</span></span> は そう まるで <span class="ruby"><span class="rb">宝石</span> <span class="rt">ほうせき</span></span> の よう で<br>（ <span class="ruby"><span class="rb">魔法</span> <span class="rt">まほう</span></span> みたい に ）<br>ふたり の <span class="ruby"><span class="rb">未来</span> <span class="rt">みらい</span></span> <span class="ruby"><span class="rb">彩</span> <span class="rt">いろど</span></span> る<br></p><details>  <summary>点我查看解析</summary></details><h2 id="附：转换-ruby-标签到博客样式的代码"><a href="#附：转换-ruby-标签到博客样式的代码" class="headerlink" title="附：转换 ruby 标签到博客样式的代码"></a>附：转换 ruby 标签到博客样式的代码</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 转换标签</span><span class="token keyword">function</span> <span class="token function">convertTags</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> rubyElements <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">"ruby"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> ruby <span class="token keyword">of</span> rubyElements<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> spans <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> children <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>ruby<span class="token punctuation">.</span>childNodes<span class="token punctuation">)</span><span class="token punctuation">;</span>    children<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">child</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>        child<span class="token punctuation">.</span>nodeName<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">"rb"</span> <span class="token operator">||</span>        child<span class="token punctuation">.</span>nodeName<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">"rt"</span>      <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">const</span> span <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"span"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        span<span class="token punctuation">.</span>className <span class="token operator">=</span> child<span class="token punctuation">.</span>nodeName<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        span<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> child<span class="token punctuation">.</span>innerHTML<span class="token punctuation">;</span>        ruby<span class="token punctuation">.</span><span class="token function">replaceChild</span><span class="token punctuation">(</span>span<span class="token punctuation">,</span> child<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>child<span class="token punctuation">.</span>nodeName<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">"rp"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 删除 rp 标签</span>        ruby<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 处理 ruby 中没有被标签套用的字符</span>    <span class="token keyword">const</span> textNodes <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>ruby<span class="token punctuation">.</span>childNodes<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>      <span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token operator">=></span> node<span class="token punctuation">.</span>nodeType <span class="token operator">===</span> Node<span class="token punctuation">.</span><span class="token constant">TEXT_NODE</span> <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>nodeValue<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>    textNodes<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">textNode</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      <span class="token keyword">const</span> span <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"span"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      span<span class="token punctuation">.</span>className <span class="token operator">=</span> <span class="token string">"rb"</span><span class="token punctuation">;</span>      span<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> textNode<span class="token punctuation">.</span>nodeValue<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      ruby<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>span<span class="token punctuation">,</span> textNode<span class="token punctuation">)</span><span class="token punctuation">;</span>      ruby<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>textNode<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 删除 class 为 morpheme 的 span 标签</span><span class="token keyword">function</span> <span class="token function">removeMorphemeSpans</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> morphemeSpans <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">"span.morpheme"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  morphemeSpans<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">span</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> parent <span class="token operator">=</span> span<span class="token punctuation">.</span>parentNode<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>span<span class="token punctuation">.</span>firstChild<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      parent<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>span<span class="token punctuation">.</span>firstChild<span class="token punctuation">,</span> span<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    parent<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>span<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 删除 class 为 line 的 div 标签，保留其所有子元素</span><span class="token keyword">function</span> <span class="token function">removeLineDivs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> lineDivs <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">"div.line"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> lineDivArray <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>lineDivs<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> div <span class="token keyword">of</span> lineDivArray<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>div<span class="token punctuation">.</span>innerText<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">continue</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">const</span> parent <span class="token operator">=</span> div<span class="token punctuation">.</span>parentNode<span class="token punctuation">;</span>    <span class="token comment">// 将 div 的子元素移到 div 的父节点</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>div<span class="token punctuation">.</span>firstChild<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      parent<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>div<span class="token punctuation">.</span>firstChild<span class="token punctuation">,</span> div<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 添加新的 &lt;br> 元素</span>    div<span class="token punctuation">.</span><span class="token function">before</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"br"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 删除 div 标签</span>    div<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">convertRubyTags</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> rubyElements <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">"ruby"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> rubyElementArray <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>rubyElements<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> ruby <span class="token keyword">of</span> rubyElementArray<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 创建新的 span 标签</span>    <span class="token keyword">const</span> rubySpan <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"span"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    rubySpan<span class="token punctuation">.</span>className <span class="token operator">=</span> <span class="token string">"ruby"</span><span class="token punctuation">;</span>    <span class="token comment">// 将 ruby 的所有子节点移动到新的 span 中</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>ruby<span class="token punctuation">.</span>firstChild<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      rubySpan<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>ruby<span class="token punctuation">.</span>firstChild<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 替换原 ruby 标签</span>    ruby<span class="token punctuation">.</span><span class="token function">before</span><span class="token punctuation">(</span>rubySpan<span class="token punctuation">)</span><span class="token punctuation">;</span>    ruby<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">removeMorphemeSpans</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">convertTags</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">convertRubyTags</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">removeLineDivs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>得到的 html 代码可以在这里进一步格式化：</p><p><a href="https://www.w3cschool.cn/tools/index?name=html_minifier">https://www.w3cschool.cn/tools/index?name=html_minifier</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="日本語" scheme="https://blog.pengdonglai.com/tags/%E6%97%A5%E6%9C%AC%E8%AA%9E/"/>
    
    <category term="Galgame" scheme="https://blog.pengdonglai.com/tags/Galgame/"/>
    
    <category term="琐碎" scheme="https://blog.pengdonglai.com/tags/%E7%90%90%E7%A2%8E/"/>
    
  </entry>
  
  <entry>
    <title>N3 日语部分语法点归总</title>
    <link href="https://blog.pengdonglai.com/2024/08/11/japanese-grammar-2/"/>
    <id>https://blog.pengdonglai.com/2024/08/11/japanese-grammar-2/</id>
    <published>2024-08-11T04:18:41.000Z</published>
    <updated>2024-09-22T09:18:57.151Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>本文仍在加工中… 本文中「字」作为词性说明表示「字典型」，就是大家熟悉的动词原形。</p></blockquote><h2 id="关于-N3"><a href="#关于-N3" class="headerlink" title="关于 N3"></a>关于 N3</h2><p>2010年日本语能力考试进行了全面改版，将原来的四个级别调整为五个级别。其中N3就是新增设的级别，依此来解决原来的二级考试与三级考试水平差异较大的问题。新考试与原来考试水平对应如下：</p><p>日语N1级：与原来的1级水平及评价合格标准大体相同，只是在原有的基础上提高测定能否达到某种运用能力的难度范围。<br>日语N2级：与现行的2级水平大体相同<br>日语N3级：在现行的2级与3级之间的水平<br>日语N4级：与现行的3级水平大体相同<br>日语N5级：与现行的4级水平大体相同</p><p>在 JIPT 的定义上看：N3属于中等水平，基本语法，汉字300字左右，词汇1500左右，能够使用日常生活会话，能够阅读简单文章，日语学习时间大约300小时，初级日语全部掌握的程度。</p><p>因此，N3在 JIPT 中属于中等水平。这个时候属于承上启下的阶段，对于 N4、N5 的知识点需要融会贯通，才能对 N2 以上高难的知识点进行突破。</p><p>本文会以分类的形式，对 N3 涉及到的知识点，进行融合总结。其中也会有对于 N4N5 涉及到的一些知识点的梳理，它们通常来说是作为 N3 知识点需要被用于区分的部分。</p><h2 id="第一类：时间（时间频度、时间程度）"><a href="#第一类：时间（时间频度、时间程度）" class="headerlink" title="第一类：时间（时间频度、时间程度）"></a>第一类：时间（时间频度、时间程度）</h2><h3 id="ごとに、おきに、たびに"><a href="#ごとに、おきに、たびに" class="headerlink" title="ごとに、おきに、たびに"></a>ごとに、おきに、たびに</h3><p>(名·数·字) ごとに (每)</p><p>(数) おきに (有隔)</p><p>(名の·字) たびに (每次)</p><p>三者前面接续不一样。たびに（每次）前面不能加数量词的，ごとに（每）的前面不能加动词性的名词。</p><p>时间单位大于等于天，ごとに（每）・おきに（每间隔）两者存在区别。两者均表示时间频率，但后者实际上在这种情况下是前者的两倍。小于 1 天，两者表达意思完全一样，不用区分。</p><p>名词+ごとに，表示：连带着前面的名词，一起做。</p><ol><li>一つ失敗する <strong>(ごとに·たびに)</strong> また一つ成長する。</li></ol><p>接续动词原形的时候，ごとに・たびに表达的意思是完全一样的。需要注意的是，ごとに之前接名词的时候，是不用加の的。</p><ol start="2"><li>このシステムは1年 <strong>(ごとに、おきに)</strong> 連新される。</li></ol><p>たびに不可以接在表示数量的名词后面。中文可以说的通，每次一年。但是日语里面不可以这么表达。</p><ol start="3"><li>駅へ向かうバスは15分 <strong>(ごとに、おきに)</strong> 出ている。</li></ol><p>同上。</p><ol start="4"><li>5メートル <strong>(ごとに、おきに)</strong> 置く。</li></ol><p>同上。</p><ol start="5"><li>リんごを皮 <strong>ごと</strong> 食べる。</li></ol><p>ごと（に）可以接续名词。但需要注意不能是动作性的名词。</p><ol start="6"><li>デートの <strong>たびに</strong> 必ずお腹が痛くなる。ごとに(×)</li></ol><p>接续たびに之前的名词，需要加の。不能用ごとに。</p><ol start="7"><li>運動の <strong>たびに</strong> 痩せていく。ごとに(×)</li></ol><p>同上，不能用ごとに。</p><ol start="8"><li>1日 <strong>ごとに</strong> 痩せていく。たびに(×)</li></ol><p>たびに前面不能接表示数量的名词。</p><h3 id="くらい、ほど、ごろ"><a href="#くらい、ほど、ごろ" class="headerlink" title="くらい、ほど、ごろ"></a>くらい、ほど、ごろ</h3><p>(数) くらい・ぐらい (左右)</p><p>(数·名) ほど (左右、如…一样)</p><p>(数·形·名の) ごろ (左右、时候)</p><p>三者前面接续不一样。</p><p>くらい・ぐらい能表示时间点的左右。例如 10 时左右：１０時くらい；10 小时左右：１０時間くらい；</p><p>ほど只能表示时间段的左右。10 小时、1 天左右：１０時間ほど・１日ほど</p><p>ごろ只能表达时间点的左右。</p><ol start="9"><li>今日の会議は3時 <strong>(くらい・ぐらい・ごと)</strong> 始まる。</li></ol><p>表示时间点，不能用ほど。</p><ol start="10"><li>大阪から東京まで3時間 <strong>(くらい・ぐらい・ほど)</strong> かかる。</li></ol><p>表示时间段，不能用ごろ。</p><ol start="11"><li>仕事は山<strong>ほど</strong>ある。</li></ol><p>N＋ほど的时候，ほど表示比喻：如…一样。这句话的意思是「工作像山一样」，表示有很多工作。</p><ol start="12"><li>若い子供の<strong>ころに</strong>、日本へ行ったことがある。</li></ol><p>N＋ころ的时候，表示「时候」。这种情况对于形容词接续也适用。</p><h2 id="第二类：状态（何时间、何状态）"><a href="#第二类：状态（何时间、何状态）" class="headerlink" title="第二类：状态（何时间、何状态）"></a>第二类：状态（何时间、何状态）</h2><h3 id="場合、際"><a href="#場合、際" class="headerlink" title="場合、際"></a>場合、際</h3><p>(普·形·名の) 場合 (时候、情况)</p><p>可以跟時（とき）混用。可以看例句 1。</p><p>(た·字·名の) 際 (时候、之际)</p><p>什么什么之际。相比于時・場合更加正式。两者表达的意思完全一致，但是際更加正式。</p><p>際一般情况下不加动词否定，也不加形容词。</p><ol><li><p>パスワードを忘れた **(場合、時)**、こ連絡くださ。</p></li><li><p>体調が悪い <strong>場合</strong> は、休んでもいいです。</p></li><li><p>雨の <strong>場合</strong>、試合は中止です。</p></li><li><p>免許を更新する **(際、時)**、写真は必要だ。</p></li></ol><p>这种情况下可以多种情况混用，只是正式情况有所区别。際一般情况下不加动词否定，也不加形容词。</p><ol start="5"><li>お困りの <strong>際</strong> は、いってもご連絡ください。</li></ol><p>お困りの是一种非常尊敬的用法，当您遇到了…</p><h3 id="まま、っぱなし"><a href="#まま、っぱなし" class="headerlink" title="まま、っぱなし"></a>まま、っぱなし</h3><p>(た·ない·名の) まま (搁置、一直)</p><p>(ます形) っぱなし (搁置、一直)</p><p>很多时候可以互换使用。<strong>っぱなし前面只能接ます型</strong>。在「一直否定」的状态中。这种情况只能用まま。这种情况在ない＋まま这种接续中出现。まま这种形态，表达出来的状态，需要是可以被看到的。っぱなし可以表达「看不到的动作」「一直在进行没有结局」。如：一直在唱歌、一直在走路。</p><ol><li>メがネをかけた<strong>まま</strong>寝た。メがネをかけ<strong>っぱなし</strong>で寝た。</li></ol><p>这种情况下，两者都能用。但是っぱなしで之前必须将名词改造成ます型，两者表达的意思是完全一样的。<br><strong>即便是前面的动词，没有表达过去时概念。</strong></p><ol start="7"><li>ずっと分からない<strong>まま</strong>だ。</li></ol><p>在「一直否定」的状态中。这种情况只能用まま。这种情况在ない＋まま这种接续中出现。</p><ol start="8"><li>２４時間走りっぱなしで、疲れた。</li></ol><p>除此之外，まま这种形态，表达出来的状态，需要是可以被看到的。っぱなし可以表达「看不到的动作」「一直在进行没有结局」这种情况。</p><p>例如：一直在唱歌、一直在走路。这种情况适合用っぱなし。二十四小时都在跑步。</p><h3 id="ずに、ず"><a href="#ずに、ず" class="headerlink" title="ずに、ず"></a>ずに、ず</h3><p>(ない形) ずに (&#x3D;ないで、不做)</p><p>(ない形) ず (&#x3D;なくで、不做)</p><p>他们相当于分别替换ないで、なくで。等同于两者的区别。</p><ol start="9"><li><p>挨拶も **(せずに、しないで)**、出て行った。</p></li><li><p>砂糖を入れ　**(ずに、ないで)**、飲む。</p></li></ol><p>表示两个先后的动作，前面的动作没做，就做了后面的动作。</p><ol start="11"><li><p>日本へ行け **(ず、なくて)**、残念です。</p></li><li><p>お金が <strong>なくて</strong>、大変だ。</p></li></ol><p>形容名词的时候，なくて不能换成ず。</p><h2 id="第三类：条件（如果、一…就…）"><a href="#第三类：条件（如果、一…就…）" class="headerlink" title="第三类：条件（如果、一…就…）"></a>第三类：条件（如果、一…就…）</h2><h3 id="たら、と、ば"><a href="#たら、と、ば" class="headerlink" title="たら、と、ば"></a>たら、と、ば</h3><p>たら（一…就、如果…的话、做了…之后）</p><p>と（一…就、做了…之后）</p><p>ば（一…就、如果…的话）</p><p>均有一…就，的含义。可以表示自然现象，物理规则。但是ば不可以用来描述过去的物理规则。除此之外，たら、と可以用来表示突然发生的一件事情，此时也没有ば的用法。</p><p>如果…的话：后面的句子，并不表达必然的结果。</p><p>たら表示如果…的话，通常来说表示「单独的一次事件」。たら相比于と更加口语化。</p><p>ば表示如果…的话的含义的时候，后面不可以出现意志，命令，请求的形式。除非一些特殊情况，例如前后主语不是同一个。或者前半句话表示某个事情的状态。</p><p>と、たら均有做了…之后的意思。使用と存在一个额外的意思：表示这个动作是一个周而复始的习惯性动作。</p><ol><li>春になる **と(たら・ば)**、桜が咲く。</li></ol><p>一…就，的含义。表示自然现象。</p><ol start="2"><li>このおみを押す **と(たら・ば)**、窓が開きます。</li></ol><p>一…就，的含义。表示物理规则（按钮被按下的话，窗户就开了，所以这里被称之为物理规则感觉也不是很合适）。</p><ol start="3"><li>このボタを押す **と(たら)**、窓が開きました。</li></ol><p>一…就，的含义。表示过去的物理规则。此时不可以使用ば。</p><ol start="4"><li>駅に着く **と(たら)**、先生がいた。</li></ol><p>たら、と可以用来表示突然发生的一件事情，此时也没有ば的用法。</p><ol start="5"><li>日月雨が降っ<strong>たら</strong>、運動会は中止です。</li></ol><p>后面的从句子，并不表达必然的结果。たら表示如果…的话，通常来说表示「单独的一次事件」。这个地方可以使用ば。</p><ol start="6"><li>休みたなっ<strong>たら</strong>、旅行に行きましょう。</li></ol><p>ば表示如果…的话的含义的时候，后面不可以出现意志，命令，请求的形式。</p><ol start="7"><li>ご飯を食べ**たら(と)**、シャワーを浴びる。</li></ol><p>と、たら均有做了…之后的意思。使用と存在一个额外的意思：表示这个动作是一个周而复始的习惯性动作。</p><p>这个例句，虽然说两个词都可以使用，但是使用と会多一层含义。</p><h3 id="なら"><a href="#なら" class="headerlink" title="なら"></a>なら</h3><p>なら（如果…的话）</p><p>有些情况下，只能用なら。比如说给对方提供信息的时候，表示建议。一般使用なら。</p><p>なら可以跳出时间先后顺序。站在现在的角度去预测未来要发生的事情，然后这件未来要发生的事情使用なら，表示未来。</p><ol start="8"><li>山田さんが行け **ば(たら・なら)**、僕も行く。</li></ol><p>ば表示如果…的话的含义的时候，后面不可以出现意志，命令，请求的形式。但是这两个主语并不一样。</p><p>前后主语不一样的情形，可以使用なら。</p><ol start="9"><li>時間がなけれ **ば(たら・なら)**、教えて。</li></ol><p>ば表示如果…的话的含义的时候，后面不可以出现意志，命令，请求的形式。但是前半句话表示某个事情的状态。</p><p>前半句话表示某个事情的状态，可以使用なら。</p><ol start="10"><li>日本へ行く<strong>なら</strong>、奈良はいいですよ。</li></ol><p>给对方提供信息的时候，表示建议。这种情况下只能使用なら。</p><ol start="11"><li>車の運転する<strong>なら</strong>、酒は飲まないように。</li></ol><p>なら可以跳出时间先后顺序。比如上面那句话，喝酒肯定在开车之前，但是なら被用在了开车的半句上。</p><ol start="12"><li>明日雨が降る<strong>なら</strong>、今日のうち出かけよう。</li></ol><p>なら可以跳出时间先后顺序。なら在这里具体表达的含义是：站在现在的角度去预测未来要发生的事情，然后这件未来要发生的事情使用なら，表示未来。这种情况下也可以归咎于打乱时间顺序。</p><p>从这个角度解释たら，意思就变为了：等将来的事情发生之后，再去采取行动。这个时候，第二句话使用「今日…」很显然不合规。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="日语学习" scheme="https://blog.pengdonglai.com/categories/%E6%97%A5%E8%AF%AD%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="日本語" scheme="https://blog.pengdonglai.com/tags/%E6%97%A5%E6%9C%AC%E8%AA%9E/"/>
    
    <category term="语法" scheme="https://blog.pengdonglai.com/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>肖邦：大师之作（上）</title>
    <link href="https://blog.pengdonglai.com/2024/05/12/chopin-masterpieces/"/>
    <id>https://blog.pengdonglai.com/2024/05/12/chopin-masterpieces/</id>
    <published>2024-05-12T12:27:54.000Z</published>
    <updated>2024-08-31T04:27:30.118Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>[!Warning]<br>本页面使用了比较多的 <code>iframe</code> 标签，它们大多使用懒加载策略。尽管 Youtube 针对于咱外页的优化有着极高水平，但是仍然会在一些配置不太好的电脑性能表现不佳。请尽量避免快速滑动页面，以造成大量的 iframe 一并加载。</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我自幼学习钢琴，并且极为侥幸地一直学了下来，至今 16 年感觉也算是小有所成。水平我自然是不太行，不过在这个过程中，我渐渐培养出了对这类音乐的喜爱。虽然说法不严谨，我们一般在大众的认知中称呼其为「古典音乐」——它泛指 20 世纪中叶前西方流派的，以钢琴，小提琴为代表的，历史悠久乐器为主演的音乐，以纯音乐为主。它名家辈出，从莫扎特，海顿，到贝多芬，后来进阶到一些更为细分领域的大师，肖邦，李斯特，德彪西，拉赫玛尼诺夫等。是他们的创作和表演，构成了西方近代史上，乃至全人类的一块壮丽的瑰宝。</p><p>我为什么想做这个系列：</p><ul><li>想使用一种另类的（区别于实体专辑）方式，在自己留下记忆的地方，以专辑的方式保存它们。</li><li>想使用文字描述聆听它们的感受。</li><li>缺乏与其他人交流的途径。博客是我没有限制的发声渠道，我可以畅所欲言。</li></ul><hr><p>一提到肖邦，人们几乎会下意识地将他与一个词联系在一起：浪漫。他被誉为十九世纪欧洲浪漫主义音乐的典范代表，在钢琴作品领域达到了浪漫主义时期的巅峰。尤其是他的一系列夜曲，旋律优美、内容丰富、情感细腻，使他获得了「钢琴诗人」的称号。</p><p>但是这绝对不意味着肖邦就等同于浪漫，唯美，温柔。这很可能是仅仅透过通俗易懂的「夜曲」系列就对肖邦进行的简单的评价。事实上，作为诗人，他最难能可贵的，是用诗一般的旋律向你娓娓道来，道来的，既有婉转的小调，更有宏大的篇章。</p><p>笔者文笔不佳，但是其它大家，赵越胜如此评价肖邦：肖邦的作品精致却不矫饰，抒情却不滥情，忧伤却不嚎哭，绮旎却不风骚。听懂了肖邦的人都能感到他的音乐织体丰厚繁复又晶莹剔透。深灰色的悲哀衬着宝蓝的底色。即使泪水盈眶，泪珠也不落下。</p><p>因此，我们透过肖邦，看到了是一个复杂的，全面的，多面的，有血有肉的，有思想有感情的，有才华有天赋的，有创造力有想象力的，有音乐有诗歌的，有浪漫有现实的，有激情有理智的，有温柔有坚强的，有天才有伟大的复合体。唯一不变的，是长居法国和波兰精神赋予他最核心内核，为那个时代，属于浪漫派时代的最闪亮的一颗明星之一。</p><p>本文接下来会对肖邦的主要之作，结合我的一些理解，进行流水账式列举。既然会进行鉴赏，那就不可能完全主观，因此一定存在立场偏向。选取的曲目亦有主观感受。<strong>本人没有专业学习过乐理，对于音乐的分析更多的凭借自己的感受和较为非专业性的描述，并且会在一些地方贴合主流观点进行说明。</strong>在这个内容中，如果您有特别想跟博主交流的地方，或者争议之处，欢迎通过邮件交流。现实中认识我的朋友，也可以直接找到我。如果这个过程中出现了冒犯之处，以你为准并且我提前向你致以诚挚的道歉。</p><p>那么，我们开始。</p><h2 id="Ballade-叙事曲"><a href="#Ballade-叙事曲" class="headerlink" title="Ballade&#x2F;叙事曲"></a>Ballade&#x2F;叙事曲</h2><p>肖邦共创作了四首叙事曲，皆为单乐章钢琴独奏，并需要较高弹奏技术。叙事曲在法文中原本是指谣曲，而肖邦则是钢琴叙事曲的首创者。如果让我选一个肖邦最推荐的作品，我应该不出意外的会从这四首里面进行选择。</p><h3 id="Ballade-No-1"><a href="#Ballade-No-1" class="headerlink" title="Ballade No.1"></a>Ballade No.1</h3><div style="position: relative; width: 100%; height: 0; padding-bottom: 56.3%; margin: 20px 0"><iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" width="560" height="315" src="https://www.youtube-nocookie.com/embed/BSFNl4roGlI?si=i-xjAF3T48sw4JEw" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe></div><p>演奏者：Krystian Zimerman 克里斯蒂安·齐默尔曼</p><p>G 小调第 1 号叙事曲，作品 23，于 1831 年创作。当时是肖邦早年于维也纳生活，受思乡之苦，适逢波兰发生十一月起义，因此将感受反映于此曲中。</p><p>罗伯特·舒曼对这首曲目曾说：</p><blockquote><p>I received a new Ballade from Chopin. It seems to be a work closest to his genius (although not the most ingenious) and I told him that I like it best of all his compositions. After quite a lengthy silence he replied with emphasis, “I am happy to hear this since I too like it most and hold it dearest.”</p><p>我收到肖邦新一首叙事曲。虽然它并不是他最为精致的一首曲，但看来是最能反映他天分的，我告诉他这是他所有的作品中我最喜欢的。过了一段沉寂，他强调：『我很开心听到这，因为我也最喜欢它。』</p></blockquote><p>喜爱之情溢于言表。</p><blockquote><p>有人认为这首叙事曲是取材于密茨凯维茨的《格拉辛娜》，但一般认为应是密茨凯维茨的史诗剧作《康拉德·华伦洛德》。这部叙事诗剧写11世纪立陶宛被日尔曼骑士兵团所灭，立陶宛后裔华伦洛德被敌俘虏，并被抚养成人，受到敌方重用。立陶宛老人乔装成唱诗的歌手深入虎穴，得以接近华伦洛德。通过反复启发教育，终于使华伦洛德醒悟，立志牺牲个人为祖国效力，最后终于使立陶宛人得胜，而华伦洛德却被敌人处死。<br>乐曲采用自由奏鸣曲式写成。具有庄重的宣叙调特点的 8 小节序奏之后，出现了安详而略带忧虑的第一主题，老人开始回忆和讲述一个遥远的故事。第二主题是舒展明朗的，使人感受到华伦洛德在知道自己身世后的感慨之情。这两个主题在展开部构成了惊心动魄的戏剧性效果，第一主题不断地增强悲剧色彩，第二主题则发展成具有英雄气概的主题，以至在第二主题再现时，绝然不同于呈示部那抒情温柔的形象，已成长为成熟的、誓为祖国雪耻的英雄形象了。乐曲的尾声将全曲的情绪再一次推向高潮。结尾是悲壮的，象征着华伦洛德为国壮烈捐躯的英雄气概。</p></blockquote><p>反映的背景故事，和现实世界发生的故事如出一辙，遥相呼应。</p><p>本作的技术难点在于各种超八度大跳，这些部分正好对应曲目中华彩段，反映了现实世界十一月起义的激烈战斗。一般认为，华彩段的处理直接影响这部作品的演绎效果（当然对其它叙事曲也一样）。但是除了华彩段，本叙事曲的主旋律反映出来的低沉气氛，想要演绎的非常好，同样也需要用心。本作正是摆脱肖邦「浪漫」风格的最好证明。因为它是难得的写实作品。开头段以略微雄壮的六和弦作为开头，到主旋律低沉的处理，像是一副缓缓展开的史诗。之后主旋律和华彩段相互交接演绎，主旋律表达了低沉的氛围，而华彩段表现了革命的激烈战斗和紧张气氛。如果说驾驭一部革命史诗的难度不低，那么这就是演奏好这首曲子的代价。</p><h3 id="Ballade-No-2"><a href="#Ballade-No-2" class="headerlink" title="Ballade No.2"></a>Ballade No.2</h3><div style="position: relative; width: 100%; height: 0; padding-bottom: 56.3%; margin: 20px 0"><iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://www.youtube-nocookie.com/embed/Wslm1ZL9EI8?si=h0VzUbFbdJLQ7g7Q" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe></div><p>演奏者：Krystian Zimerman 克里斯蒂安·齐默尔曼</p><p>F 大调第 2 号叙事曲，作品 38，在 1836 至 1839 年分别于法国的诺昂维克和西班牙的马约卡岛创作，并献于罗伯特·舒曼。</p><p>如果我们有参与这首曲子的评价，我们可以听到这样的言论：</p><blockquote><p>肖邦曾说，当他要写这首叙事曲时，是受密茨凯维茨的长诗《斯维台茨湖》的感动。那首长诗也是写立陶宛古代的爱国故事，大意是：立陶宛遭到异族侵略，青年人都去前方作战了，当留在城里的老幼妇孺听到敌人已迫近城门时，他们无力抵抗，只得乞求上苍，宁可让洪水淹没城市，与敌人同归于尽。果然，奇迹出现了，城市变成了一片湖泊。经过许多世代以后，立陶宛后裔漫步湖畔，探寻着这古代传说的遗迹。突然，有水仙从湖底浮起，向人们讲述了这个故事，然后又潜身返回湖底。肖邦这首叙事曲也并非是对这首长诗的具体描述。它由平静、优美的抒情乐段和暴风骤雨般的戏剧性乐段交织构成，我们只能根据它特定的音乐形象和情绪气氛，对密茨凯维茨的长诗进行一定的联想。</p></blockquote><p>但是实际上，通过英文世界的资料发现，这首曲子似乎并不像我们想象的那么美好。关于它的批评声很多，尤其是在对比他更加天才横溢的 1 号叙事曲后，更加如此。维基百科有这样的描述：「该作品受到一些著名钢琴家和音乐学家的批评，甚至包括其被奉献着舒曼，认为其不如第一部作品巧妙。关于其灵感，存在一定程度的分歧，人们经常声称它的灵感来自于亚当·密茨凯维奇的诗《斯维台茨湖》，但这种说法没有得到证实，《叙事曲第三号》有时被归因于这首诗也是如此。」</p><p>原文在这里 <a href="https://en.wikipedia.org/wiki/Ballade_No._2_(Chopin)">https://en.wikipedia.org/wiki/Ballade_No._2_(Chopin)</a>：</p><blockquote><p>The piece has been criticized by some prominent pianists and musicologists, including its dedicatee Schumann, as a less ingenious work than the first.There is some degree of disagreement as to its inspiration, with the claim, often made that it was inspired by Adam Mickiewicz’s poem Świtezianka, the lake of Willis, but this claim is unsubstantiated, and the Ballade No. 3 is sometimes attributed to this poem as well.</p></blockquote><p>但是就我看来，这首曲子同样也有很多可圈可点的地方。首先它在一定程度在和 1 有着相似之处，因为它同样是主旋律+华彩的基本架构。但是相比于 1 的写实，2 应该没有什么争议地被认为，肖邦融入了更多自己的想法。这体现在主题 1 和 2 肖邦的味道更浓厚（虽然这里同样存在非常多的争议，比如混乱感比较强），但是在第一个主题 2 呈现（小调部分）之后，F 大调主题以一种出色的方式扩展，而这种类似「史诗般」的华彩段相比于 1 来说，连贯性更强并且情绪渲染更加合理（看人，1 极有可能是受到了写实风格的影响）。最后的结尾说实在 2 比 1 更加干净，同样都是在高潮中收尾，1 有一种意犹未尽的感觉，2 则更加干净，更加纯粹。</p><h3 id="Ballade-No-3"><a href="#Ballade-No-3" class="headerlink" title="Ballade No.3"></a>Ballade No.3</h3><div style="position: relative; width: 100%; height: 0; padding-bottom: 56.3%; margin: 20px 0"><iframe loading="lazy" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://www.youtube-nocookie.com/embed/BkPLDoZXlHQ?si=bTkxnWRUw_N4-PL1" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe></div><p>演奏者：Krystian Zimerman 克里斯蒂安·齐默尔曼</p><p>降 A 大调第 3 号叙事曲，作品 47，1841 年始作。这首叙事曲是献给他的学生宝琳·德·诺阿耶（Pauline de Noailles，1823-1844）。根据维基百科来源，它的灵感通常被认为是亚当·密茨凯维奇的诗《Undine》，也被称为 Świtezianka，这与第二首不谋而合地来自于同一位作者。不过需要说明的是，肖邦从未证实过哪些文学来源为他的叙事曲提供了创作动力。很可能他根本不希望听众知道，而是从他的音乐中汲取自己的叙述。</p><p>即便是来源类似，但是从这两首曲子的风格来说，肖邦应该选择了不同的故事。一般认为，这首诗是叙述对爱情不忠诚的人终遭报应的民间传说故事，故事的主人公是一位骑士和一位少女。它的来源无从考证，不过这依然影响不了第三首是完全独特于第一首、第二首的存在。</p><p>叙事曲以一段带有「dolce」字样的冗长介绍开始。引子在旋律上与作品的大部分内容无关，但在作品的结尾和高潮处重复出现，一如故事所言，「骑士向年轻美丽的少女表达自己的心意，少女被骑士的热情打动，愿意与骑士约会」，第一段作为这段故事的开头非常合适。在引子之后，肖邦在一个部分引入了一个新的主题 B，这个主题在我看来可以说是叙事曲中最像圆舞曲的部分，但是又不像圆舞曲那样子充满高贵典雅，而是一种非常轻灵的表现形式，宛如骑士与少女在嬉戏打闹。中音部分很快发展成激烈的 F 小调和弦部分，并再次回到A♭，就像男人与女人，也仿佛恋爱时的心情，跌宕起伏。</p><p>随后进入了变奏，这是主题 B 的变奏。对应故事的原文，很有可能这里就是对应了另外一位美丽的女子，相比之前的少女，更加精致且有魅力。这便是之前的少女——水仙女，化作的另一个女人，来考验骑士的真心。在 124 小节左右，骑士不由自主的跟着水仙女的舞步，愚蠢、负心汉的嘴脸慢慢的暴露出来。却不知水仙女已经看透了他，并且怒不可遏，决心报复。</p><p>157 小节开始音乐开始变得阴暗，右手的旋律像是不再伪装的水仙女在控诉骑士的种种行为，表达自己的愤怒。左手则像原本平静的湖水开始涌动，巨大的危机正向骑士席卷而来。随后进入本作的高潮部分——主题 B 以华丽，恢宏的形式展开，但是对我们的男主人公来说，这毫无疑问显示了这是水仙女的报复。如果说以前的水仙女和他在一起在水中嬉戏打闹，是一开始的主题 B。那么此时的主题 B 又嬉戏玩笑的水花，在这一刻化作了滔天巨浪，宛如回旋镖一般击中了骑士。随后短暂的宁静更像是骑士的哀求，可惜水仙女已经不给他机会。快速跑动的音阶和咆哮的和旋，一如水仙女掀起的滔天巨浪将骑士淹没，任他怎么挣扎都无法逃脱。最后曲子就在快音阶收尾，很显然骑士没有得到水仙女的原谅。</p><p>我的评价是：剧情太狗血，希望这不是真的。狗血的剧情不会影响音乐的美感。</p><h3 id="Ballade-No-4"><a href="#Ballade-No-4" class="headerlink" title="Ballade No.4"></a>Ballade No.4</h3><div style="position: relative; width: 100%; height: 0; padding-bottom: 56.3%; margin: 20px 0"><iframe loading="lazy" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://www.youtube-nocookie.com/embed/pe-GrRQz8pk?si=Hvnnx6iXxrNa09gZ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe></div><p>演奏者：Krystian Zimerman 克里斯蒂安·齐默尔曼</p><p>F小调第四叙事曲，作品 52，于 1842 年在巴黎完成。它通常被认为是 19 世纪钢琴音乐的杰作之一，和第一首有着极为类似的地位。维基百科说，在四首叙事曲中，它被许多钢琴家认为是技术上和音乐上最困难的。它也是最长的，大约需要十到十二分钟的表演时间。根据约翰·奥格登的说法，它是「肖邦所有作品中最崇高、最强烈和最强大的作品……令人难以置信的是它只持续了十二分钟，因为它包含了一生的经历。」该作品献给纳撒尼尔·德·罗斯柴尔德 (Nathaniel de Rothschild) 的妻子罗斯柴尔德男爵夫人 (Baroness Rothschild)。阿尔弗雷德·科尔托在他的肖邦叙事曲版本的序言中声称，这首叙事曲的灵感来自亚当·密茨凯维奇的诗《三个兄弟》，讲述了三兄弟被父亲派去寻找宝藏，并与三个波兰人一起返回的故事。</p><p>说实在，第四叙事曲确实可以听出来艺术含金量非常高。但是我个人确实没有太听懂，应该是我的理解层面还没有达到。它与肖邦的其他叙事诗有很大的不同，这不是一个戏剧性的史诗，而是一个抒情的故事（这不废话，事实上，2-4 号叙事曲都可以是这个风格）。在整部作品中，作曲家完全没有使用情感的对比，只有一些抒情色彩相近、音调完全不同的音乐形象相互交替，只有在结尾才出现肖邦大型作品中独有的悲壮、激情、慷慨的形象。</p><p>一般在中文互联网认为，这是肖邦对晚年生活的独白。这自然是无从考证的东西。不过从这首曲子的风格以及结构分析来说，确实自洽。咋听下来，曲子的前半段保持着另类的平静，但是结合肖邦中晚年（他没有生理意义的中晚年，因为他 39 岁就去世了。）的情况来看，这所谓的百般宁静，又何尝不是变着花子诉说着自己「成熟」的痛苦呢？宁静之下，潜藏着痛苦和不太容易被听出来的不甘和呐喊。时不时地和的力度变化，将这种不甘和呐喊，仿佛要把这种情绪推向高潮，却又不太坚决。与众不同的是，这首曲子主旋律的再现部的前面的一小段是一段凄凉的高音独奏，这和以往的风格截然不同。最后的高潮一波接着一波，但是最后的部分居然是休息了一小会才到来，很像是一种感觉，那就是呐喊声充满了无力感——也许是我自作多情了，肖邦似乎是比较怕让别人猜到他真正的想法的。</p><p>网络上的评价，我觉得也很有道理：</p><blockquote><p>这首叙事曲是肖邦晚期心情的自我抒发，没有较为具体的标题性。在结构上采用了奏鸣曲式与变奏相结合的方法。在这里，具有忧郁和幻想气质的抒情、叙事性的主部主题通过变奏发展加强了基本感情的色彩。在第三次陈述时，性格上起了变化，变得充满了悲剧性的热情，而在再现部中最后一次陈述时，活跃而紧张的运动带来了惊惶不安的色彩。副部则用了和声变奏手法，是明朗、柔和的抒情主题获得了色彩的变化。</p></blockquote><h2 id="Concerto-协奏曲"><a href="#Concerto-协奏曲" class="headerlink" title="Concerto&#x2F;协奏曲"></a>Concerto&#x2F;协奏曲</h2><h3 id="Concerto-Mo-1"><a href="#Concerto-Mo-1" class="headerlink" title="Concerto Mo.1"></a>Concerto Mo.1</h3><div style="position: relative; width: 100%; height: 0; padding-bottom: 56.3%; margin: 20px 0"><iframe loading="lazy" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://www.youtube-nocookie.com/embed/gV_x_QY1P5c?si=fMIAGP6O8Ib9S9s3" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe></div><p>演奏者：Martha Argerich 玛莎·阿格里奇</p><p>e 小调第一钢琴协奏曲，作品第 11 号。它是弗雷德里克·肖邦于 1830 年创作的，当时他 20 岁。该曲于当年 10 月 12 日在波兰华沙的 Teatr Narodowy（国家剧院）首演，作曲家在他离开波兰之前的一场「告别」音乐会上担任独奏家。这首钢琴协奏曲是献给钢琴家兼作曲家弗里德里希·卡尔克布伦纳的。1830 年 10 月 12 日的首映「取得了成功……座无虚席」。七周后，波兰政变爆发后，肖邦在巴黎的普莱耶尔音乐厅首次在法国演奏了他的协奏曲，同样好评如潮。</p><p>该协奏曲由三个乐章组成，是该时期典型的器乐协奏曲：</p><ol><li>Allegro maestoso (E minor) &#x2F;庄严的快板</li><li>Romanze – Larghetto (E major) &#x2F;浪漫曲 - 甚缓板</li><li>Rondo – Vivace (E major) &#x2F;回旋曲 - 活泼地</li></ol><p>第一乐章有三个主题，由乐团引入。然后钢琴演奏第一主题（第 139 小节），然后是抒情的第二主题（第 155 小节）。第一主题与结尾交相呼应，是那个年代很正常的起手式。</p><p>抒情的第二主题，缓缓由钢琴演绎出来，是整个第一乐章最为触动我的部分…闭上双眼聆听，19 世纪欧洲广袤的肥沃土地，一直延伸到今天波兰所在的华沙，那片肥沃的土地上，曾经有过多少的浪漫故事，有过多少的爱情，有过多少的悲欢离合。</p><p>第三主题为E大调，由管弦乐队引入并由钢琴接管（第222小节）。发展从第 385 小节开始，钢琴演奏第二主题；然后管弦乐队发展第一个主题。这个过程存在着钢琴的华彩段，但是这个华彩段中，听着并不是一般华彩段那种辉煌的感觉，利落的跑动和交响乐一唱一和，让我想到了小孩子在广袤的土地上，奔跑，嬉戏，打闹….这也许并不很贴近时代背景。</p><p>开头的重演再次从第 486 小节开始，管弦乐队演奏了开场主题。第三个 E 大调主题回来了（第573小节），但最终，尾声又回到E小调，乐章以钢琴部分结束，随后是突然的强音E末尾的小和弦。我不喜欢这个小和旋，看起来收尾的有点突兀。</p><p>随后我们进入优美的第二乐章。这是本协奏曲中，最像诗歌的地方。引用肖邦曾经说过的话：</p><blockquote><p>Chopin wrote in the same letter to Tytus, saying, “It is not meant to create a powerful effect; it is rather a Romance, calm and melancholy, giving the impression of someone looking gently towards a spot that calls to mind a thousand happy memories. It is a kind of reverie in the moonlight on a beautiful spring evening.”</p></blockquote><p>肖邦在给泰图斯的同一封信中写道：「这并不是为了创造一种强大的效果；而是一种浪漫，平静而忧郁，给人的印象是一个人轻轻地看着一个地方，唤起我一千个幸福的回忆。这是一种美丽的春夜月光下的遐想。」</p><p>首先也是乐器起手，之后钢琴为主演奏主题。主题婉转，优美，并且非常意外地通俗易懂。听起来像是一段平静的诉说。</p><p>之后伴随着器乐进入第二主题，听起来像是在自问自答。随后我们进入了一段低音和管弦乐互相演奏的阶段，这个过程中有伴随第一、第二主题的变奏，低音的演绎就像是在沉思，和乐曲清灵，婉转地部分交相辉映。随后钢琴渐渐回到高声部，这个过程中，音色渐渐消退，只留下钢琴。</p><p>随着灵动的高音自问自答式地展开，我们进入了第二乐章的「升华段」——钢琴用更多装饰音的变奏，重新演绎一开始的第一主题，这是整个乐曲中最令人感动的部分——它显得更忧郁和幻美，像是月光下的凝思，有着眼泪的迷蒙，既是心中满怀爱意的衷曲转达，又是对恋人伤感的怀想与思念。</p><p>每当我听到这个部分的时候，我就会驻足停留，并且闭上眼睛——倾听着优雅、尊贵的音律。说它是「灵魂升华」无疑是违背唯物主义的，但如果你想让唯物主义者感觉到「灵魂升华」的感觉，同时他也对这种类型的乐曲不感冒，那么「仔细聆听这一段」，毫无疑问是最接近「灵魂升华」的一次体验。</p><p>随着几声管弦乐的「蹦蹦」声，仿佛将我们从离合的思绪中拉回。我们进入了第三乐章。</p><p>勇士舞 Krakowiak 是一种快速的波兰舞，节拍是 2&#x2F;4 拍，起源于旧首都克拉科夫及小波兰省。据传，第三乐章华丽回旋曲就是以此主题的。它的主题我们一进入就能听见。当然，既然是回旋曲，我们在后面也能多次听到这段旋律。歌曲轻快明亮，是完全不同于前面两个乐章的风格，不过同样是以管弦乐与钢琴交错展开。我们可以在回旋曲的中间听到插入的一段具有浓烈波兰风格的民曲，不过这段旋律很快就过去了。</p><p>关于第三乐章，最容易产生的联想是，我们正参加 Krakowiak 波兰舞的活动之中，随着舞者开始起舞，会场顿时进入了轻快的风格。民歌的加入让整首曲子的波兰民族味道更浓厚。我们可以渐渐感受到大家越来越热情，会场的气氛越来越浓厚。此时，钢琴进入了华彩段——这是一段难度非常高，但是却能把乐曲推向高潮的琶音。经过一次休息后，钢琴在管弦乐的帮助下将氛围推向顶点，之后全曲结束。不同于第一乐章结束的仓促，第三乐章的结束会有一种欢畅淋漓的感觉。</p><p>纵观全曲，三个乐章的风格完全不一样，但是都是波兰民族的各个部分，我甚至完全不介意称之为波兰民族音乐版本的百科全书——肖邦的民族性跃然纸上。在那个波兰仍处于沙皇俄国压迫的阶段，这样的音乐家创作的曲子，更显得难能可贵。</p><h3 id="Concerto-No-2"><a href="#Concerto-No-2" class="headerlink" title="Concerto No.2"></a>Concerto No.2</h3><div style="position: relative; width: 100%; height: 0; padding-bottom: 56.3%; margin: 20px 0"><iframe loading="lazy" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://www.youtube-nocookie.com/embed/B3r4EgwLqMM?si=oVCCmBNhPMauFuJo" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe></div><p>演奏者：Arthur Rubinstein 亚瑟·鲁宾斯坦</p><p>f 小调第二钢琴协奏曲，作品第 21 号。是肖邦于 1829 年秋季创作的一部钢琴协奏曲。当时他大约 20 岁。一个有趣的事实是，虽然说这是第二号协奏曲，但是它比第一部更早出版，所以给到的编号只是 No.2.</p><p>该协奏曲由三个乐章组成：</p><ol><li>Maestoso (F minor) &#x2F;雄伟地</li><li>Larghetto (A-flat major) &#x2F;甚缓板</li><li>Allegro vivace (F minor – F major) &#x2F;甚极速地</li></ol><p>实际听下来，第一乐章和这个标题有出入之处。全曲雄壮的地方似乎不多，不过也有可能是中译英的锅，这一点我没办法考证了。不过我还是去了解了下背景信息，当时肖邦正在华沙音乐学院就读。据传，写这首曲子的时候肖邦正在暗恋学声乐的女同学康斯坦茨娅 (Konstancja Gladkowska)，只是肖邦也就处于这暗恋的状态中了，也一直没敢表白。也有出处说女同学拒绝了肖邦青涩的表白。有力的证据来源于肖邦曾在一封给友人的信：「写这首舒缓的协奏曲时，我的心绪始终和她在一起。」我们也似乎可以从乐曲中婉扬的部分中对这份情感有一个初步的认识。</p><p>开头一段略微奇怪的下行旋律可能来源于肖邦的天才想法，事实上听过千篇一律的旋律后一听这首曲子便立马起了兴致，这是第一主题。交响乐发起一阵巨响（和他在第一首曲子中的手法如出一辙），伴随着小提琴的乐句，我们便进入了第二主题。交响曲和钢琴连绵起伏，交错演奏。这个技法很常见，但是也很难不让人联想到肖邦包含的爱意，同样也是连绵起伏的。</p><p>第二主题为降 A 大调，并且不时插入第一主题的旋律。此刻，管弦乐已黯然失色。华丽的钢琴独奏，展开了广阔的音响世界。这一段内钢琴的展开很多且展开变奏之华丽，技巧之深，每每听到，我想大家都会由衷的赞叹肖邦在这个方面的音乐天赋。和协奏曲第一号的第二乐章（以及待会提到的第二乐章）来说，这里优美的旋律是穿插在钢琴和管弦乐之间的，在两者结合的时候，优美程度达到最高。钢琴通过快速的音阶将管弦乐进入一个小高潮部分后，又回到刚刚描述这段的状态中。</p><p>钢琴休息片刻，便又奏出第一主题。圆号与之为伴，弦乐与它同行。再现的乐段变得简洁凝炼，并在钢琴独奏中，更多地融入了年轻作曲家对爱情的幻求。第一乐章在管弦乐队沉闷的和弦中结束。</p><p><s>第二乐章可以说一听就是专门为女朋友准备的、太明显了</s>。我一般因为不懂所以不评价管弦乐的演奏，加之在协奏曲中往往也是以钢琴为主。但是排开优美的钢琴旋律，木管乐在这个乐章的表演同样超神——事实上，在第一协奏曲的第二乐章就已经初见端倪。但是开头，木管乐和弦乐的交相呼应仍然是我印象最深的片段之一，好似两种乐器在悄悄对话。钢琴在第二主题有一段从低音向上的旋律同样也是我最深刻的记忆，一如渐渐燃起了热情的火苗，它在颤音上跳动，在和弦中飘曳；乐曲的最后，由弦乐与木管的呢哺絮语中，钢琴从低音开始，几个音符攀援到稳定的降A主音上。第二乐章只要能梳理出几个旋律其实非常好懂，很多内容也和第一协奏曲的第二乐章比较相似，这里就不再展开。</p><p>第三乐章虽然不直接叫「回旋曲」，但确实一开始演奏就有回旋式的风格。不过一般认为它其实是波兰的玛祖卡。一开始首先从第二乐章的意犹未尽，钢琴轻轻、稍慢地地开始第一主题。不过轻快的风格已经十分明显了。在弦乐顿足般的同音反复节奏型中，钢琴粗犷地奏出第二主题，随后过渡到活跃的音阶和音调中，把人们带到火热的马祖卡舞蹈的行列里。宏大的管弦乐队要然而止。乐曲中的圆号是点睛之笔，它的演奏更像是呼唤，换来钢琴的回应。</p><p>就这样，钢琴和交响乐交替演奏，一直到钢琴一阵颤音后的华丽主题演奏后消退。之后回到第一乐章，开始回旋重复刚刚的过程。过了一阵，协奏曲在马祖卡舞曲所独有的三连音节奏型的持续涌进中，终于在向上的旋律中，冲出来转变为了 F 大调。最后，钢琴华丽的琶音配合乐队的激情和弦伴奏，给人们留下灿烂的光辉。在短暂的休息后，钢琴小爆发，使全曲在欢腾火热的气氛中结束。</p><p>第二首协奏曲给我的印象，其实没有第一首那么印象深刻。主要是因为第一首曲子描绘的内容确实很「大」。第二首曲子更多地参杂了肖邦个人的生活和想法，相对来说并没有那么写实。这一点和他的几首叙事曲的区别也比较像。不过我认为这恰恰是肖邦的一体两面，一面的他是民族性的，作为爱国音乐诗人，他写的曲子时不时反应历史背景和波兰精神，具备浓厚的民族味道。另一面是浪漫，他个人极强的音乐天赋和个人生活对于爱情的描写和向往，也有一部分是音乐家独特的浪漫天赋。两首协奏曲对这些内容表现的淋漓尽致。</p><h2 id="Sonata-奏鸣曲"><a href="#Sonata-奏鸣曲" class="headerlink" title="Sonata&#x2F;奏鸣曲"></a>Sonata&#x2F;奏鸣曲</h2><h3 id="Sonata-No-2"><a href="#Sonata-No-2" class="headerlink" title="Sonata No.2"></a>Sonata No.2</h3><div style="position: relative; width: 100%; height: 0; padding-bottom: 56.3%; margin: 20px 0"><iframe loading="lazy" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://www.youtube-nocookie.com/embed/DhB59YCvxuw?si=pvb6De5W-1lnKTS0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe></div><p>演奏者：Krystian Zimerman 克里斯蒂安·齐默尔曼</p><h3 id="Sonata-No-3"><a href="#Sonata-No-3" class="headerlink" title="Sonata No.3"></a>Sonata No.3</h3><div style="position: relative; width: 100%; height: 0; padding-bottom: 56.3%; margin: 20px 0"><iframe loading="lazy" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://www.youtube-nocookie.com/embed/qbd9-hYXK9M?si=cEfLmBcJtRNCt4NC" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe></div><p>演奏者：Krystian Zimerman 克里斯蒂安·齐默尔曼</p><h2 id="Etude-Op-10-练习曲作品之10"><a href="#Etude-Op-10-练习曲作品之10" class="headerlink" title="Etude Op.10&#x2F;练习曲作品之10"></a>Etude Op.10&#x2F;练习曲作品之10</h2><p>接下来会逐步开始介绍肖邦的练习曲。Youtube 能找到的演奏家，并且满足高播放的，我这里选取了 Rousseau，Kassia，还有瓦姐的。首先我还是最推荐瓦姐的版本，但是瓦姐的版本是 15 年前的了，无论是画质还是音效都不如现在。另外两个我更喜欢 Kassia，不过 Youtube 似乎还是 Rousseau 的粉丝更多些。</p><p>近些年来 Rousseau 这样的结合钢琴特点，演奏的可视化在 Youtube 这类的视频网站上多了很多，也不乏 Kassia 这样一看上去就知道实力强劲的选手，我本人非常喜欢这种模式。这样观众对于这首曲子如何演绎，有了更为直观的感受。</p><p>练习曲分为 Op.10 和 Op.25 这两部作品。这是业余选手能接触到的较为顶层的作品——中国大陆的钢琴考级，九级&#x2F;十级几乎都会选取肖邦的练习曲作为考级曲目，这正好说明了十级选手对于肖邦练习曲的掌握是有一定要求的，部分简单的曲目得信手捏来。不同于叙事曲、协奏曲的抽象，练习曲是很多练琴者真真切切遇到的困难。笔者有幸练过其中的几首作品，在叙述的时候会顺带讲解自己对于其中一些作品练习的看法。</p><p>按照难度，一般认为肖邦练习曲和车尔尼 740 练习曲的难度相当，实际上略微被认可的细分应该是 740 低速 &lt; 肖邦练习曲 &lt; 740 原速；实际上，740 一共有五十首，且部分曲目难度也非常大，而且在技巧性上更甚肖邦练习曲一筹，例如第 35 首，在肖邦练习曲中很难找到类似的练习类型。还有三度这种不常见的、难度大的技巧，虽然说肖邦练习曲也有涉及，但是难度明显不如 740. 在一些地方，比如激流和冬风练习曲，难度一般认为还是大于 740 中跑动的部分。</p><p>除了笔者选取的作者之外，在互联网上完全可以找到更为精彩的演绎。可视化也许也能给正在练习这些曲目的同学更多的一些帮助（笔者曾经通过 Rousseau 的月光三，学了一处指法）。</p><h3 id="No-3-Tristesse-离别"><a href="#No-3-Tristesse-离别" class="headerlink" title="No.3 Tristesse&#x2F;离别"></a>No.3 Tristesse&#x2F;离别</h3><div style="position: relative; width: 100%; height: 0; padding-bottom: 56.3%; margin: 20px 0"><iframe loading="lazy" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://www.youtube-nocookie.com/embed/bzBH9Nm1BP8?si=gBVBxx3snpqHK4Ix" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe></div><p>演奏者：Rousseau</p><h3 id="No-4-Torrent-激流"><a href="#No-4-Torrent-激流" class="headerlink" title="No.4 Torrent&#x2F;激流"></a>No.4 Torrent&#x2F;激流</h3><div style="position: relative; width: 100%; height: 0; padding-bottom: 56.3%; margin: 20px 0"><iframe loading="lazy" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://www.youtube-nocookie.com/embed/oHiU-u2ddJ4?si=g0hOf_-HTnrQSGd5" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe></div><p>演奏者：Rousseau</p><h3 id="No-5-Black-Keys-黑键"><a href="#No-5-Black-Keys-黑键" class="headerlink" title="No.5 Black Keys&#x2F;黑键"></a>No.5 Black Keys&#x2F;黑键</h3><div style="position: relative; width: 100%; height: 0; padding-bottom: 56.3%; margin: 20px 0"><iframe loading="lazy" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://www.youtube-nocookie.com/embed/8tcnuRsfgUQ?si=7qajTsmjFytb5qdN" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe></div><p>演奏者：Rousseau</p><h3 id="No-8-Sunshine-阳光、滑翔机"><a href="#No-8-Sunshine-阳光、滑翔机" class="headerlink" title="No.8 Sunshine&#x2F;阳光、滑翔机"></a>No.8 Sunshine&#x2F;阳光、滑翔机</h3><div style="position: relative; width: 100%; height: 0; padding-bottom: 56.3%; margin: 20px 0"><iframe loading="lazy" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://www.youtube-nocookie.com/embed/43mvd1lKd3k?si=0NPmespokGxeQgnR" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe></div><p>演奏者：Valentina Lisitsa 瓦伦廷娜·李斯特莎</p><h3 id="No-12-Revolutionary-革命"><a href="#No-12-Revolutionary-革命" class="headerlink" title="No.12 Revolutionary&#x2F;革命"></a>No.12 Revolutionary&#x2F;革命</h3><div style="position: relative; width: 100%; height: 0; padding-bottom: 56.3%; margin: 20px 0"><iframe loading="lazy" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://www.youtube-nocookie.com/embed/g1uLrHq9TDg?si=eAFDZ-yRRcMsq_3o" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe></div><p>演奏者：Rousseau</p><h2 id="Etude-Op-25-练习曲作品之25"><a href="#Etude-Op-25-练习曲作品之25" class="headerlink" title="Etude Op.25&#x2F;练习曲作品之25"></a>Etude Op.25&#x2F;练习曲作品之25</h2><h3 id="No-1-Aeolian-Harp-风弦琴"><a href="#No-1-Aeolian-Harp-风弦琴" class="headerlink" title="No.1 Aeolian Harp&#x2F;风弦琴"></a>No.1 Aeolian Harp&#x2F;风弦琴</h3><div style="position: relative; width: 100%; height: 0; padding-bottom: 56.3%; margin: 20px 0"><iframe loading="lazy" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://www.youtube-nocookie.com/embed/7MxFWmr8Wck?si=VPv03Uw8tq0lqzXu" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe></div><p>演奏者：Kassia</p><p>Op25 第 1 首《降 A 大调练习曲》，它同时有一个别的称号：《牧羊人的笛子》。这是因为肖邦自己对这首曲子的解释：『牧童因暴风雨来临，避难于安全的洞穴。远处风雨大作，牧童却若无其事地取出笛子，吹出风雅的旋律。』。最像诗的练习曲之一。</p><p>这首曲子主要的难点是大量的快速琶音和和弦。最为完美的演绎，应该是在比较清晰的弹出这些快速琶音和和弦的同时，将位于右手每组 16 分音符的第一个音和左手的根音组成的「旋律」也能较为清楚的演奏出来。</p><h3 id="No-2-The-Bees-蜜蜂"><a href="#No-2-The-Bees-蜜蜂" class="headerlink" title="No.2 The Bees&#x2F;蜜蜂"></a>No.2 The Bees&#x2F;蜜蜂</h3><div style="position: relative; width: 100%; height: 0; padding-bottom: 56.3%; margin: 20px 0"><iframe loading="lazy" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://www.youtube-nocookie.com/embed/-o2lYktVy3I?si=OmlmVPQkZ1IGtOVr" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe></div><p>演奏者：Valentina Lisitsa 瓦伦廷娜·李斯特莎</p><p>Op25 第 2 首《f 小调练习曲》。不多说，选择它的原因也是因为这首曲子是 10 级的考级曲目，为了情怀选择的曲子。想必一直以来它都是各路琴童的噩梦之一。但是在肖邦练习曲中，这真是最简单的一首曲子了。</p><p>德国作曲家舒曼曾经评论它说:「它是那样美妙动人，充满幻想和静谧，宛如孩子梦中的歌声」。</p><h3 id="No-5-Wrong-Note-错音"><a href="#No-5-Wrong-Note-错音" class="headerlink" title="No.5 Wrong Note&#x2F;错音"></a>No.5 Wrong Note&#x2F;错音</h3><div style="position: relative; width: 100%; height: 0; padding-bottom: 56.3%; margin: 20px 0"><iframe loading="lazy" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://www.youtube-nocookie.com/embed/koPbc8F7u1s?si=8J29RvHOzzzaIF-b" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe></div><p>演奏者：Kassia</p><p>Op25 第 5 首《e 小调练习曲》，错音练习曲，他的难点主要是在于对谱子。所谓错音练习曲，只是旋律写的像错音罢了，并不意味着将它弹错也是没有问题的。而这么做，无疑会增加识谱难度。在我们没有反复聆听他的情况下，咱们要想通过音色来进行识别是特别难的。因此，这周曲子强烈建议听熟练之后再去弹。</p><p>这周曲子也仅有第一主题才听起来像错音，第二主题可以说，反而像一个很优美的篇章——实际上，第一主题恰恰是第二主题的「错音版本」。所以在这首曲目中，咱们就也不用想太多，直接当成两个单独不同的旋律，这样子才不会弹岔。</p><p>除此之外，这周曲子既然是错音练习曲，肖邦也用了许多不和谐的黑键来进一步放大错音的不和谐感，因此本曲目也是训练黑键的一首不错的练习。</p><h3 id="No-6-Thirds-三度"><a href="#No-6-Thirds-三度" class="headerlink" title="No.6 Thirds&#x2F;三度"></a>No.6 Thirds&#x2F;三度</h3><div style="position: relative; width: 100%; height: 0; padding-bottom: 56.3%; margin: 20px 0"><iframe loading="lazy" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://www.youtube-nocookie.com/embed/cpgjTR6p6oA?si=0MXK93Iwq0k8qtJm" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe></div><p>演奏者：Valentina Lisitsa 瓦伦廷娜·李斯特莎</p><p>Op25 第 6 首《升 g 小调练习曲》，三度练习曲，写的非常具备有东欧味道的练习曲。整首曲子不长，但是难度却一般被认为是肖邦练习曲中最难的几首曲子之一。在我看来，三度这周曲子，难点就是在反人类的「三度音」上，而这首曲子的完成度，也和三度音直接相关。顺便一提，740 中的三度练习曲，是比肖邦的更加难的。所以我们完全可以看到肖邦确实留下了不少「情面」。不过，将三度发扬光大的，毫无疑问是我们的李斯特同学，如果我还有精力能出李斯特的合集，那么对于老李的三度音我可要好好鉴赏一番。</p><p>关于这首练习曲，有这样一个传闻：据说肖邦在写作它的时候，心里想象着一个波兰流亡者在雪撬银铃声中，沿着茫茫无尽头的冰雪小道，流放到远方去的情景，这个传闻不一定可靠，但乐曲中那连续不断的三度和弦，确实很像雪撬前进时送来的铃声。我一直觉得特别多的人只关注这首曲子的难度，却忽略了这首曲子的音乐性。正相反，这首曲子的音乐性将一种寂静的感觉（实际上肖邦用了不少音符做到这一点），表现得恰当好处。</p><h3 id="No-9-Butterfly-蝴蝶"><a href="#No-9-Butterfly-蝴蝶" class="headerlink" title="No.9 Butterfly&#x2F;蝴蝶"></a>No.9 Butterfly&#x2F;蝴蝶</h3><div style="position: relative; width: 100%; height: 0; padding-bottom: 56.3%; margin: 20px 0"><iframe loading="lazy" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://www.youtube-nocookie.com/embed/WZYHvEF84NQ?si=KLkIvcpLW5V4yfG3" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe></div><p>演奏者：Rousseau</p><p>Op25 第 9 首《降 G 大调前奏曲》，蝴蝶练习曲，旋律非常轻巧的一手练习曲，旋律好听。通俗易懂。就是弹好这首曲子不容易。因为确实没有怎么接触过所以不过多评价。主要的难点在于右手的六度音（确实不太了解，但六度音相当的不好弹，比三度音更难弹）。左手的旋律也不轻松。</p><h3 id="No-11-Winter-Wind-冬风"><a href="#No-11-Winter-Wind-冬风" class="headerlink" title="No.11 Winter Wind&#x2F;冬风"></a>No.11 Winter Wind&#x2F;冬风</h3><div style="position: relative; width: 100%; height: 0; padding-bottom: 56.3%; margin: 20px 0"><iframe loading="lazy" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://www.youtube-nocookie.com/embed/60Upg8Hz0rI?si=HjbZr0-io_v2_PPT" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe></div><p>演奏者：Kassia</p><p>Op25 第 11 首《a 小调练习曲》，冬风练习曲。这位更是同激流一般的高难度曲目，也是在各大主流平台「非常出圈」的一首曲目。相当多的人接触肖邦练习曲就是因为这首曲子，也因此建立了对于肖邦的恐惧233… 不过根据之前的分析也应该非常清楚了，那就是所谓的肖邦练习曲，冬风在里面实际上也是最难的几首曲目之一了。</p><p>这首曲子有一个非常缓和的开头，简单的简直让人觉得是弹错了。在一阵宁静后，伴随着右手快速的跑动音，冬风就来临了，肖邦是通过一种特定的练习音型来来表现这一点。冬风之所以能够出圈也跟这段的反差有着非常密切的关系。随后，在第一主题被反复的用多个不同的调子跑动完成之后，本来我们想舒一口气，未曾想过第二主题丝毫没有倦怠——正如冬风也是凛冽的，一阵高过一阵。第二主题像是一首革命进行曲，将肖邦的革命性展现的淋漓尽致。从这个角度上来说，《冬风练习曲》同样也将革命意识和反抗压迫的心愿，一如既往的表现出来。整首曲子是用一段快速跑动的音阶进行收尾，和另外一首有着类似意境的曲目《追雪》（李斯特的超技练习曲）有着截然不同的处理。追雪是寒风慢慢的减弱，冬风则有点戛然而止的味道，因此在意境的表现上我会投《追雪》一票。但即便是有点小瑕疵，也不影响这首曲子同样有着极高的音乐性。</p><p>彪罗对此曲评价：「在你能想象的范围内展现着最丰富的音。」</p><h3 id="No-12-Ocean-大海"><a href="#No-12-Ocean-大海" class="headerlink" title="No.12 Ocean&#x2F;大海"></a>No.12 Ocean&#x2F;大海</h3><div style="position: relative; width: 100%; height: 0; padding-bottom: 56.3%; margin: 20px 0"><iframe loading="lazy" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://www.youtube-nocookie.com/embed/7EBRJbGYfSg?si=qk5mFr7hSluKzVyI" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe></div><p>演奏者：Kassia</p><p>Op25 第 12 首《c 小调练习曲》，大海练习曲。这首曲子肖邦作于 1831 年，正值「华沙起义」失败之时，据说肖邦是因为听到革命失败的时候所作的曲子。这首曲子和《冬风》差不多同一时间创立，具备极高的革命性质。这首练习曲听起来是一首爱国主义的音诗，肖邦在这里叙述了他的爱国主义激情。在川流不息的分解和弦和短小、坚毅、果断的插句里，都使人感到一股不可抗衡的巨大力量。</p><p>未完待续…</p><p>为了性能的保证，只能分级出个下集，下集主要写一些零散的篇章，夜曲，圆舞曲，玛祖卡，谐谑曲等内容。其中的很大一部分展示了肖邦浪漫的一面。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>维基百科：肖邦叙事曲 <a href="https://zh.wikipedia.org/wiki/%E5%8F%99%E4%BA%8B%E6%9B%B2_(%E8%82%96%E9%82%A6)">https://zh.wikipedia.org/wiki/%E5%8F%99%E4%BA%8B%E6%9B%B2_(%E8%82%96%E9%82%A6)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="音乐鉴赏" scheme="https://blog.pengdonglai.com/categories/%E9%9F%B3%E4%B9%90%E9%89%B4%E8%B5%8F/"/>
    
    
    <category term="Music" scheme="https://blog.pengdonglai.com/tags/Music/"/>
    
    <category term="Chopin" scheme="https://blog.pengdonglai.com/tags/Chopin/"/>
    
    <category term="肖邦" scheme="https://blog.pengdonglai.com/tags/%E8%82%96%E9%82%A6/"/>
    
    <category term="音乐" scheme="https://blog.pengdonglai.com/tags/%E9%9F%B3%E4%B9%90/"/>
    
    <category term="近代浪漫派" scheme="https://blog.pengdonglai.com/tags/%E8%BF%91%E4%BB%A3%E6%B5%AA%E6%BC%AB%E6%B4%BE/"/>
    
  </entry>
  
  <entry>
    <title>JSON 转换为 TypeScript 接口</title>
    <link href="https://blog.pengdonglai.com/2024/05/04/convert-json2interface/"/>
    <id>https://blog.pengdonglai.com/2024/05/04/convert-json2interface/</id>
    <published>2024-05-04T09:45:30.000Z</published>
    <updated>2024-06-03T17:04:59.286Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><textarea style="width: 100%; height: 400px; background: rgba(255, 255, 255, 0.3); border-radius: 5px; padding: 8px;" id="textSrc">{  "url": "https://blog.pengdonglai.com/",  "posts": [    { "title": "日记", "date": "2016.06.08" },    { "title": "随笔", "date": "2016.06.09" }  ],  "last-update": 1465388410306}</textarea><p><button id="btnConvert" class="btn btn-small">点我转换</button></p><textarea style="width: 100%; height: 400px; background: rgba(255, 255, 255, 0.3); border-radius: 5px; padding: 8px;" id="textOut" rows="20" readonly></textarea><h3 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h3><p>代码 forked from <a href="https://static.jixun.moe/json2tsinterface.html">https://static.jixun.moe/json2tsinterface.html</a>，我做了一些改良。</p><p>有了这个工具之后<s>摸鱼</s>的效率明显高了许多。</p><script>(function ($) {  function toInterface (variable) {    var interfaceNames = ['IUnknown'];    var extra_interface = '';    function getVariableType (variable, name) {      if (variable === undefined) {        return 'void /* undefined */';      }      var type = typeof variable;      if (type == 'object') {        if (!variable)          return 'void /* 未知类型 */';        if (name.slice(-2) == 'es') {          name = name.slice(0, -2);        } else if (name.slice(-1) == 's') {          name = name.slice(0, -1);        }        if (variable.constructor.name == 'Array') {          return getVariableType(variable[0], name) + '[]';        }        if (name) {          name = name[0].toUpperCase() + name.slice(1);        } else {          name = 'Unknown';        }        var ifName = 'I' + name;        if (interfaceNames.indexOf(ifName) != -1) {          var i = 1;          while (interfaceNames.indexOf(ifName + '_' + i) != -1) {            i++;          }          ifName = ifName + '_' + i;        }        interfaceNames.push(ifName);        var extra = generateInterface(ifName, variable, '');        extra_interface = extra + extra_interface;        return ifName;      }      return type;    }    function formatKey (key) {      if (!/^[a-z][a-z\d]*$/i.test(key))        return JSON.stringify(key);      return key;    }    function generateInterface (pref_name, variable, indent) {      var r = '\n' + indent + 'interface ' + pref_name + ' {\n';      var sub_indent = '\t' + indent;      r += Object.keys(variable).map(function(k){        return sub_indent + formatKey(k) + ': ' + getVariableType(variable[k], k);      }).join(';\n') + ';\n';      r += indent + '}\n\n';      return r;    }    var interface = generateInterface('IUnknown', variable, '');    return (interface + '\n/* 自动生成的 Interface */\n' + extra_interface).trim();  };  var $src = $('textSrc'),    $out = $('textOut');  function procClick () {    try {      var data = JSON.parse($src.value);      $out.value = toInterface(data);    } catch (err) {      $out.value = err;    }  }  $('btnConvert').onclick = procClick;  procClick();})(document.getElementById.bind(document));</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="开箱即用" scheme="https://blog.pengdonglai.com/categories/%E5%BC%80%E7%AE%B1%E5%8D%B3%E7%94%A8/"/>
    
    
    <category term="JSON" scheme="https://blog.pengdonglai.com/tags/JSON/"/>
    
    <category term="interface" scheme="https://blog.pengdonglai.com/tags/interface/"/>
    
    <category term="Typescript" scheme="https://blog.pengdonglai.com/tags/Typescript/"/>
    
  </entry>
  
  <entry>
    <title>图床数据库插入 SQL 生成</title>
    <link href="https://blog.pengdonglai.com/2024/05/04/generate-img-insert-sql/"/>
    <id>https://blog.pengdonglai.com/2024/05/04/generate-img-insert-sql/</id>
    <published>2024-05-04T04:49:27.000Z</published>
    <updated>2024-06-03T17:04:59.297Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><style>.dragover-area {  border: 1px dashed #7f7f7f;  border-radius: 8px;  margin-top: 20px;  margin-bottom: 20px;}.dragover-area-inner {  margin-top: 2.5rem;  margin-bottom: 2.5rem;  display: flex;  flex-direction: column;  align-items: center;  justify-content: center;}</style><p>假设你有一些存储在对象存储上的图片，现在想要将这些图片的 URL 存入到数据库中。只需要将图片在本地的那一份拖入并添加，在下面填写好被插入的表名和对象存储的 URL，就可以生成 SQL 语句了。</p><div class="mt-3 mb-3 dragover-area" id="dropzone" ondrop="drop(event)" ondragover="allowDrop(event)">  <div class="dragover-area-inner">    <p>拖放图片到此处来添加</p>    <div class="d-grid mx-auto d-sm-block gap-3">      <button type="button" class="btn btn-small" onclick="clearFiles()">清空图片</button>    </div>  </div></div><p>已添加的图片数：<span id="addedPicsCount">0</span></p><label class="switch">  <input type="checkbox" id="isReconstructTable">  <span>删除并重建表格</span></label><p>开：生成的 SQL 会删除 (Drop) 并重建 (Create) 表格，然后插入 (Insert) 图片数据。也就是说，表格中的所有旧数据都会被删除。适合初次使用或者想要清空表格的情况。</p><p>关：生成的 SQL 只会插入 (Insert) 图片数据。也就是说，表格中的所有旧数据都会被保留。适合已经有数据，只想追加图片的情况。</p><p>被插入的表名（比如 tableName）：<br><input type="text" class="form-control form-control-lg" id="tableName"></p><p>对象存储的根 UR（<a href="https://aaa.xxx.com/">https://aaa.xxx.com</a>）：<br><input type="text" class="form-control form-control-lg" id="baseUrl"></p><p><button type="button" class="btn btn-small btn-lg mb-3" onclick="generateSQL()">生成并下载 SQL</button></p><p>建议：使用 id 索引进行查询优化，这样子可以极大的节省查询的行数。毕竟一个表成千上万，Cloudflare 5M 的查询消耗会比想象中要快得多。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> <span class="token identifier"><span class="token punctuation">`</span>[tableName]-id<span class="token punctuation">`</span></span> <span class="token keyword">ON</span> <span class="token identifier"><span class="token punctuation">`</span>[tableName]<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><script>let addedImages = [];const addedPicsCountControl = document.getElementById("addedPicsCount");const tableNameControl = document.getElementById("tableName");const baseUrlControl = document.getElementById("baseUrl");const isReconstructTableControl = document.getElementById("isReconstructTable");function allowDrop(event) {    event.preventDefault();}function drop(event) {    event.preventDefault();    const files = event.dataTransfer.files;    if (files.length > 0) {        // 把每一张图片都添加到 addedImages 数组中        for (let i = 0; i < files.length; i++) {            if (files[i].type.startsWith("image/")) {                addedImages.push(files[i]);            }        }    }    addedPicsCountControl.textContent = addedImages.length.toString();}async function getImageDimensions(objURL) {    return new Promise((resolve) => {        var img = new Image();        img.src = URL.createObjectURL(objURL);        img.onload = function () {            var width = img.width;            var height = img.height;            resolve({ width, height });        };    });}async function generateSQL() {    let sqls = [];    const dropTableSql = `DROP TABLE IF EXISTS \`${tableNameControl.value}\`;`;    const createTableSql = `CREATE TABLE IF NOT EXISTS \`${tableNameControl.value}\` (            id INTEGER PRIMARY KEY   AUTOINCREMENT,    name VARCHAR(255),    url VARCHAR(255),    size INT,    width INT,    height INT,    ratio DECIMAL(5, 3),    landscape BOOLEAN,    near_square BOOLEAN,    big_size BOOLEAN,    small_size BOOLEAN,    mid_size BOOLEAN,    big_res BOOLEAN,    small_res BOOLEAN,    mid_res BOOLEAN,    bjn BOOLEAN);`;    if (isReconstructTableControl.checked)    {        sqls.push(dropTableSql);        sqls.push(createTableSql);    }    if (addedImages) {        for (let i = 0; i < addedImages.length; i++) {            let a = null;            try {                const dimensions = await getImageDimensions(addedImages[i]);                a = dimensions; // 此时 a 包含宽度和高度信息            } catch (error) {                console.error('Error:', error);            }            const fileName = addedImages[i].name;            const url = baseUrlControl.value + "/" + encodeURIComponent(fileName);            const fileSize = addedImages[i].size;            const width = a.width;            const height = a.height;            // 保留三位小数            const ratio = parseFloat((width / height).toFixed(3));            const landscape = width > height;            const nearSquare = ratio > 0.9090909 && ratio < 1.1;            const bigSize = fileSize > 600000;            const smallSize = fileSize < 100000;            const midSize = !bigSize && !smallSize;            // 短边大于1440            const bigRes = width > 1440 || height > 1440;            // 短边小于640            const smallRes = width < 640 || height < 640;            const midRes = !bigRes && !smallRes;            // 名字包含bjn字样            const bjn = fileName.includes("bjn");                        sqls.push(`INSERT INTO \`${tableNameControl.value}\` (name, url, size, width, height, ratio, landscape, near_square, big_size, small_size, mid_size, big_res, small_res, mid_res, bjn) VALUES ('${fileName}', '${url}', ${fileSize}, ${width}, ${height}, ${ratio}, ${landscape}, ${nearSquare}, ${bigSize}, ${smallSize}, ${midSize}, ${bigRes}, ${smallRes}, ${midRes}, ${bjn});`);        }        // 保存为 txt 文件        const sqlsText = sqls.join("\n");        const blob = new Blob([sqlsText], { type: "text/plain;charset=utf-8" });        const objectURL = URL.createObjectURL(blob);        const aTag = document.createElement("a");        aTag.href = objectURL;        aTag.download = `${tableNameControl.value}.txt`;        aTag.click();        // 释放一个之前已经存在的、通过调用 URL.createObjectURL() 创建的 URL 对象。        // 当你结束使用某个 URL 对象之后，应该通过调用这个方法来让浏览器知道不用在内存中继续保留对这个文件的引用了。        URL.revokeObjectURL(objectURL);    }    else {        alert("请先拖放一张图片，然后点击“开始”按钮。");    }}function clearFiles() {    addedImages = [];    addedPicsCountControl.textContent = "0";}</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="开箱即用" scheme="https://blog.pengdonglai.com/categories/%E5%BC%80%E7%AE%B1%E5%8D%B3%E7%94%A8/"/>
    
    
    <category term="Tools" scheme="https://blog.pengdonglai.com/tags/Tools/"/>
    
    <category term="数据库" scheme="https://blog.pengdonglai.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="图床" scheme="https://blog.pengdonglai.com/tags/%E5%9B%BE%E5%BA%8A/"/>
    
  </entry>
  
  <entry>
    <title>新博客从出生到迁移的变化记录</title>
    <link href="https://blog.pengdonglai.com/2024/05/01/change-log/"/>
    <id>https://blog.pengdonglai.com/2024/05/01/change-log/</id>
    <published>2024-05-01T02:36:05.000Z</published>
    <updated>2024-06-03T17:04:59.286Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>记忆是知识的唯一管库人。</p></blockquote><h3 id="2024-05-12"><a href="#2024-05-12" class="headerlink" title="2024-05-12"></a>2024-05-12</h3><p>将文档站添加到了博客的导航栏。并且完善了文档站的第一个 API。</p><p>开了一个新坑：《肖邦：大师之作》，准备留下我听古典的回忆。</p><h3 id="2024-05-05"><a href="#2024-05-05" class="headerlink" title="2024-05-05"></a>2024-05-05</h3><p>将工具与文章分开，并且优化类布局和展现逻辑。修改了绿色主题让它与其它颜色一致。</p><h3 id="2024-05-04"><a href="#2024-05-04" class="headerlink" title="2024-05-04"></a>2024-05-04</h3><p>发布了一个转换图片为链接插入 sql 的工具。</p><h3 id="2024-05-03"><a href="#2024-05-03" class="headerlink" title="2024-05-03"></a>2024-05-03</h3><p>个人主页 index 页正式发布，并且修复了一些 bug，主要是代码框的展开按钮的 <code>z-index</code> 居然是 999，原作者有点东西。</p><h3 id="2024-05-01"><a href="#2024-05-01" class="headerlink" title="2024-05-01"></a>2024-05-01</h3><p>发布了文章《changelog》保存的记忆，又多了一份。</p><h3 id="2024-04-30"><a href="#2024-04-30" class="headerlink" title="2024-04-30"></a>2024-04-30</h3><p>进一步优化了文章内「目录」的样式。看起来不再别扭。</p><h3 id="2024-04-29"><a href="#2024-04-29" class="headerlink" title="2024-04-29"></a>2024-04-29</h3><p>暗黑模式推倒重建，主要的目标是履行最好的实践，让背景看起来不那么黑。目前改动已上线。</p><h3 id="2024-04-27"><a href="#2024-04-27" class="headerlink" title="2024-04-27"></a>2024-04-27</h3><p>最近有大量处理图片的需求，并且对图片的原理也做了进一步的学习，所以发布了第二篇技术文章《图片压缩的不同姿势》，以总结为主。应该是市面上最全的图片压缩的总结，文章历经多次更新最终达到了万字规模。</p><h3 id="2024-04-20"><a href="#2024-04-20" class="headerlink" title="2024-04-20"></a>2024-04-20</h3><p>博客样式微调。</p><h3 id="2024-04-19"><a href="#2024-04-19" class="headerlink" title="2024-04-19"></a>2024-04-19</h3><p>博客文章图片实现懒加载，访问速度提升。</p><p>博客上线四周年，终于实现了长久以来的 breaking change 梦想！</p><h3 id="2024-04-14"><a href="#2024-04-14" class="headerlink" title="2024-04-14"></a>2024-04-14</h3><p>发布了文章《国内二次元随机图片 API》汇总，具备非常高的收藏意义。不过文章后续 API 发生了变化，维护是个大问题。</p><h3 id="2024-04-12"><a href="#2024-04-12" class="headerlink" title="2024-04-12"></a>2024-04-12</h3><p>breaking change:</p><ul><li>迁移到了 Vercel 上，并且把节点换成香港的服务器</li><li>启动 PWA 功能，缓存覆盖率提升</li><li>删除了网易云的 iframe，启用了音乐页面，使用 APlayer 播放器，并且针对博客进行了样式优化</li><li>导航栏的样式进行了优化</li><li>改进了部分 alt 文案，和文案选择的逻辑，a11y 评分提升。</li></ul><p>做完了以上，博客速度 LightHouse 评分从 81 分优化到了 90+ 分。</p><h3 id="2024-04-11"><a href="#2024-04-11" class="headerlink" title="2024-04-11"></a>2024-04-11</h3><p>breaking change:</p><ul><li>给博客添加了 CDN 访问，挂载到了 jsDelivr</li><li>所有的图片全部经历一次更新，换成了更符合 XP 和美观的，原神浓度下降。全部换成 webp 格式</li><li>图片再经历一次压缩</li><li>对所有的资源文件进行了压缩</li></ul><p>做完了以上，博客速度 LightHouse 评分从 56 分优化到了 81 分。</p><h3 id="2024-04-05"><a href="#2024-04-05" class="headerlink" title="2024-04-05"></a>2024-04-05</h3><p>尝试做了个工具，帮助记忆日语动词。但是更新了 20 个动词后就咕咕了。因为博主又病了。</p><h3 id="2024-02-09"><a href="#2024-02-09" class="headerlink" title="2024-02-09"></a>2024-02-09</h3><p>深感日语学习的语法之零碎，于是开了个新坑，发布了文章《一些较为零散的日语语法点归总》。准备后续来慢慢打理这篇文章。</p><h3 id="2024-01-11"><a href="#2024-01-11" class="headerlink" title="2024-01-11"></a>2024-01-11</h3><p>更新了博客的颜色细节。</p><h3 id="2024-01-09"><a href="#2024-01-09" class="headerlink" title="2024-01-09"></a>2024-01-09</h3><p>首次在博客更新去年一年的总结，发布了《海星来来的 2023 年总结》</p><h3 id="2023-11-19"><a href="#2023-11-19" class="headerlink" title="2023-11-19"></a>2023-11-19</h3><p>因为在公司写脚手架，所以学习了 Node.js 开发 CLI 程序，并且发布了《How to create a CLI program using Node.js》，这篇文章是博客的第一个技术文章。</p><h3 id="2023-11-11"><a href="#2023-11-11" class="headerlink" title="2023-11-11"></a>2023-11-11</h3><p>博客上线了简繁体转换的功能。</p><h3 id="2023-10-29"><a href="#2023-10-29" class="headerlink" title="2023-10-29"></a>2023-10-29</h3><p>将以前的剑桥雅思做题记录慢慢的发上来，发布了大作文心得《Task 2 理念篇》，这是以前看 Vince 大佬的视频写的笔记总结。</p><h3 id="2023-10-24"><a href="#2023-10-24" class="headerlink" title="2023-10-24"></a>2023-10-24</h3><p>发布了《部分剑桥雅思的做题记录和沉淀》2。</p><h3 id="2023-10-21"><a href="#2023-10-21" class="headerlink" title="2023-10-21"></a>2023-10-21</h3><p>上线了《通过一些句子增加雅思听力词汇》其中的 4 篇，这个系列就完结了。成为了本博客第一个被完结的系列。</p><h3 id="2023-10-19"><a href="#2023-10-19" class="headerlink" title="2023-10-19"></a>2023-10-19</h3><p>将以前的剑桥雅思做题记录慢慢的发上来，首先发布了《部分剑桥雅思的做题记录和沉淀》1。</p><h3 id="2023-10-17"><a href="#2023-10-17" class="headerlink" title="2023-10-17"></a>2023-10-17</h3><p>总结了雅思听力常考的一些偏僻听力词汇，并且组成了几百个句子，并且在博客上线了《通过一些句子增加雅思听力词汇》其中的 1-3 篇。</p><p>上线了一个文字格式化的工具，以文章的形式发布。主要用于 markdown 的校正以及中英文之间的间隔。现在已经不太更新了，好像使用确实也会有点问题。</p><h3 id="2023-10-09"><a href="#2023-10-09" class="headerlink" title="2023-10-09"></a>2023-10-09</h3><p>游戏《冒险王精灵物语》作为小时候最喜欢玩的游戏之一，在博客重新上线。</p><h3 id="2023-10-07"><a href="#2023-10-07" class="headerlink" title="2023-10-07"></a>2023-10-07</h3><p>暗黑的机制完善了，可以在 js 的层面感知到页面的暗黑变化。暗黑模式建设告一段落。</p><h3 id="2023-10-06"><a href="#2023-10-06" class="headerlink" title="2023-10-06"></a>2023-10-06</h3><p>breaking change:</p><ul><li>图片进行进一步替换</li><li>给博客上线了 live-2d 功能，并增强它的功能</li><li>更新了大量颜色细节，看起来更加协调</li><li>上线了暗黑模式，并且给暗黑模式设计了一套主题色</li><li>几个 4399 童年最喜欢玩的游戏，以文章的形式被发布</li><li>发布文章《英语听力磨耳朵》，尝试最佳的写作范式</li></ul><h3 id="2023-10-05"><a href="#2023-10-05" class="headerlink" title="2023-10-05"></a>2023-10-05</h3><p>breaking change:</p><ul><li>图片进行进一步替换</li><li>给博客上线了 404，分类，友链，标签，归档功能</li><li>从网易云拿来了个 iframe，可以在博客内播音乐</li><li>更新了大量颜色细节，看起来更加协调</li><li>主题色更新为：橙 蓝 紫 绿四种颜色，并且根据图片的色调每天做更换</li><li>在本地更新了开发、上线范式</li></ul><h3 id="2023-10-04"><a href="#2023-10-04" class="headerlink" title="2023-10-04"></a>2023-10-04</h3><p>博客的主人开始对 Matery 主题进行大幅度的自定义更新，这一天是 breaking change 的日子。</p><ul><li>将原生的图片全数替换，替换成二次元的模样</li><li>主题更新，换了个好看的，纯 css 加载的新背景</li><li>更新了大量颜色细节，看起来更加协调</li><li>花里胡哨的东西，看起来像是进了夜店的装饰，通通删掉</li><li>更新了另一种不同的主题色</li></ul><h3 id="2023-10-03"><a href="#2023-10-03" class="headerlink" title="2023-10-03"></a>2023-10-03</h3><p>选择 Matery 为 Hexo 主题，并且更新主题上线。</p><h3 id="2023-10-02"><a href="#2023-10-02" class="headerlink" title="2023-10-02"></a>2023-10-02</h3><p>博客在一夜之间从 WordPress 迁移到了 Hexo。因为 WordPress 的语言 PHP 实在是不会用。</p><h3 id="2023-10-01"><a href="#2023-10-01" class="headerlink" title="2023-10-01"></a>2023-10-01</h3><p>转眼间来到了 10 月，此时一切都已经尘埃落定。博客的主人开始对博客进行 breaking change。</p><h3 id="2023-04-19"><a href="#2023-04-19" class="headerlink" title="2023-04-19"></a>2023-04-19</h3><p>三周年，无事发生。</p><h3 id="2023-02-01"><a href="#2023-02-01" class="headerlink" title="2023-02-01"></a>2023-02-01</h3><p>博客的主人在毕设的重压下，选择不更新。</p><h3 id="2022-12-28"><a href="#2022-12-28" class="headerlink" title="2022-12-28"></a>2022-12-28</h3><p>博客的主人毕业后有了新去处，准备考虑是否要恢复博客更新。</p><h3 id="2022-04-19"><a href="#2022-04-19" class="headerlink" title="2022-04-19"></a>2022-04-19</h3><p>上线两周年，没时间打理博客。博客的主人在年初去<a href="https://www.bytedance.com/en/">字节跳动</a>搬砖了，鸽的有些顺理成章。<s>你甚至在博客里面看不到他更新面试心得。</s></p><p>此时博客还只是 WordPress 的静态博客，没有评论功能，没有搜索功能，没有归档功能，没有标签功能。甚至连样式都是最原始的。只有两篇文章。</p><h3 id="2021-12-19"><a href="#2021-12-19" class="headerlink" title="2021-12-19"></a>2021-12-19</h3><p>工信部的人不懂海祇岛怎么念，笑喷了。然后就是很疑惑为什么备案不能出现「博客」等字眼。</p><h3 id="2021-12-12"><a href="#2021-12-12" class="headerlink" title="2021-12-12"></a>2021-12-12</h3><p>给博客起名「海祇岛的珊瑚森林」，虽然原神我应该没时间玩了，但是这个昵称我仍然非常满意，会一直用下去。</p><h3 id="2021-12-10"><a href="#2021-12-10" class="headerlink" title="2021-12-10"></a>2021-12-10</h3><p>注册了域名 <a href="https://starfishdl.site/">https://starfishdl.site</a>，之后给博客添加了这个域名，并且在工信部完成备案。</p><h3 id="2021-11-10"><a href="#2021-11-10" class="headerlink" title="2021-11-10"></a>2021-11-10</h3><p>博客使用 WordPress 重新发布，并且使用 WordPress 发布了一篇现在已经找不到了的文章。</p><h3 id="2021-04-19"><a href="#2021-04-19" class="headerlink" title="2021-04-19"></a>2021-04-19</h3><p>博客上线一周年，它无事发生。主要是主人离线太久了。</p><h3 id="2020-04-19"><a href="#2020-04-19" class="headerlink" title="2020-04-19"></a>2020-04-19</h3><p>发现 GitHub Pages 这个好东西，然后博客用 GitHub Pages 发布。是为博客上线日。链接就是刚刚注册的那种，以 github.io 结尾的。</p><h3 id="2020-04-02"><a href="#2020-04-02" class="headerlink" title="2020-04-02"></a>2020-04-02</h3><p>苦修前端三件套，写好的 HTML 文件发布在 GitHub 上。</p><h3 id="2019-10-01"><a href="#2019-10-01" class="headerlink" title="2019-10-01"></a>2019-10-01</h3><p>博客正式建立，最开始是以云笔记的形式存在，当天我注册了 GitHub，想着需要在 GitHub 上也上传点东西，可是那个时候也不怎么会写代码，于是我将笔记发在了 GitHub 上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="碎碎念" scheme="https://blog.pengdonglai.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
    <category term="碎碎念" scheme="https://blog.pengdonglai.com/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>图片压缩的不同姿势</title>
    <link href="https://blog.pengdonglai.com/2024/04/27/picture-compress-api/"/>
    <id>https://blog.pengdonglai.com/2024/04/27/picture-compress-api/</id>
    <published>2024-04-27T12:14:53.000Z</published>
    <updated>2024-06-03T17:04:59.504Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>众所周知，前端有许多切图的需求，其中对于图片的优化与前端也息息相关。因此无论是前端工作，还是博客的运营，亦或是希望可以用更小的成本玩转图片，必定涉及大量图片操作需求。与图片打过一些交道了，自然而然就会产生一些心得。</p><p>而在这其中，图片压缩是优化的重要手段。LCP 同样作为用户感知明显的指标之一，而图片的加载直接影响 LCP。在众多的前端面试题中，我们会经常看到图片优化的手段，但是一些优化手段如懒加载，其实也会影响用户的体验。而图片压缩，只要使用无损压缩，那么用户的体验会更好，是典型的无副作用方案。本文将介绍我平时用的顺手，并且效率也相对较高的图片处理模式。</p><blockquote><p>本文仍然在施工中…只是个半成品，后续如果有更好用的方法，我会及时更新。</p></blockquote><h2 id="图片格式转换"><a href="#图片格式转换" class="headerlink" title="图片格式转换"></a>图片格式转换</h2><p>WebP 是一种现代图片格式，可为网络上的图片提供出色的无损和有损压缩。使用 WebP，网站站长和 Web 开发者可以创建更小、更丰富的图片，从而提高网页加载速度。</p><p>与 PNG 相比，WebP 无损图片的尺寸<a href="https://developers.google.com/speed/webp/docs/webp_lossless_alpha_study?hl=zh-cn#results">缩小了 26%</a>。WebP 有损图片比采用等效 <a href="https://en.wikipedia.org/wiki/Structural_similarity">SSIM</a> 质量指数的同等 JPEG 图片<a href="https://developers.google.com/speed/webp/docs/webp_study?hl=zh-cn">小 25-34%</a>。</p><p>无损 WebP 支持透明度（也称为 Alpha 通道），但只需<a href="https://developers.google.com/speed/webp/docs/webp_lossless_alpha_study?hl=zh-cn#results">额外增加 22% 的字节</a>。对于可以接受有损 RGB 压缩的情况，有损 WebP 也支持透明度，其文件大小通常比 PNG 小 3 倍。</p><p>动画 WebP 图片支持有损、无损和透明度，与 GIF 和 APNG 相比，此类图片可缩减大小。</p><p>如今都 2024 了，我们没有理由继续使用不再支持 <code>WebP</code> 格式的设备。事实上不支持的设备凤毛麟角。所以放心大胆的将图片转换为 <code>WebP</code> 吧！除了 Python 提供类似于 image 这样的库之外，还有一些工具可以帮助我们完成图片格式的转换。</p><p>以下为 Python 提供的能力，可谓是门槛最低的方法了：</p><ul><li>使用 cv2 库将图片从 png 格式转换为 webp 格式</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token comment"># 读入 PNG 格式的图片</span>img <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'input.png'</span><span class="token punctuation">)</span><span class="token comment"># 转换为 WebP 格式的图片，并保存</span>cv2<span class="token punctuation">.</span>imwrite<span class="token punctuation">(</span><span class="token string">'output.webp'</span><span class="token punctuation">,</span> img<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">(</span>cv2<span class="token punctuation">.</span>IMWRITE_JPEG_QUALITY<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用 PIL 库将图片从 webp 格式转换为 png 格式</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> PIL <span class="token keyword">import</span> Imageimg <span class="token operator">=</span> Image<span class="token punctuation">.</span><span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'input.webp'</span><span class="token punctuation">)</span>img<span class="token punctuation">.</span>load<span class="token punctuation">(</span><span class="token punctuation">)</span>img<span class="token punctuation">.</span>save<span class="token punctuation">(</span><span class="token string">'output.png'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="集成到系统原生"><a href="#集成到系统原生" class="headerlink" title="集成到系统原生"></a>集成到系统原生</h3><p><a href="https://developers.google.com/speed/webp/docs/precompiled?hl=zh-cn">https://developers.google.com/speed/webp/docs/precompiled?hl=zh-cn</a></p><p>考虑到 WebP 是由 Google 发起的，我们可以方便的使用 Google Developer 提供的建议。我们甚至可以将 WebP 格式转换的能力内置进入系统，像 node 一样使用。如果我们这么做了，可能第一次操作的时候需要摸索，但是一旦习惯了，以后我们可以方便的使用命令行文件进行处理。</p><p>笔者使用的是 MacOS 系统，因此会比较详细的列举 Mac 的使用方法。或许我们日后可以使用类似的方法在 Linux 上使用它。Windows 系统的话，<s>先咕了，去官网应该能看懂怎么下载。</s></p><ol><li>使用 homebrew 安装 webp。<code>brew install webp</code>. 请先确保你的 brew 可用，然后再进行安装。</li></ol><p>homebrew 链接：<a href="https://formulae.brew.sh/formula/webp">https://formulae.brew.sh/formula/webp</a></p><p>以上过程会将整个 webp 的转换工具都安装到你的系统中，如果你的系统已经安装了 webp，那么可以使用 <code>brew info webp</code> 查看<s>实际上也就是把 homebrew 的官网文字给你输出了一遍而已</s>。</p><p>它包括了：<code>cwebp</code> <code>dwebp</code>(将图片转换为原来的格式) <code>img2webp</code> 等工具。这里我们先使用 <code>cwebp</code> 举例子，进行转换。</p><ol start="2"><li>压缩为 WebP 无损压缩，需要保证 input.png 在当前目录下。</li></ol><p>我们使用 <code>cwebp</code> 工具中的“无损”选项将 PNG 转换为 WebP 无损格式。要获得最少的输出，所使用的确切命令行如下所示：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cwebp input.png <span class="token parameter variable">-lossless</span> <span class="token parameter variable">-m</span> <span class="token number">6</span> <span class="token parameter variable">-q</span> <span class="token number">100</span> <span class="token parameter variable">-o</span> webp_lossless.webp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>压缩为 WebP 有损压缩（使用 alpha 通道）</li></ol><p>我们使用 <code>cwebp</code> 工具将 PNG 转换为 WebP 有损（带有 alpha 通道）。我们选择的 WebP 质量为 90（有损压缩），alpha 质量为 100（无损压缩）。使用的确切命令行如下所示：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cwebp input.png <span class="token parameter variable">-q</span> <span class="token number">90</span> <span class="token parameter variable">-alpha_q</span> <span class="token number">100</span> <span class="token parameter variable">-m</span> <span class="token number">6</span> <span class="token parameter variable">-o</span> webp_alpha.webp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>关于 <code>cwebp</code> 的文档，可以查看：<a href="https://developers.google.com/speed/webp/docs/cwebp?hl=zh-cn">https://developers.google.com/speed/webp/docs/cwebp?hl=zh-cn</a></p><p>有了上述技能，我们完全可以写一个脚本，批量将图片转换为 webp 格式。例如，如需转换文件夹中的所有 jpeg 文件，请尝试执行以下操作：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">for</span> <span class="token for-or-select variable">F</span> <span class="token keyword">in</span> *.jpg<span class="token punctuation">;</span> <span class="token keyword">do</span> cwebp <span class="token variable">$F</span> <span class="token parameter variable">-o</span> <span class="token variable"><span class="token variable">`</span><span class="token function">basename</span> $<span class="token punctuation">&#123;</span>F%.jpg<span class="token punctuation">&#125;</span><span class="token variable">`</span></span>.webp<span class="token punctuation">;</span> <span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果是无损压缩，我们只需要使用 <code>-lossless</code> 参数即可，当然，为确保最大的压缩比率，这里也可以使用 <code>-q</code>。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">for</span> <span class="token for-or-select variable">F</span> <span class="token keyword">in</span> *.jpg<span class="token punctuation">;</span> <span class="token keyword">do</span> cwebp <span class="token string">"<span class="token variable">$F</span>"</span> <span class="token parameter variable">-lossless</span> <span class="token parameter variable">-q</span> <span class="token number">100</span> <span class="token parameter variable">-o</span> <span class="token string">"<span class="token variable"><span class="token variable">`</span><span class="token function">basename</span> $<span class="token punctuation">&#123;</span>F%.jpg<span class="token punctuation">&#125;</span><span class="token variable">`</span></span>.webp"</span><span class="token punctuation">;</span> <span class="token keyword">done</span><span class="token keyword">for</span> <span class="token for-or-select variable">F</span> <span class="token keyword">in</span> *.png<span class="token punctuation">;</span> <span class="token keyword">do</span> cwebp <span class="token string">"<span class="token variable">$F</span>"</span> <span class="token parameter variable">-lossless</span> <span class="token parameter variable">-q</span> <span class="token number">100</span> <span class="token parameter variable">-o</span> <span class="token string">"<span class="token variable"><span class="token variable">`</span><span class="token function">basename</span> $<span class="token punctuation">&#123;</span>F%.png<span class="token punctuation">&#125;</span><span class="token variable">`</span></span>.webp"</span><span class="token punctuation">;</span> <span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当然，用这两种方法不会删除原有的图片，如果我们需要删除原有的图片，可以使用 <code>rm</code> 命令。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">rm</span> <span class="token parameter variable">-rf</span> *.png<span class="token function">rm</span> <span class="token parameter variable">-rf</span> *.jpg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>或者集成：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">for</span> <span class="token for-or-select variable">F</span> <span class="token keyword">in</span> *.jpg<span class="token punctuation">;</span> <span class="token keyword">do</span> cwebp <span class="token string">"<span class="token variable">$F</span>"</span> <span class="token parameter variable">-lossless</span> <span class="token parameter variable">-q</span> <span class="token number">100</span> <span class="token parameter variable">-o</span> <span class="token string">"<span class="token variable"><span class="token variable">`</span><span class="token function">basename</span> $<span class="token punctuation">&#123;</span>F%.jpg<span class="token punctuation">&#125;</span><span class="token variable">`</span></span>.webp"</span> <span class="token operator">&amp;&amp;</span> <span class="token function">rm</span> <span class="token parameter variable">-rf</span> <span class="token string">"<span class="token variable">$F</span>"</span><span class="token punctuation">;</span> <span class="token keyword">done</span><span class="token keyword">for</span> <span class="token for-or-select variable">F</span> <span class="token keyword">in</span> *.png<span class="token punctuation">;</span> <span class="token keyword">do</span> cwebp <span class="token string">"<span class="token variable">$F</span>"</span> <span class="token parameter variable">-lossless</span> <span class="token parameter variable">-q</span> <span class="token number">100</span> <span class="token parameter variable">-o</span> <span class="token string">"<span class="token variable"><span class="token variable">`</span><span class="token function">basename</span> $<span class="token punctuation">&#123;</span>F%.png<span class="token punctuation">&#125;</span><span class="token variable">`</span></span>.webp"</span> <span class="token operator">&amp;&amp;</span> <span class="token function">rm</span> <span class="token parameter variable">-rf</span> <span class="token string">"<span class="token variable">$F</span>"</span><span class="token punctuation">;</span> <span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当然，这种方法的另一个好处是，我们完全可以从开源的源代码自行编译成我们需要的程序，可以参考这个链接，这里不再做说明：<a href="https://developers.google.com/speed/webp/docs/compiling?hl=zh-cn">https://developers.google.com/speed/webp/docs/compiling?hl=zh-cn</a></p><h3 id="修图工具"><a href="#修图工具" class="headerlink" title="修图工具"></a>修图工具</h3><h4 id="PhotoShop"><a href="#PhotoShop" class="headerlink" title="PhotoShop"></a>PhotoShop</h4><p>如果 2024 年了，仍然有修图工具不支持导出 <code>WebP</code> 格式，那么你也完全没必要使用它了。</p><p>这里以 PhotoShop 为例子，大致说下如何转换：</p><ol><li>打开图像处理软件，如 PhotoShop、GIMP 等。</li><li>导入要转换的图片文件。</li><li>在软件中打开“文件”菜单，选择“另存为”。</li><li>在弹出的“另存为”对话框中，选择“<code>WebP</code>”格式作为输出格式。</li></ol><p>这里也有一位作者分享了他批量转换格式的姿势：<a href="https://blog.zhheo.com/p/1d8e31d8.html#%E5%A4%A7%E5%8A%9F%E5%91%8A%E6%88%90">https://blog.zhheo.com/p/1d8e31d8.html#%E5%A4%A7%E5%8A%9F%E5%91%8A%E6%88%90</a></p><p>不过，如果我们只是打开 PS 然后改下图片的格式，未免太大材小用。尤其是部分性能不好的电脑，PS 启动关闭可能都需要 1 分钟以上，我开个 PS 就为了改个图片格式？更不用说很多程序员的电脑里面都没有携带 PS 这款软件。自然而然，我们会倾向于使用更轻量化的工具。</p><h4 id="ImageManager"><a href="#ImageManager" class="headerlink" title="ImageManager"></a>ImageManager</h4><p>ImageManager 是一款 VS Code 插件。相比起 PhotoShop，它具备两个优点：可以在 VS Code 内「自给自足」，并且足够轻量化。当然，它之所以能轻量化的原因是因为它明白它主要的功能都是给程序员提供的。因此，它提供的所有功能都是程序员用的比较多的，对于研发来说是比较实用的。</p><p>顺便也膜拜下原作者，这是他在稀土掘金发布的本文链接：<a href="https://juejin.cn/post/7348004403016794147">https://juejin.cn/post/7348004403016794147</a></p><p>作者对于自己的工具，显得十分自信：</p><blockquote><p>同一张图片，TinyPNG 压缩结果为 136kb，时间大概 5s；而 image-manager 压缩效果为 92kb，不到 1s！<br>如果把上传图片、下载图片这些繁琐的操作加到一起，或许 vscode 插件的效率要高上 10 倍有余</p></blockquote><p>这个插件的主要使用方法，作者仍然定义为了「图片压缩」，所以才会去和后文提到的 TinyPNG 进行对比。不过，这个插件也可以实现批量格式转换。如图所示，Image Manager 中，我们选择了一个文件夹下的图片，然后点击「转换」。转换成 webp 后，确实减少了 68% 的体积，同时也会对图片进行压缩。</p><p>在使用的时候，MacOS 使用 <code>Shift+Command+P</code> 快捷键，打开命令面板，输入 <code>Image Manager</code> 即可进入这个页面。</p><div align="center">  <img src="../../../../loading2.svg" data-original="/2024/04/27/picture-compress-api/10.webp"></div><p>不过就笔者的使用体验而言，原生转换为 webp 格式后，使用 TinyPNG 压缩的效果是比这个插件要好的，所以感觉也不能直接把结论下了，应该是和图片本身存在一定的联系，部分图片使用 TinyPNG 效果好，部分使用插件效果好。不过就易用性而言，这个插件确实是做到了极致，而且转换的速度确实也非常快。</p><h3 id="在线转换"><a href="#在线转换" class="headerlink" title="在线转换"></a>在线转换</h3><p>网站上提供在线转换的服务商一大把，这里需要选取几个放在这里展示也是很不容易的。需要说明的是我的选取标准，首先就是质量。至少转换的质量非常高，转换后需要用肉眼看不出来。在某些能选择转换质量的网站上，把质量选到最高，需要能满足这一条件。其次是必须要免费，咱不能为了这唾手可得的功能花钱啊。当然，在线服务的网络状况也是一个重要因素，如果说图片上传下载的体验不好，那么实际上再好的压缩算法，易用性也很差。其中也有部分服务在国内体验可能不太好，因为众首周知的原因。当然，这个部分具体取决于当前使用者的网络状态，我会尽力说明。</p><h4 id="To-WebP"><a href="#To-WebP" class="headerlink" title="To WebP"></a>To WebP</h4><p>ToWebp.io 是一款免费在线工具，可立即转换 WebP，无需将文件上传为标准 JPG、JPEG、PNG、AVIF、GIF 和 ICO。同时，将所有可能的图像格式转换为WebP图像格式。</p><p>这个网站应该是最纯净的将图片转换为 WebP 的网站，并且完全免费。</p><p><a href="https://towebp.io/">https://towebp.io/</a></p><div align="center">  <img src="../../../../loading2.svg" data-original="/2024/04/27/picture-compress-api/9.webp"></div><p>如图所示，它支持拖拽上传，并且支持批量转换。并且具有为数不多的可以调整一些参数的功能。例如不想要太高的转换质量，那么可以调整一下，这个在极致优化的时候感觉会很有用。除此之外，他可以将图片进行缩放，这一下子就将图片压缩的「三板斧」都集齐了。</p><p>可惜的是，它不支持 API 调用。所以仅仅适合于顺手使用下的场景。</p><h4 id="Pixelied"><a href="#Pixelied" class="headerlink" title="Pixelied"></a>Pixelied</h4><p>Pixelied 是一家提供相片编辑器的服务商，旗下有个「Free Image Converter」的图片格式转换工具，让使用者通过浏览器进行在线批次编辑，而且不用担心降低照片画质，也无需下载或安装任何应用程序，提供最快速、免费且易于使用的图片转文件功能，这项服务支持各种常见图片格式包括 PNG、JPG、WebP、SVG、GIF、AVIF 和 TIFF 等超过 100 种格式。</p><div align="center">  <img src="../../../../loading2.svg" data-original="/2024/04/27/picture-compress-api/7.webp"></div><p><a href="https://pixelied.com/convert/jpg-converter/jpg-to-webp">https://pixelied.com/convert/jpg-converter/jpg-to-webp</a></p><p>它最大的优点是：免费且无限制的转换。（后文介绍的一些在线转换服务实际上有转换限制），这让我们在转换的时候可以无负担的使用。</p><p>他们家主要靠图片编辑收钱，因此提供了一些类似于云的服务。好在免费用户也能享受到部分存储空间。据介绍，免费用户有 2GB 的存储空间，确实比较良心。因此完全可以把他家进一步使用当成简易的图片编辑器来使用。付费版的区别主要是能使用更多素材，更多空间和一些 AI 能力，这些对于写代码来说反而不是很需要。</p><p>不过他家似乎没有 API 调用，因此我们无法通过代码来实现批量转换。</p><hr><h4 id="Convertio"><a href="#Convertio" class="headerlink" title="Convertio"></a>Convertio</h4><p>Convertio 是一个线上文件转换工具，它允许用户将文件从一种格式转换为另一种格式。它支持大多数常见的档案格式，包括图像、文件、音讯、影片、电子表格和更多。Convertio 还提供一些额外的功能，例如将 PDF 转换为可编辑的档案格式，或者将多个文件合并为一个单一的文件。</p><div align="center">  <img src="../../../../loading2.svg" data-original="/2024/04/27/picture-compress-api/4.jpeg"></div><p><a href="https://convertio.co/zh/jpg-%60WebP%60/">https://convertio.co/zh/jpg-WebP/</a></p><p>进去之后，我想它友好的页面设计会让您知道怎么操作的，这里就不详细展开了。</p><p>当然，它仍然有一些缺点，并且可能在部分人看来实际上没办法接受。首先是国内访问速度可能较慢，并且在特定条件下，下载的速度极慢。其次，它的免费计划限制较多，文件最大只能 100MB，在 24h 内只能转换 10 个文件，并且最多并行 2 个文件。</p><p>它支持 API 调用的方式，这块单独写在后面。</p><h4 id="CloudConvert"><a href="#CloudConvert" class="headerlink" title="CloudConvert"></a>CloudConvert</h4><p><a href="https://cloudconvert.com/">https://cloudconvert.com/</a></p><p>CloudConvert 最引以为豪的就是它支持 218 种文件格式的转换，当然也可以随意转换图片格式。在它的网站上，你能看到它「Convert Anything to Anything」的标语。事实上，CloudConvert 不但支持转换同类别的文件格式（比如将 JPG 转换为 PNG），它甚至可以跨类别转换，比如将 DOCX 文档转换成 PNG。</p><div align="center">  <img src="../../../../loading2.svg" data-original="/2024/04/27/picture-compress-api/8.webp"></div><p>不过它的免费额度也有限制，每天最多转换 25 个文件，和上面的那家如出一辙。</p><p>它同样支持 API 调用方式。</p><h4 id="改图宝"><a href="#改图宝" class="headerlink" title="改图宝"></a>改图宝</h4><p>改图宝是我比较用的顺手的在线工具，主要是它特别轻量化，并且也会对图片进行一些损害不高的压缩操作。至少我个人用着没啥问题，也没有遇到过收费的情况。</p><div align="center">  <img src="../../../../loading2.svg" data-original="/2024/04/27/picture-compress-api/5.jpeg"></div><p><a href="https://www.gaitubao.com/jpg-gif-png">https://www.gaitubao.com/jpg-gif-png</a></p><p>它的页面也十分友好，进去之后很容易找到图片格式转换的地方。</p><h3 id="比-WebP-更优秀的格式"><a href="#比-WebP-更优秀的格式" class="headerlink" title="比 WebP 更优秀的格式"></a>比 WebP 更优秀的格式</h3><p>当然，比 <code>WebP</code> 格式更好的图片，例如 <code>avif</code>，<code>heic</code> 等格式，目前还不支持多数浏览器的解析，贸然使用可能会导致图片无法正常显示。这种时候我们需要使用图片降级渲染策略。</p><p><a href="https://zh.wikipedia.org/zh-hans/AVIF">AVIF 的维基百科，想仔细研究的去这里！</a></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>picture</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span> <span class="token attr-name">srcset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>img/photo.avif<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>image/avif<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> // 如果浏览器支持使用  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span> <span class="token attr-name">srcset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>img/photo.webp<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>image/webp<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>img/photo.jpg<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Description of Photo<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> // 浏览器不支持<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>picture</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，我们也可以使用 JS 方法来进行判断：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// npm install avif.js</span><span class="token comment">// 下面代码放到reg.js中，然后把avif-sw.js放在web服务器根目录</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"avif.js"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token string">"/avif-sw.js"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>  <span class="token comment">&lt;!-- 注册worker --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>reg.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>  <span class="token comment">&lt;!-- 使用IMG标签嵌入AVIF图像 --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>image.avif<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token comment">&lt;!-- 或者通过CSS属性 --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">background</span><span class="token punctuation">:</span> <span class="token url"><span class="token function">url</span><span class="token punctuation">(</span>image2.avif<span class="token punctuation">)</span></span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上图，我们甚至可以依赖 service worker 的请求拦截特性，当页面发出 <code>fetch</code> 操作时，它可以将请求拦截住，然后给出自己的响应，这样就能在请求完 <code>avif</code> 格式的图片以后，在 service worker 当中调用解码器，将图片转码。同时，因为是运行在 service worker 线程当中，解码操作并不会阻塞 UI 线程。</p><p>另外，由于 <code>avif</code> 是基于 AV1 视频编码的，Chrome 等浏览器在很早之前的版本就内置了 AV1 的解码器，但是直到最近才支持 <code>avif</code> 的解析。</p><p>所以实际上在内置了原生解码器的浏览器版本里面，我们就不需要使用这个 polyfill 实现的 JS 版本解码器了，可以直接使用效率更高的原生解码器。</p><p>当你还在犹豫不决时，<a href="https://www.bilibili.com/">bilibili</a>已经在他们的网站上使用了上了 avif 格式~ 你可以点进去它们的一篇专栏，然后用最新版本的 Chrome 去查看，看看是不是已经使用了 <code>avif</code> 格式的图片了。</p><div align="center">  <img alt="b站现在越来越露了，233" src="../../../../loading2.svg" data-original="/2024/04/27/picture-compress-api/3.png"></div><h3 id="使用-API-进行转换"><a href="#使用-API-进行转换" class="headerlink" title="使用 API 进行转换"></a>使用 API 进行转换</h3><h4 id="Convertio-1"><a href="#Convertio-1" class="headerlink" title="Convertio"></a>Convertio</h4><p><a href="https://developers.convertio.co/zh/">https://developers.convertio.co/zh/</a></p><p>首先需要注册获得一个 API_KEY。这个过程是免费的。</p><p>这是 API 文档：<a href="https://developers.convertio.co/zh/api/docs/">https://developers.convertio.co/zh/api/docs/</a>，官方给出了一些参数：</p><table class="files-table api-params-table">                            <thead>                            <tr>                                <td style="width:170px">Field</td>                                <td style="width:80px"></td>                                <td style="width:80px">Type</td>                                <td>Description</td>                            </tr>                            </thead>                            <tbody>                                                        <tr class="user-file-row">                                <td class="param-name">apikey</td>                                <td></td>                                <td>String</td>                                <td style="word-break: break-word">Your API Key                                                                                                </td>                            </tr>                                                        <tr class="user-file-row">                                <td class="param-name">input</td>                                <td></td>                                <td>String</td>                                <td style="word-break: break-word">Method of providing the input file.                                <br>Default Value:url                                <br>Allowed Values: url,raw,base64,upload                                </td>                            </tr>                                                        <tr class="user-file-row">                                <td class="param-name">file</td>                                <td></td>                                <td>String</td>                                <td style="word-break: break-word">URL of the input file (if input=url), or file content (if input = raw/base64)                                                                                                </td>                            </tr>                                                        <tr class="user-file-row">                                <td class="param-name">filename</td>                                <td><span class="param-opt">optional</span></td>                                <td>String</td>                                <td style="word-break: break-word">Input filename including extension (file.ext). Required if input = raw/base64                                                                                                </td>                            </tr>                                                        <tr class="user-file-row">                                <td class="param-name">outputformat</td>                                <td></td>                                <td>String</td>                                <td style="word-break: break-word">Output format, to which the file should be converted to.                                                                                                </td>                            </tr>                                                        <tr class="user-file-row">                                <td class="param-name">options</td>                                <td><span class="param-opt">optional</span></td>                                <td>Object</td>                                <td style="word-break: break-word">Conversion options. Now used to define callback URL, enable OCR and setting up its options. <b>You may find available OCR conversion options <a href="#options" style="color: #e41000">here</a> and callback example <a href="#options_callback" style="color: #e41000">here</a>.</b>                                                                                                </td>                            </tr>                                                        </tbody>                        </table><p>不过也像上面所说，它拥有一个免费计划，因此 API 的调用并不是无限的，好在它的限制措施也不多，只有一条：每 24h 转换 25 个文件，其它的限制也没有了，不会像有些产品，指定一堆复杂的政策骗钱。不过具体的我还没试用过，所以暂时没有 demo，平时一般都是线上服务解决问题也够了。</p><p>另外，这家的 API 服务似乎没有一些常用语言的 SDK，这可能会对开发者带来一些麻烦。（只有 PHP 的，所以 PHP 是不是世界上最好的语言呢 233）</p><p><s>不得不说，换个账号大法确实好用，希望这些网站的管理者没有看到我说的这句话。</s></p><h4 id="CloudConvert-1"><a href="#CloudConvert-1" class="headerlink" title="CloudConvert"></a>CloudConvert</h4><p><a href="https://cloudconvert.com/pricing">https://cloudconvert.com/pricing</a></p><p>它也同样需要注册来免费获取一个 key。相比于 Convertio，它的好处是支持了各种语言的 SDK，在开发的时候更加得心应手。不过他的免费额度也只有每天 25 个文件。</p><p>以 node 为例子，它的 SDK 在 Github 给出了比较详细的 demo：<a href="https://github.com/cloudconvert/cloudconvert-node">https://github.com/cloudconvert/cloudconvert-node</a></p><p>它的调用相比于其他的 API 来说，心智相对复杂一些。这可能是为了兼容多种文件的转换格式，因此它提供了 <code>job</code> 的概念。比如说下图就是创建了一种「工作」，其中包括了上传，转换，导出 3 个步骤。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// npm install cloudconvert --save</span><span class="token keyword">const</span> CloudConvert <span class="token operator">=</span>  <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'cloudconvert'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> cloudConvert <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CloudConvert</span><span class="token punctuation">(</span><span class="token string">'api_key'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> importUrl <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'my-file.jpg'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> outputName <span class="token operator">=</span> <span class="token string">'output-file'</span><span class="token punctuation">;</span><span class="token keyword">let</span> job <span class="token operator">=</span> <span class="token keyword">await</span> cloudConvert<span class="token punctuation">.</span>jobs<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>    <span class="token literal-property property">tasks</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token string-property property">'import-my-file'</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>            <span class="token literal-property property">operation</span><span class="token operator">:</span> <span class="token string">'import/url'</span><span class="token punctuation">,</span>            <span class="token literal-property property">url</span><span class="token operator">:</span> importUrl        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token string-property property">'convert-my-file'</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>            <span class="token literal-property property">operation</span><span class="token operator">:</span> <span class="token string">'convert'</span><span class="token punctuation">,</span>            <span class="token literal-property property">input</span><span class="token operator">:</span> <span class="token string">'import-my-file'</span><span class="token punctuation">,</span>            <span class="token literal-property property">output_format</span><span class="token operator">:</span> <span class="token string">'webp'</span><span class="token punctuation">,</span>            <span class="token literal-property property">some_other_option</span><span class="token operator">:</span> <span class="token string">'value'</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token string-property property">'export-my-file'</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>            <span class="token literal-property property">operation</span><span class="token operator">:</span> <span class="token string">'export/url'</span><span class="token punctuation">,</span>            <span class="token literal-property property">input</span><span class="token operator">:</span> outputName        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>CloudConvert 给每个使用了 <code>export/url</code> 的任务都会返回一个公共的，能在互联网访问的 url，我们就可以通过这个 url 来获取到转换后的文件。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">job <span class="token operator">=</span> <span class="token keyword">await</span> cloudConvert<span class="token punctuation">.</span>jobs<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>job<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Wait for job completion</span><span class="token keyword">const</span> file <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>cloudConvert<span class="token punctuation">.</span>jobs<span class="token punctuation">.</span><span class="token function">getExportUrls</span><span class="token punctuation">(</span>job<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">const</span> writeStream <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">createWriteStream</span><span class="token punctuation">(</span><span class="token string">'./out/'</span> <span class="token operator">+</span> file<span class="token punctuation">.</span>filename<span class="token punctuation">)</span><span class="token punctuation">;</span>https<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>file<span class="token punctuation">.</span>url<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    response<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>writeStream<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">await</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    writeStream<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'finish'</span><span class="token punctuation">,</span> resolve<span class="token punctuation">)</span><span class="token punctuation">;</span>    writeStream<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个 SDK 还提供了沙盒环境，使得用户在测试 API 的时候不至于使用掉免费额度。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// Pass `true` to the constructor</span><span class="token keyword">const</span> cloudConvert <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CloudConvert</span><span class="token punctuation">(</span><span class="token string">'api_key'</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>总体使用下来，API 还是最推荐这款，虽然说免费额度一致，相比于 Convertio 使用友好，也可以避免在测试的时候丢失配额。速度也总体上比 Convertio 来的更快。</p><h2 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h2><p>除了格式转换之外，我们还需要考虑图片压缩的问题。一般来说，图片压缩在绝大多数情况下可以取得非常好的效果。毕竟一般图片的生产方没有压缩的意识。</p><p>如果说格式的转换可能有比较固定的范式，那么图片压缩可以说是十分考验压缩算法的水平了。不同的压缩算法，在压缩率、压缩速度、压缩质量上都有着不同的表现。市面上能提供十分有竞争力的压缩能力的厂商属实不多，愿意免费的更是少之又少。除开压缩算法，如果我们正好有让图片大小变小的需求，那么图片的大小优化也肯定会很可观。比如说网站的大图没有必要使用 8k 的大图做展示，4k 就够了。如果不是刻意的保存需求，那么我们往往能创造一个改变图片大小的环境。不过图片大小也是一定会损害图片质量的。</p><p>在这个过程中，我们自然是希望图片的质量不能损失太多。毕竟很多图片一旦失去了高清晰度，就会让显示效果大打折扣。</p><h3 id="系统自带"><a href="#系统自带" class="headerlink" title="系统自带"></a>系统自带</h3><p>MacOS 系统自带图片的压缩功能。Apple 的官方说明中提及了这一点：</p><p><a href="https://support.apple.com/zh-cn/guide/preview/prvw2015/mac">https://support.apple.com/zh-cn/guide/preview/prvw2015/mac</a></p><ol><li>在 Mac 上的“预览” App  中，打开想要更改的文件。</li><li>选取“工具” &gt; “调整大小”，然后选择“重新采样图像”。</li><li>在“分辨率”栏中输入一个较小的值。</li><li>新的大小显示在底部。</li></ol><blockquote><p>【提示】若要同时减小多个图像的文件大小，请在同一个窗口中显示这些图像，并在窗口的边栏中选择它们，然后选取“工具” &gt; “调整大小”。</p></blockquote><p>首先 Apple 的能力确实还是值得信赖的，压缩图片很快。并且在这个过程中，可以选择一些常见的图片大小，系统能力集成，也让这个过程执行的非常丝滑方便。但是缺点也很明显：那就是能选择的尺寸太少了，且最高只支持到 <code>1280*720</code>. 在当前场景下，它确实用处只会越来越小。</p><p>在这个过程中，甚至还能顺带转换下图片的格式，可惜不支持 <code>WebP</code>。如果转换为 <code>png</code> 格式，有的时候甚至图片还会变大…</p><h3 id="imagemin"><a href="#imagemin" class="headerlink" title="imagemin"></a>imagemin</h3><p>作为前端开发，imagemin 自然是我们再熟悉不过的产品之一了。它的最大优势是我们可以集成在 CI&#x2F;CD 环境中。每当我们进行打包的时候，我们可以在打包的过程中直接使用 imagemin 来进行图片压缩。</p><p>Imagemin 是围绕「插件」构建的。插件是用于压缩特定图片格式的 npm 软件包（例如，<code>mozjpeg</code> 会压缩 JPEG）。选择插件时，最重要的考虑因素是它是「有损」还是「无损」。在无损压缩中，不会丢失任何数据。有损压缩会减小文件大小，但代价是可能会降低图片质量。如果插件未提及它是「有损」还是「无损」，您可以通过其 API 来判断：如果您可以指定输出的图片质量，则它是「有损」的。</p><table>    <thead>      <tr>        <th>图片格式</th>        <th>有损插件</th>        <th>无损插件</th>      </tr>    </thead>    <tbody>      <tr>        <td>JPEG</td>        <td>          <a href="https://www.npmjs.com/package/imagemin-mozjpeg">imagemin-mozjpeg</a>        </td>        <td>          <a href="https://www.npmjs.com/package/imagemin-jpegtran">imagemin-jpegtran</a>        </td>      </tr>      <tr>        <td>PNG</td>        <td>          <a href="https://www.npmjs.com/package/imagemin-pngquant">imagemin-pngquant</a>        </td>        <td>          <a href="https://www.npmjs.com/package/imagemin-optipng">imagemin-optipng</a>        </td>      </tr>      <tr>        <td>GIF</td>        <td>          <a href="https://www.npmjs.com/package/imagemin-giflossy">imagemin-giflossy</a>        </td>        <td>          <a href="https://www.npmjs.com/package/imagemin-gifsicle">imagemin-gifsicle</a>        </td>      </tr>      <tr>        <td>SVG</td>        <td>          <a href="https://www.npmjs.com/package/imagemin-svgo">imagemin-svgo</a>        </td>        <td></td>      </tr>      <tr>        <td>WebP</td>        <td>          <a href="https://www.npmjs.com/package/imagemin-webp">imagemin-webp</a>        </td>        <td>          <a href="https://www.npmjs.com/package/imagemin-webp">imagemin-webp</a>        </td>      </tr>    </tbody>  </table><p>在通过跟打包工具集成 imagemin 之后，我们就可以在打包的过程中，使用 imagemin 来进行图片压缩。这里使用 Webpack 为例子：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> ImageminPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'imagemin-webpack-plugin'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>default<span class="token punctuation">;</span><span class="token keyword">const</span> CopyWebpackPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'copy-webpack-plugin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">entry</span><span class="token operator">:</span> <span class="token string">'./index.js'</span><span class="token punctuation">,</span>  <span class="token literal-property property">output</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">filename</span><span class="token operator">:</span> <span class="token string">'bundle.js'</span><span class="token punctuation">,</span>    <span class="token literal-property property">path</span><span class="token operator">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'dist'</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token literal-property property">plugins</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token keyword">new</span> <span class="token class-name">CopyWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">&#123;</span>        <span class="token literal-property property">from</span><span class="token operator">:</span> <span class="token string">'img/**/**'</span><span class="token punctuation">,</span>        <span class="token literal-property property">to</span><span class="token operator">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'dist'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">new</span> <span class="token class-name">ImageminPlugin</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>      <span class="token literal-property property">pngquant</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">&#123;</span> <span class="token literal-property property">quality</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">]</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此代码会告知 Imagemin 使用 Pngquant 插件压缩 PNG。quality 字段使用 min 和 max 值范围来确定压缩级别 - 0 是最低压缩级别，1 是最高压缩级别。如需强制所有图片以 50% 质量压缩，请将 0.5 同时作为最小值和最大值传递。</p><p>假设我们还需要压缩 jpg 文件，那么我们需要添加如下配置：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> imageminMozjpeg <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'imagemin-mozjpeg'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">new</span> <span class="token class-name">ImageminPlugin</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  <span class="token literal-property property">pngquant</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">&#123;</span> <span class="token literal-property property">quality</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">]</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 已有配置，无需新增</span>  <span class="token literal-property property">plugins</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token function">imageminMozjpeg</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> <span class="token literal-property property">quality</span><span class="token operator">:</span> <span class="token number">50</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以说，每种插件的具体用法都不一样，具体得您自己去查阅对应插件的文档。然后我们根据项目的需要，按需进行配置。比如你的项目如果确实只是用了 <code>png</code> 和 <code>jpg</code> 两种图片格式，那么你只需要配置 <code>pngquant</code> 和 <code>mozjpeg</code> 即可。</p><p>我们甚至还可以将 Imagemin 本身用作 Node 脚本。以下代码使用 <code>imagemin-mozjpeg</code> 插件将 JPEG 文件的质量压缩为 50（0 表示最差；100 表示最佳）：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> imagemin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'imagemin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> imageminMozjpeg <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'imagemin-mozjpeg'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token keyword">async</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> files <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">imagemin</span><span class="token punctuation">(</span>      <span class="token punctuation">[</span><span class="token string">'source_dir/*.jpg'</span><span class="token punctuation">,</span> <span class="token string">'another_dir/*.jpg'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span>        <span class="token literal-property property">destination</span><span class="token operator">:</span> <span class="token string">'destination_dir'</span><span class="token punctuation">,</span>        <span class="token literal-property property">plugins</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token function">imageminMozjpeg</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token literal-property property">quality</span><span class="token operator">:</span> <span class="token number">50</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">]</span>      <span class="token punctuation">&#125;</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>files<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="TinyPNG"><a href="#TinyPNG" class="headerlink" title="TinyPNG"></a>TinyPNG</h3><div align="center">  <img src="../../../../loading2.svg" data-original="/2024/04/27/picture-compress-api/6.jpeg"></div><p>在官网的介绍中，他们这么写：TinyPNG 使用智能有损压缩技术将您的 <code>WebP</code>, <code>PNG</code> 和 <code>JPEG</code> 图片的文件大小降低。 通过选择性的减少图片中的颜色，只需要很少的字节数就能保存数据。 对视觉的影响几乎不可见，但是在文件大小上有非常大的差别。</p><p>经过实测，无论是什么环境下，他们的图片损失都很小，但是压缩率非常高。</p><p><a href="https://tinypng.com/">https://tinypng.com/</a> 进入之后直接上传即可，每次最多上传 20 张图片。一般来说足够支持需要顺手支持的场景。</p><h3 id="黑魔法"><a href="#黑魔法" class="headerlink" title="黑魔法"></a>黑魔法</h3><p>偶然在知乎上看到了无限制使用 node 压缩图片的解法，先上 Github 地址：（这个并不是我写的，特此注明下）</p><p><a href="https://github.com/zhanyuzhang/super-tinypng">super-tinypng</a></p><p>知乎原文链接：<a href="https://zhuanlan.zhihu.com/p/152317953">https://zhuanlan.zhihu.com/p/152317953</a></p><p>这里我概括下作者的思路（大部分为作者原文，这里稍微提炼了下）：</p><blockquote><p>网页版的服务，我们仍然可以达到「无限使用」的效果——事实上我们完全不需要在云端保存那 20 张图片，这在不登录的情况下，是一定存在漏洞的。因此我们可以直接尝试使用网页和服务器的接口实现图片的压缩。<br>一般来说，这种免登录就可试用的系统，都是通过用户 IP 来限制用户的操作次数的。目前的 web 架构大多数都是通过 <code>nginx</code> 作为反向代理的，换句话说，客户端并不是直接请求应用服务的，而是通过统一接入层（往往是 <code>nginx</code>） 来转发请求的。而 <code>nginx</code> 恰恰约定了 <code>X-Forwarded-For</code> 请求头告知下游服务用户的 IP。实际上，基本上所有的反向代理服务都实现了这个约定，以确保下游的服务可以感知到经过的反向代理，并从中获取到用户的 IP 地址。<br>那么我们能不能在客户端伪造这个头部，每次上传图片的时候都设置一个随机的 IP 呢？所以就决定尝试一下。结果发现，该方法确实可行！</p></blockquote><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> options <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">method</span><span class="token operator">:</span> <span class="token string">'POST'</span><span class="token punctuation">,</span>  <span class="token literal-property property">hostname</span><span class="token operator">:</span> <span class="token string">'TinyPNG – Compress PNG images while preserving transparency'</span><span class="token punctuation">,</span>  <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">'/web/shrink'</span><span class="token punctuation">,</span>  <span class="token literal-property property">headers</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">rejectUnauthorized</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>    <span class="token string-property property">'Postman-Token'</span><span class="token operator">:</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token string-property property">'Cache-Control'</span><span class="token operator">:</span> <span class="token string">'no-cache'</span><span class="token punctuation">,</span>    <span class="token string-property property">'Content-Type'</span><span class="token operator">:</span> <span class="token string">'application/x-www-form-urlencoded'</span><span class="token punctuation">,</span>    <span class="token string-property property">'User-Agent'</span><span class="token operator">:</span>      <span class="token string">'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36'</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 上传图片的时候加上这两行：</span>options<span class="token punctuation">.</span>headers<span class="token punctuation">[</span><span class="token string">'X-Forwarded-For'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">getRandomIP</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fileUpload</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// console.log('可以压缩：' + file);</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>完整的代码原作者已经在知乎、Github 上开源了，感兴趣的可以自行尝试。</p><p>同时，作者也发布到了 npm 上面。只需要全局安装：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">pnpm</span> i super-tinypng <span class="token parameter variable">-g</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后在你想要压缩图片的目录里面运行 <code>super-tinypng</code> 就能自动压缩图片了，并且不会有数量限制！</p><p>不过 TinyPNG 在未来是完全有可能将这个办法给封杀的，大家能用就早用早享受。</p><h3 id="不受限制的站点"><a href="#不受限制的站点" class="headerlink" title="不受限制的站点"></a>不受限制的站点</h3><p>Free TinyPNG <a href="https://free.tinypng.site/">https://free.tinypng.site/</a></p><p>这个网站和 TinyPNG 网站几乎一样，不同的是它取消了数量限制，和大小限制。图片超过 5MB，是不能被免费 TinyPNG 的网站服务和 API 接受的。但是在这个站点就可以。</p><p>这个网站有宣称自己的算法和 TinyPNG 一致，不过具体有待考证。</p><h3 id="API-服务"><a href="#API-服务" class="headerlink" title="API 服务"></a>API 服务</h3><p>他们家的 API 服务同样也十分慷慨，对每个账户每个月有 500 次的免费调用次数。更惊喜的是，他们对于主流的代码环境都支持。比如针对于 <code>node.js</code> 他们专门开发了易用的 SDK，实际在最简单的环境中，我们仅需4行代码就可以使用 API 进行图片压缩了。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// npm install tinify</span><span class="token keyword">const</span> tinify <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"tinify"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>tinify<span class="token punctuation">.</span>key <span class="token operator">=</span> <span class="token string">"API_KEY"</span><span class="token punctuation">;</span><span class="token keyword">const</span> source <span class="token operator">=</span> tinify<span class="token punctuation">.</span><span class="token function">fromFile</span><span class="token punctuation">(</span>imagePath<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">await</span> source<span class="token punctuation">.</span><span class="token function">toFile</span><span class="token punctuation">(</span>outputPath<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要获取 API_KEY，只需要注册一个账号，然后就能在官网的控制台中获取。</p><div align="center">  <img src="../../../../loading2.svg" data-original="/2024/04/27/picture-compress-api/2.jpeg"></div><p>我们可以在控制台看到我们这个月使用的次数。</p><div align="center">  <img src="../../../../loading2.svg" data-original="/2024/04/27/picture-compress-api/1.png"></div><p>如果说想批量压缩图片，这里有个 demo 供参考使用，可以直接在 node 环境下运行。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> tinify <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"tinify"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>tinify<span class="token punctuation">.</span>key <span class="token operator">=</span> <span class="token string">"API_KEY"</span><span class="token punctuation">;</span><span class="token keyword">const</span> folderPath <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'..'</span><span class="token punctuation">,</span> <span class="token string">'OLD_FOLDER_NAME'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 替换为您在外面一级的文件夹路径</span><span class="token keyword">const</span> folderName <span class="token operator">=</span> <span class="token string">'NEW_FOLDER_NAME'</span><span class="token punctuation">;</span> <span class="token comment">// 新文件夹的名称，会在当前目录生成</span><span class="token keyword">const</span> imageCount <span class="token operator">=</span> <span class="token number">500</span><span class="token punctuation">;</span> <span class="token comment">// 替换为要压缩的图片数量</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">compressImage</span><span class="token punctuation">(</span><span class="token parameter">imagePath<span class="token punctuation">,</span> outputPath</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> source <span class="token operator">=</span> tinify<span class="token punctuation">.</span><span class="token function">fromFile</span><span class="token punctuation">(</span>imagePath<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">await</span> source<span class="token punctuation">.</span><span class="token function">toFile</span><span class="token punctuation">(</span>outputPath<span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">压缩成功：</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>outputPath<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">压缩失败：</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>imagePath<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">compressImagesInFolder</span><span class="token punctuation">(</span><span class="token parameter">folderPath<span class="token punctuation">,</span> count</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> imageFiles <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readdirSync</span><span class="token punctuation">(</span>folderPath<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token parameter">file</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      <span class="token keyword">const</span> extension <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">extname</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> extension <span class="token operator">===</span> <span class="token string">'.png'</span> <span class="token operator">||</span> extension <span class="token operator">===</span> <span class="token string">'.jpg'</span> <span class="token operator">||</span> extension <span class="token operator">===</span> <span class="token string">'.jpeg'</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> selectedImages <span class="token operator">=</span> imageFiles<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> imageFile <span class="token keyword">of</span> selectedImages<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">const</span> imagePath <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>folderPath<span class="token punctuation">,</span> imageFile<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">const</span> compressedImagePath <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> folderName<span class="token punctuation">,</span> imageFile<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 修改输出路径</span>      <span class="token keyword">await</span> <span class="token function">compressImage</span><span class="token punctuation">(</span>imagePath<span class="token punctuation">,</span> compressedImagePath<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 传递输出路径给compressImage函数</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'压缩图片时发生错误：'</span><span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">createOutputFolder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> folderPath <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> folderName<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fs<span class="token punctuation">.</span><span class="token function">existsSync</span><span class="token punctuation">(</span>folderPath<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    fs<span class="token punctuation">.</span><span class="token function">mkdirSync</span><span class="token punctuation">(</span>folderPath<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> folderPath<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">createOutputFolder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">compressImagesInFolder</span><span class="token punctuation">(</span>folderPath<span class="token punctuation">,</span> imageCount<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>图片压缩的不同姿势，希望能帮助到仔细看完这篇文章的你。</p><p>如果让我说一个总结，我认为在当下（2024.4）我使用这些方法的频率是这样的：</p><ol><li>如果是在不改变当前图片格式的情况下，我会优先使用 tinypng 进行压缩。毕竟我们有办法无限白嫖它。</li><li>如果是在项目中使用，那么 imagemin 是我们优先的考量。能集成在 CI&#x2F;CD 自然是开发的最佳实践之一。</li><li>如果是针对于博客项目，或者一些图片服务，imagemin 有可能不支持对应的脚手架，那么就会使用命令行。这种时候我会统一将图片转成 webp，这样子用户的体验是最好的。</li><li>如果是针对于图片需要小幅修改的场景，那么依据需要修改好的范围，我会针对性的使用 Luna Paint 等集成在 VS Code 中的插件服务 &gt; 能云存储的在线服务 &gt; 到 Photoshop 等图片修改工具进行修改。</li><li>除去以上情形无法解决，我会使用本文提到的部分在线服务。</li></ol><h2 id="参考文档-感谢："><a href="#参考文档-感谢：" class="headerlink" title="参考文档 &amp; 感谢："></a>参考文档 &amp; 感谢：</h2><p><a href="https://web.dev/articles/codelab-imagemin-webpack?hl=zh-cn">https://web.dev/articles/codelab-imagemin-webpack?hl=zh-cn</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="技术总结" scheme="https://blog.pengdonglai.com/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="API" scheme="https://blog.pengdonglai.com/tags/API/"/>
    
    <category term="web" scheme="https://blog.pengdonglai.com/tags/web/"/>
    
    <category term="图片" scheme="https://blog.pengdonglai.com/tags/%E5%9B%BE%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>国内二次元图片API汇总保存</title>
    <link href="https://blog.pengdonglai.com/2024/04/14/anime-pictures/"/>
    <id>https://blog.pengdonglai.com/2024/04/14/anime-pictures/</id>
    <published>2024-04-14T11:28:29.000Z</published>
    <updated>2024-06-03T17:04:59.285Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><blockquote><p>本文由「赵苦瓜のBlog~」改编而来，原文地址：<a href="https://blog.jixiaob.cn/?post=93">https://blog.jixiaob.cn/?post=93</a></p></blockquote><p>「国内」包含范围：中国大陆。港澳台会和海外放到另外的一个 Post 中去。</p><p>首先感谢原作者能一下子提供这么多的 API，并且绝大部分质量还是非常不错的，覆盖到的图片应该有十万量级了。本文会根据作者自己的癖好做出修改<s>才不是删去了非二次元OvO</s>。</p><p>发出来之前应该是做了一些补完计划，目前所有的 API，已做好过滤并且附上了图。针对于可能的加载情况做了一些懒加载优化（毕竟图片这么多）。</p><p>后续的计划是，附上一些 API 的说明，之后会对文章进行分类，并逐渐淘汰一些不用了的&#x2F;使用频率低的 API。另外，这些 API 还是国内使用为主，后续应该会补一篇国外的，质量会更好。以及本人秉承着自给自足丰衣足食的原则，二次元<s>摄图</s>应该也会开发（已经有了），并且不是 API 套皮。推销一波自己的 API，图源来自 Jitsu，后面也会有他的 API 分享。然后我也会一直补充这些 API。</p><p><a href="https://moe.starfishdl.site/api/setu/v1">https://moe.starfishdl.site/api/setu/v1</a></p><p>（取消了横屏和竖屏的展示，因为需要花费很多查询次数）</p><p style="text-align:center;"><img src="../../../../loading2.svg" data-original="https://moe.starfishdl.site/api/setu/v1" height="300" alt="点击刷新预览图" title="点击刷新预览图" style="height:300px;" onclick="event.stopPropagation();src=src+'?'+Math.random()*5;"></p><p>希望大家可以找到自己喜欢的二次元美图，也希望大家爱惜好身体！以下为正文：</p><hr><p>记录一些随机图API的地址&#x3D;w&#x3D;，点击图片即可刷新预览图。</p><p>关于图片保存：</p><p>如果在这个页面刷到一些好看的图片想保存的话，<s>直接右键另存为或者下载是保存不到你看到的图片的，而是另一张随机图</s>有可能是可以保存原图的。而且如果复制粘贴到 word 这种会二次从互联网上下载的软件里也会是另一张随机图。</p><p>可以复制图片然后粘贴到画图之类的不会从互联网上二次下载的软件中然后保存。</p><h2 id="1-次元API-举个栗子随机二次元图床API"><a href="#1-次元API-举个栗子随机二次元图床API" class="headerlink" title="1 次元API-举个栗子随机二次元图床API"></a>1 次元API-举个栗子随机二次元图床API</h2><p><a href="https://t.mwm.moe/">https://t.mwm.moe/</a></p><p>此外还有萌图、风景图、白底图、自适应屏幕、原神、AI图和随机二次元头像的接口，点击上方链接即可查看</p><p>另外在接口后面加上&#x2F;img.txt即可查看图片链接列表，非常方便。</p><p>PC端（横屏）：</p><p><a href="https://t.mwm.moe/pc">https://t.mwm.moe/pc</a></p><p style="text-align:center;"><img src="../../../../loading2.svg" data-original="https://t.mwm.moe/pc" height="300" alt="点击刷新预览图" title="点击刷新预览图" style="height:300px;" onclick="event.stopPropagation();src=src+'?'+Math.random()*5;"></p><p>移动端（竖屏）：</p><p><a href="https://t.mwm.moe/mp">https://t.mwm.moe/mp</a></p><p style="text-align:center;"><span style="font-size:16px;"><img src="../../../../loading2.svg" data-original="https://t.mwm.moe/mp" height="300" alt="点击刷新预览图" title="点击刷新预览图" style="height:300px;" onclick="event.stopPropagation();src=src+'?'+Math.random() * 5;"><br></span></p><p>二次元风景：</p><p><a href="https://t.mwm.moe/fj">https://t.mwm.moe/fj</a></p><p style="text-align:center;"><span style="font-size:16px;"><img src="../../../../loading2.svg" data-original="https://t.mwm.moe/fj" height="300" alt="点击刷新预览图" title="点击刷新预览图" style="height:300px;" onclick="event.stopPropagation();src=src+'?'+Math.random() * 5;"><br></span></p><h2 id="2-98情缘API"><a href="#2-98情缘API" class="headerlink" title="2 98情缘API"></a>2 98情缘API</h2><p>随机壁纸</p><p><a href="http://www.98qy.com/sjbz/api.php">http://www.98qy.com/sjbz/api.php</a></p><p style="text-align:center;"><span style="font-size:16px;"><img src="../../../../loading2.svg" data-original="http://www.98qy.com/sjbz/api.php" height="300" alt="点击刷新预览图" title="点击刷新预览图" style="height:300px;" onclick="event.stopPropagation();src=src+'?'+Math.random()*5;"><br></span></p><h2 id="3-Lolicon-API"><a href="#3-Lolicon-API" class="headerlink" title="3 Lolicon API"></a>3 Lolicon API</h2><p>神代绮凛大佬是神！</p><p>这个不是直接返回图片，而是一个json信息，图片的链接在json里面。</p><p>同时这个也可以加tag、r18等参数来缩小图片查找范围，很好用&#x3D;w&#x3D;</p><p>可以拿来做QQ群的涩图机器人</p><p><a href="https://api.lolicon.app/setu/v2">https://api.lolicon.app/setu/v2</a></p><h2 id="4-NyanCatdaの小站"><a href="#4-NyanCatdaの小站" class="headerlink" title="4 NyanCatdaの小站"></a>4 NyanCatdaの小站</h2><p>这个也是返回json，不过现在好像不能用了qwq</p><p><a href="https://api.nyan.xyz/httpapi/sexphoto/">https://api.nyan.xyz/httpapi/sexphoto/</a></p><p>跟站长确认过了，上面的接口停用了，不过有另一个新的涩图接口</p><p><a href="https://sex.nyan.xyz/">https://sex.nyan.xyz/</a></p><p>这个也是可以返回json，也可以直接返回图片</p><p>可以筛选r18，指定作者pid，指定返回数量，指定tag关键字等等</p><p><a href="https://sex.nyan.xyz/api/v2/img">https://sex.nyan.xyz/api/v2/img</a></p><p style="text-align:center;"><span style="font-size:16px;"><img src="../../../../loading2.svg" data-original="https://sex.nyan.xyz/api/v2/img" height="300" alt="点击刷新预览图" title="点击刷新预览图" style="height:300px;" onclick="event.stopPropagation();src=src+'?'+Math.random()*5;"><br></span></p><h2 id="5-超级小兔的随机图"><a href="#5-超级小兔的随机图" class="headerlink" title="5 超级小兔的随机图"></a>5 超级小兔的随机图</h2><p>随机图</p><p><a href="https://imgapi.xl0408.top/index.php">https://imgapi.xl0408.top/index.php</a></p><p style="text-align:center;"><span style="font-size:16px;"><img src="../../../../loading2.svg" data-original="https://imgapi.xl0408.top/index.php" height="300" alt="点击刷新预览图" title="点击刷新预览图" style="height:300px;" onclick="event.stopPropagation();src=src+'?'+Math.random()*5;"><br></span></p><h2 id="6-EEE-DOG随机图API"><a href="#6-EEE-DOG随机图API" class="headerlink" title="6 EEE.DOG随机图API"></a>6 EEE.DOG随机图API</h2><p>呓喵酱的随机图</p><p>这个也可以加参数，指定筛选的尺寸，是否显示r18，是否显示为网页等，同时也有必应和头像的随机图接口</p><p><a href="https://api.yimian.xyz/img">https://api.yimian.xyz/img</a></p><p style="text-align:center;"><img src="../../../../loading2.svg" data-original="https://api.yimian.xyz/img" height="300" alt="点击刷新预览图" title="点击刷新预览图" style="height:300px;" onclick="event.stopPropagation();src=src+'?'+Math.random() * 5;"></p><h2 id="7-岁月小筑随机背景API"><a href="#7-岁月小筑随机背景API" class="headerlink" title="7 岁月小筑随机背景API"></a>7 岁月小筑随机背景API</h2><p><a href="https://img.xjh.me/random_img.php">https://img.xjh.me/random_img.php</a></p><p>这个好像返回的不是纯图片，需要用iframe引用</p><p>多了一个百度统计的东西emmm</p><p>感觉有点因噎废食了</p><p>由于返回的不是纯图片感觉用处不是很广泛（</p><p> 找到一个调用岁月小筑但是是直接返回图片的：</p><p><a href="https://cloud.qqshabi.cn/api/images/api.php">https://cloud.qqshabi.cn/api/images/api.php</a></p><p><a href="https://cloud.qqshabi.cn/apidetail/33.html">https://cloud.qqshabi.cn/apidetail/33.html</a></p><h2 id="8-樱花随机二次元图片API"><a href="#8-樱花随机二次元图片API" class="headerlink" title="8 樱花随机二次元图片API"></a>8 樱花随机二次元图片API</h2><p>好像用樱花的这个的人也挺多的</p><p><a href="https://www.dmoe.cc/random.php">https://www.dmoe.cc/random.php</a></p><p style="text-align:center;"><span style="font-size:16px;"><img src="../../../../loading2.svg" data-original="https://www.dmoe.cc/random.php" height="300" alt="点击刷新预览图" title="点击刷新预览图" style="height:300px;" onclick="event.stopPropagation();src=src+'?'+Math.random()*5;"> <br></span></p><h2 id="9-韩小韩API接口站"><a href="#9-韩小韩API接口站" class="headerlink" title="9 韩小韩API接口站"></a>9 韩小韩API接口站</h2><p>韩小韩API除了这两个图片还有好多其他的，比如风景图、电脑壁纸、桌面壁纸、随机头像等</p><p>不过感觉他用的图片CDN访问速度有点慢（</p><p>随机二次元图片API接口</p><p><a href="https://api.vvhan.com/api/wallpaper/acg">https://api.vvhan.com/api/wallpaper/acg</a></p><p style="text-align:center;"><img src="../../../../loading2.svg" data-original="https://api.vvhan.com/api/wallpaper/acg" height="300" alt="点击刷新预览图" title="点击刷新预览图" style="height:300px;" onclick="event.stopPropagation();src=src+'?'+Math.random()*5;"></p><h2 id="10-缙哥哥的博客"><a href="#10-缙哥哥的博客" class="headerlink" title="10 缙哥哥的博客"></a>10 缙哥哥的博客</h2><p>原神随机图</p><p>收录了数千张原神图片，还有特别大的那种（一张二三十兆）</p><p><a href="https://api.dujin.org/pic/yuanshen/">https://api.dujin.org/pic/yuanshen/</a></p><p style="text-align:center;"><img src="../../../../loading2.svg" data-original="https://api.dujin.org/pic/yuanshen/" height="300" alt="点击刷新预览图" title="点击刷新预览图" style="height:300px;" onclick="event.stopPropagation();src=src+'?'+Math.random()*5;"></p><h2 id="11-PAULZZH-东方Project随机图片API"><a href="#11-PAULZZH-东方Project随机图片API" class="headerlink" title="11 PAULZZH 东方Project随机图片API"></a>11 PAULZZH 东方Project随机图片API</h2><p>东方随机图，全都是东方的图，图库总量也很大</p><p><a href="https://blog.paulzzh.com/archives/50.html">https://blog.paulzzh.com/archives/50.html</a></p><p><a href="https://img.paulzzh.com/touhou/random">https://img.paulzzh.com/touhou/random</a></p><p style="text-align:center;"><img src="../../../../loading2.svg" data-original="https://img.paulzzh.com/touhou/random" height="300" alt="点击刷新预览图" title="点击刷新预览图" style="height:300px;" onclick="event.stopPropagation();src=src+'?'+Math.random()*5;"></p><h2 id="12-随机二次元图片API"><a href="#12-随机二次元图片API" class="headerlink" title="12 随机二次元图片API"></a>12 随机二次元图片API</h2><p>作者似乎没有给自己站点起名字，那就发下链接，这位大大的图说实在的质量也非常不错：<a href="https://api.sretna.cn/">https://api.sretna.cn/</a></p><p>API: <a href="https://api.sretna.cn/comic.php">https://api.sretna.cn/comic.php</a></p><p>电脑端随机二次元（2560*1440）：</p><p style="text-align:center;"><img src="../../../../loading2.svg" data-original="https://api.sretna.cn/layout/pc.php" height="300" alt="点击刷新预览图" title="点击刷新预览图" style="height:300px;" onclick="event.stopPropagation();src=src+'?'+Math.random()*5;"></p><p>手机端随机二次元（1440*2560）：</p><p style="text-align:center;"><img src="../../../../loading2.svg" data-original="https://api.sretna.cn/layout/pe.php" height="300" alt="点击刷新预览图" title="点击刷新预览图" style="height:300px;" onclick="event.stopPropagation();src=src+'?'+Math.random()*5;"></p><p>动漫头像随机二次元（1000*1000）：</p><p style="text-align:center;"><img src="../../../../loading2.svg" data-original="https://api.sretna.cn/layout/ar.php" height="300" alt="点击刷新预览图" title="点击刷新预览图" style="height:300px;" onclick="event.stopPropagation();src=src+'?'+Math.random()*5;"></p><h2 id="13-保罗API"><a href="#13-保罗API" class="headerlink" title="13 保罗API"></a>13 保罗API</h2><p>白底二次元图片，适合当作纯色桌面背景之类的</p><p><a href="https://api.paugram.com/wallpaper/">https://api.paugram.com/wallpaper/</a></p><p style="text-align:center;"><img src="../../../../loading2.svg" data-original="https://api.paugram.com/wallpaper/" height="300" alt="点击刷新预览图" title="点击刷新预览图" style="height:300px;" onclick="event.stopPropagation();src=src+'?'+Math.random()*5;"></p><h2 id="14-小歪API"><a href="#14-小歪API" class="headerlink" title="14 小歪API"></a>14 小歪API</h2><p>小歪除了这个动漫的随机图，还有表情包少女Menhera-chan和三次元风景壁纸的接口</p><p><a href="https://api.aixiaowai.cn/api/api.php">https://api.aixiaowai.cn/api/api.php</a></p><p>二次元动漫</p><p style="text-align:center;"><img src="../../../../loading2.svg" data-original="https://api.aixiaowai.cn/api/api.php" height="300" alt="点击刷新预览图" title="点击刷新预览图" style="height:300px;" onclick="event.stopPropagation();src=src+'?'+Math.random()*5;"></p><p>mc酱动漫</p><p style="text-align:center;"><img src="../../../../loading2.svg" data-original="https://api.aixiaowai.cn/mcapi/mcapi.php" height="300" alt="点击刷新预览图" title="点击刷新预览图" style="height:300px;" onclick="event.stopPropagation();src=src+'?'+Math.random()*5;"></p><h2 id="15-樱道随机图片API接口"><a href="#15-樱道随机图片API接口" class="headerlink" title="15 樱道随机图片API接口"></a>15 樱道随机图片API接口</h2><p>樱道这里有非常多的系列可以选择，包含二次元与三次元</p><p>二次元动漫综合系列、赛马娘系列、东京食尸鬼系列、Fate系列、为美好世界献上祝福系列、某科学的超电磁炮系列、原神系列、我的世界系列、神奇宝贝系列、龙珠系列、罪恶王冠系列、鬼灭之刃系列、火影忍者系列、海贼王系列、进击的巨人系列、从零开始的异世界生活系列、刀剑神域系列、钢之炼金术师系列、妖精的尾巴系列、缘之空系列、东方project系列、猫娘系列、风景系列、物语系列、少女前线系列、明日方舟系列、重装战姬系列、P站系列、CG系列、守望先锋系列、王者荣耀系列、少女写真系列、橘里橘气系列<br>这些系列里面还有细分，超级精细</p><p>这里以二次元动漫综合系列的动漫综合1为例：</p><p><a href="https://api.r10086.com/%E6%A8%B1%E9%81%93%E9%9A%8F%E6%9C%BA%E5%9B%BE%E7%89%87api%E6%8E%A5%E5%8F%A3.php?%E5%9B%BE%E7%89%87%E7%B3%BB%E5%88%97=%E5%8A%A8%E6%BC%AB%E7%BB%BC%E5%90%881">https://api.r10086.com/%E6%A8%B1%E9%81%93%E9%9A%8F%E6%9C%BA%E5%9B%BE%E7%89%87api%E6%8E%A5%E5%8F%A3.php?%E5%9B%BE%E7%89%87%E7%B3%BB%E5%88%97=%E5%8A%A8%E6%BC%AB%E7%BB%BC%E5%90%881</a></p><p style="text-align:center;"><img src="../../../../loading2.svg" data-original="https://api.r10086.com/%E6%A8%B1%E9%81%93%E9%9A%8F%E6%9C%BA%E5%9B%BE%E7%89%87api%E6%8E%A5%E5%8F%A3.php?%E5%9B%BE%E7%89%87%E7%B3%BB%E5%88%97=%E5%8A%A8%E6%BC%AB%E7%BB%BC%E5%90%881" height="300" alt="点击刷新预览图" title="点击刷新预览图" style="height:300px;" onclick="event.stopPropagation();src=src+'&amp;'+Math.random()*5;"></p><p>还有少女写真系列里面的COS系列：</p><p><a href="https://api.r10086.com/%E6%A8%B1%E9%81%93%E9%9A%8F%E6%9C%BA%E5%9B%BE%E7%89%87api%E6%8E%A5%E5%8F%A3.php?%E5%9B%BE%E7%89%87%E7%B3%BB%E5%88%97=%E5%B0%91%E5%A5%B3%E5%86%99%E7%9C%9F1S">https://api.r10086.com/%E6%A8%B1%E9%81%93%E9%9A%8F%E6%9C%BA%E5%9B%BE%E7%89%87api%E6%8E%A5%E5%8F%A3.php?%E5%9B%BE%E7%89%87%E7%B3%BB%E5%88%97=%E5%B0%91%E5%A5%B3%E5%86%99%E7%9C%9F1S</a></p><p style="text-align:center;"><img src="../../../../loading2.svg" data-original="https://api.r10086.com/%E6%A8%B1%E9%81%93%E9%9A%8F%E6%9C%BA%E5%9B%BE%E7%89%87api%E6%8E%A5%E5%8F%A3.php?%E5%9B%BE%E7%89%87%E7%B3%BB%E5%88%97=%E5%B0%91%E5%A5%B3%E5%86%99%E7%9C%9F1" height="300" alt="点击刷新预览图" title="点击刷新预览图" style="height:300px;" onclick="event.stopPropagation();src=src+'&amp;'+Math.random()*5;""></p><h2 id="16-搏天api"><a href="#16-搏天api" class="headerlink" title="16 搏天api"></a>16 搏天api</h2><p>这里面还有其他的接口，比如随机动漫头像之类的</p><p><a href="https://api.btstu.cn/sjbz/api.php">https://api.btstu.cn/sjbz/api.php</a></p><p>三次元图片</p><p>名称 必填 类型 说明<br>  method 否 string 输出壁纸端[mobile|pc|zsy]默认为pc<br>  lx 否 string 选择输出分类[meizi|dongman|fengjing|suiji]，为空随机输出<br>  format 否 string 输出壁纸格式[json|images]默认为images</p><p style="text-align:center;"><span style="font-size:16px;"><img src="../../../../loading2.svg" data-original="https://api.btstu.cn/sjbz/api.php?lx=dongman&format=images" height="300" alt="点击刷新预览图" title="点击刷新预览图" style="height:300px;" onclick="event.stopPropagation();src=src+'?'+Math.random()*5;"></span></p><h2 id="17-小C的每日漫图介绍页的随机图"><a href="#17-小C的每日漫图介绍页的随机图" class="headerlink" title="17 小C的每日漫图介绍页的随机图"></a>17 小C的每日漫图介绍页的随机图</h2><p><a href="https://pixiv.xiaoc.cn/v1/img/random?vertical=1">https://pixiv.xiaoc.cn/v1/img/random?vertical=1</a></p><p>返回json格式，包含图片标题、pid、作者和图片链接，vertical&#x3D;1表示只有竖图</p><h2 id="18-Jitsuの随机涩图API-docs-anosu-top"><a href="#18-Jitsuの随机涩图API-docs-anosu-top" class="headerlink" title="18 Jitsuの随机涩图API(docs.anosu.top)"></a>18 Jitsuの随机涩图API(docs.anosu.top)</h2><p>具体使用就看文档吧，可以返回json，可以直接返回图片，可以加tag标签、r18等参数等等。</p><p><a href="https://docs.anosu.top/intro/params.html">请求参数 | API Docs (anosu.top)</a></p><p style="text-align:center;"><img src="../../../../loading2.svg" data-original="https://image.anosu.top/pixiv/direct" height="300" alt="点击刷新预览图" title="点击刷新预览图" align onclick="event.stopPropagation();src=src+'?'+Math.random()*5;" style="height:300px;"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">收录来自群里传的梗：可以看到只不过是把r18参数设为了<span class="token number">1</span>然后标签做了对应以下链接<span class="token number">100</span><span class="token operator">%</span>出现涩图请用浏览器打开链接新年第一天大家祝大家冲个痛快https<span class="token punctuation">:</span><span class="token operator">//</span>image<span class="token punctuation">.</span>anosu<span class="token punctuation">.</span>top<span class="token operator">/</span>pixiv<span class="token operator">/</span>direct?r18<span class="token operator">=</span><span class="token number">1</span><span class="token operator">&amp;</span>keyword<span class="token operator">=</span>azurlane碧蓝航线涩图https<span class="token punctuation">:</span><span class="token operator">//</span>image<span class="token punctuation">.</span>anosu<span class="token punctuation">.</span>top<span class="token operator">/</span>pixiv<span class="token operator">/</span>direct?r18<span class="token operator">=</span><span class="token number">1</span><span class="token operator">&amp;</span>keyword<span class="token operator">=</span>bluearchive碧蓝档案涩图https<span class="token punctuation">:</span><span class="token operator">//</span>image<span class="token punctuation">.</span>anosu<span class="token punctuation">.</span>top<span class="token operator">/</span>pixiv<span class="token operator">/</span>direct?r18<span class="token operator">=</span><span class="token number">1</span><span class="token operator">&amp;</span>keyword<span class="token operator">=</span>genshinimpact原神涩图https<span class="token punctuation">:</span><span class="token operator">//</span>image<span class="token punctuation">.</span>anosu<span class="token punctuation">.</span>top<span class="token operator">/</span>pixiv<span class="token operator">/</span>direct?r18<span class="token operator">=</span><span class="token number">1</span><span class="token operator">&amp;</span>keyword<span class="token operator">=</span>arknights明日方舟涩图https<span class="token punctuation">:</span><span class="token operator">//</span>image<span class="token punctuation">.</span>anosu<span class="token punctuation">.</span>top<span class="token operator">/</span>pixiv<span class="token operator">/</span>direct?r18<span class="token operator">=</span><span class="token number">1</span><span class="token operator">&amp;</span>keyword<span class="token operator">=</span>honkai崩坏三涩图https<span class="token punctuation">:</span><span class="token operator">//</span>image<span class="token punctuation">.</span>anosu<span class="token punctuation">.</span>top<span class="token operator">/</span>pixiv<span class="token operator">/</span>direct?r18<span class="token operator">=</span><span class="token number">1</span><span class="token operator">&amp;</span>keyword<span class="token operator">=</span>fate命运涩图https<span class="token punctuation">:</span><span class="token operator">//</span>image<span class="token punctuation">.</span>anosu<span class="token punctuation">.</span>top<span class="token operator">/</span>pixiv<span class="token operator">/</span>direct?r18<span class="token operator">=</span><span class="token number">1</span><span class="token operator">&amp;</span>keyword<span class="token operator">=</span>frontline少女前线涩图https<span class="token punctuation">:</span><span class="token operator">//</span>image<span class="token punctuation">.</span>anosu<span class="token punctuation">.</span>top<span class="token operator">/</span>pixiv<span class="token operator">/</span>direct?r18<span class="token operator">=</span><span class="token number">1</span><span class="token operator">&amp;</span>keyword<span class="token operator">=</span>princess公主连接涩图https<span class="token punctuation">:</span><span class="token operator">//</span>image<span class="token punctuation">.</span>anosu<span class="token punctuation">.</span>top<span class="token operator">/</span>pixiv<span class="token operator">/</span>direct?r18<span class="token operator">=</span><span class="token number">1</span><span class="token operator">&amp;</span>keyword<span class="token operator">=</span>idolmaster偶像大师涩图https<span class="token punctuation">:</span><span class="token operator">//</span>image<span class="token punctuation">.</span>anosu<span class="token punctuation">.</span>top<span class="token operator">/</span>pixiv<span class="token operator">/</span>direct?r18<span class="token operator">=</span><span class="token number">1</span><span class="token operator">&amp;</span>keyword<span class="token operator">=</span>hololive皮套人涩图https<span class="token punctuation">:</span><span class="token operator">//</span>image<span class="token punctuation">.</span>anosu<span class="token punctuation">.</span>top<span class="token operator">/</span>pixiv<span class="token operator">/</span>direct?r18<span class="token operator">=</span><span class="token number">1</span><span class="token operator">&amp;</span>keyword<span class="token operator">=</span>touhou东方涩图<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="19-Jitsuの随机涩图API-img-jitsu-top"><a href="#19-Jitsuの随机涩图API-img-jitsu-top" class="headerlink" title="19 Jitsuの随机涩图API(img.jitsu.top)"></a>19 Jitsuの随机涩图API(img.jitsu.top)</h2><p><a href="https://blog.jitsu.top/archives/3/" style="white-space:normal;"><span style="font-size:16px;">随机涩图API——随机返回我老婆（ - 迷途之旅 (jitsu.top)</span></a></p><p>这个也可以指定参数，调整图片大小，选择图片类型等，详见使用文档</p><p><a href="https://img.jitsu.top/#/instruction/?id=%e8%b0%83%e7%94%a8%e7%a4%ba%e4%be%8b"><span style="font-size:16px;">使用说明 - 随机漫图API 使用文档 (jitsu.top)</span></a></p><p><a href="https://moe.jitsu.top/api">https://moe.jitsu.top/api</a></p><p><a href="https://moe.jitsu.top/r18">https://moe.jitsu.top/r18</a></p><p style="text-align:center;"><img src="../../../../loading2.svg" data-original="https://moe.jitsu.top/api" height="300" alt="点击刷新预览图" title="点击刷新预览图" align onclick="event.stopPropagation();src=src+'?'+Math.random()*5;" style="height:300px;"></p><h2 id="20-零七生活API"><a href="#20-零七生活API" class="headerlink" title="20 零七生活API"></a>20 零七生活API</h2><p><a href="https://api.oick.cn/random/api.php">https://api.oick.cn/random/api.php</a></p><p>可以加参数?type&#x3D;pc或者?type&#x3D;pe，表示电脑图或者手机图（横图和竖图）</p><p style="text-align:center;"><img src="../../../../loading2.svg" data-original="https://api.oick.cn/random/api.php" height="300" alt="点击刷新预览图" title="点击刷新预览图" align onclick="event.stopPropagation();src=src+'?'+Math.random()*5;" style="height:300px;"></p><h2 id="21-桑帛云API"><a href="#21-桑帛云API" class="headerlink" title="21 桑帛云API"></a>21 桑帛云API</h2><p>这个里面也有一大堆接口，好像大部分都是用在qq群里根据别人的头像生成表情包的，也有一些随机图随机视频啥的，详情可以点进去看。</p><p>随机二次元动漫图</p><p><a href="https://api.lolimi.cn/API/dmt/api.php?type=image">https://api.lolimi.cn/API/dmt/api.php?type=image</a></p><p style="text-align:center;"><img src="../../../../loading2.svg" data-original="https://api.lolimi.cn/API/dmt/api.php?type=image" height="300" alt="点击刷新预览图" title="点击刷新预览图" onclick="event.stopPropagation();src=src+'&amp;'+Math.random()*5;" style="height:300px;"></p><p>随机原神壁纸，返回来的是 text</p><p><a href="https://api.lolimi.cn/API/yuan/?type=text">https://api.lolimi.cn/API/yuan/?type=text</a></p><p>点击刷新预览图</p><h2 id="22-星河随机图片API"><a href="#22-星河随机图片API" class="headerlink" title="22 星河随机图片API"></a>22 星河随机图片API</h2><p>最近有更新的API</p><p>图片都是webp格式，速度很快</p><p>使用说明：随机图片API | ASXE &#x3D; 月落星沉</p><p>旧API：</p><p><a href="https://api.lovezyc.club/random.php">https://api.lovezyc.club/random.php</a></p><p>新API：</p><p><a href="https://api.asxe.vip/random.php">https://api.asxe.vip/random.php</a></p><p style="text-align:center;"><img src="../../../../loading2.svg" data-original="https://api.asxe.vip/random.php" height="300" alt="点击刷新预览图" title="点击刷新预览图" align onclick="event.stopPropagation();src=src+'?'+Math.random()*5;" style="height:300px;"></p><p>二次元风景：</p><p><a href="https://api.asxe.vip/scenery.php">https://api.asxe.vip/scenery.php</a></p><p style="text-align:center;"><img src="../../../../loading2.svg" data-original="https://api.asxe.vip/scenery.php" height="300" alt="点击刷新预览图" title="点击刷新预览图" align onclick="event.stopPropagation();src=src+'?'+Math.random()*5;" style="height:300px;"></p><h2 id="23-LoliAPI-LoliAPI"><a href="#23-LoliAPI-LoliAPI" class="headerlink" title="23 LoliAPI | LoliAPI"></a>23 LoliAPI | LoliAPI</h2><p>有自适应二次元图片，手机端和PC端，随机二次元头像等。</p><p>二次元自适应：</p><p><a href="https://www.loliapi.com/acg/">https://www.loliapi.com/acg/</a></p><p style="text-align:center;"><img src="../../../../loading2.svg" data-original="https://www.loliapi.com/acg/" height="300" alt="点击刷新预览图" title="点击刷新预览图" align onclick="event.stopPropagation();src=src+'?'+Math.random()*5;" style="height:300px;"></p><p>二次元头像：</p><p><a href="https://www.loliapi.com/acg/pp/">https://www.loliapi.com/acg/pp/</a></p><p style="text-align:center;"><img src="../../../../loading2.svg" data-original="https://www.loliapi.com/acg/pp/" height="300" alt="点击刷新预览图" title="点击刷新预览图" align onclick="event.stopPropagation();src=src+'?'+Math.random()*5;" style="height:300px;"></p><h2 id="24-魅影随机图片API"><a href="#24-魅影随机图片API" class="headerlink" title="24 魅影随机图片API"></a>24 魅影随机图片API</h2><p>有二次元图，三次元图，风景图和必应图，可以通过category选择</p><p>type可以选择直接302跳转图片地址或者返回xml或者返回json等。</p><p>二次元自适应随机图</p><p><a href="https://tuapi.eees.cc/api.php?category=dongman&amp;type=302">https://tuapi.eees.cc/api.php?category=dongman&amp;type=302</a></p><p style="text-align:center;"><img src="../../../../loading2.svg" data-original="https://tuapi.eees.cc/api.php?category=dongman&type=302" height="300" alt="点击刷新预览图" title="点击刷新预览图" align onclick="event.stopPropagation();src=src+'?'+Math.random()*5;" style="height:300px;"></p><h2 id="25-赫萝随机图片API"><a href="#25-赫萝随机图片API" class="headerlink" title="25 赫萝随机图片API"></a>25 赫萝随机图片API</h2><p><a href="https://api.horosama.com/random.php">https://api.horosama.com/random.php</a></p><p>可以指定type（pc横图，mobile竖图，profile头像），format（jpg&#x2F;json）和分辨率resolution （1080p，2k，4k，small（头像适用））</p><p style="text-align:center;"><img src="../../../../loading2.svg" data-original="https://api.horosama.com/random.php" height="300" alt="点击刷新预览图" title="点击刷新预览图" align onclick="event.stopPropagation();src=src+'?'+Math.random()*5;" style="height:300px;"></p><h2 id="26-如诗的API接口"><a href="#26-如诗的API接口" class="headerlink" title="26 如诗的API接口"></a>26 如诗的API接口</h2><p>除了这个pixiv壁纸外还有单独的PC、手机、表情包少女 Menhera-chan、必应壁纸和三次元风景壁纸的接口等等</p><p><a href="https://api.likepoems.com/img/pc">https://api.likepoems.com/img/pc</a></p><p style="text-align:center;"><img src="../../../../loading2.svg" data-original="https://api.likepoems.com/img/pc" height="300" alt="点击刷新预览图" title="点击刷新预览图" align onclick="event.stopPropagation();src=src+'?'+Math.random()*5;" style="height:300px;"></p><h2 id="27-小小API"><a href="#27-小小API" class="headerlink" title="27 小小API"></a>27 小小API</h2><p>二次元（type是pc或者wap表示横图或者竖图）：</p><p><a href="https://v2.api-m.com/api/randomAcgPic?type=pc&amp;return=302">https://v2.api-m.com/api/randomAcgPic?type=pc&amp;return=302</a></p><p style="text-align:center;"><img src="../../../../loading2.svg" data-original="https://v2.api-m.com/api/randomAcgPic?type=pc&return=302" height="300" alt="点击刷新预览图" title="点击刷新预览图" align onclick="event.stopPropagation();src=src+'?'+Math.random()*5;" style="height:300px;"></p><h2 id="28-素颜API"><a href="#28-素颜API" class="headerlink" title="28 素颜API"></a>28 素颜API</h2><p>里面有原神、甘城猫猫（猫羽雫）、jk、黑丝、随机二次元等随机图，还有其他可用的api接口。</p><p>原神随机图</p><p><a href="https://api.suyanw.cn/api/ys">https://api.suyanw.cn/api/ys</a></p><p style="text-align:center;"><img src="../../../../loading2.svg" data-original="https://api.suyanw.cn/api/ys" height="300" alt="点击刷新预览图" title="点击刷新预览图" align onclick="event.stopPropagation();src=src+'?'+Math.random()*5;" style="height:300px;"></p><p>甘城猫猫随机图</p><p><a href="https://api.suyanw.cn/api/mao">https://api.suyanw.cn/api/mao</a></p><p style="text-align:center;"><img src="../../../../loading2.svg" data-original="https://api.suyanw.cn/api/mao" height="300" alt="点击刷新预览图" title="点击刷新预览图" align onclick="event.stopPropagation();src=src+'?'+Math.random()*5;" style="height:300px;"></p><p>自适应二次元随机图</p><p><a href="https://api.suyanw.cn/api/comic/api.php">https://api.suyanw.cn/api/comic/api.php</a></p><p style="text-align:center;"><img src="../../../../loading2.svg" data-original="https://api.suyanw.cn/api/comic/api.php" height="300" alt="点击刷新预览图" title="点击刷新预览图" align onclick="event.stopPropagation();src=src+'?'+Math.random()*5;" style="height:300px;"></p><h2 id="29-无铭API"><a href="#29-无铭API" class="headerlink" title="29 无铭API"></a>29 无铭API</h2><p>里面也收录了很多API，不过大部分需要免费注册之后获取key之后才能使用。</p><p>随机动漫壁纸（需要注册后免费获取key）</p><p><a href="https://jkapi.com/api/dm_wallpaper">https://jkapi.com/api/dm_wallpaper</a></p><h2 id="30-御坂API"><a href="#30-御坂API" class="headerlink" title="30 御坂API"></a>30 御坂API</h2><p>随机p站插画（支持r18与非r18）<br><a href="https://ybapi.cn/API/pixiv.php">https://ybapi.cn/API/pixiv.php</a><br>参数1<br>r18&#x3D;非必填，填true为输出r18，不填则输出非r18<br>参数2<br>type&#x3D;非必填，填text输出文本格式，不填则输出json格式</p><p>新随机二次元PC横图</p><p>请求地址：<br><a href="https://ybapi.cn/API/dmt.php">https://ybapi.cn/API/dmt.php</a></p><p>随机二次元动漫图片（输出pc端横图）<br>请求地址：<br><a href="https://ybapi.cn/API/pc_acgimg.php">https://ybapi.cn/API/pc_acgimg.php</a></p><p>随机二次元动漫图片（输出pe端竖图）<br>请求地址：<br><a href="https://ybapi.cn/API/pe_acgimg.php">https://ybapi.cn/API/pe_acgimg.php</a></p><h2 id="31-夏沫博客美图古风二次元接口"><a href="#31-夏沫博客美图古风二次元接口" class="headerlink" title="31 夏沫博客美图古风二次元接口"></a>31 夏沫博客美图古风二次元接口</h2><p>作者开了防盗链，不过应该还能给qq机器人之类的用一用</p><p>接口文档：</p><p><a href="https://cdn.seovx.com/">https://cdn.seovx.com/</a></p><p><a href="https://www.seovx.com/73.html">https://www.seovx.com/73.html</a></p><p>防盗链白名单域名授权申请：</p><p><a href="https://www.seovx.com/1480.html">https://www.seovx.com/1480.html</a></p><p>二次元：</p><p><a href="https://cdn.seovx.com/d/">https://cdn.seovx.com/d/</a></p><p><a href="https://cdn.seovx.com/d/?mom=302">https://cdn.seovx.com/d/?mom=302</a></p><p>古风：</p><p><a href="https://cdn.seovx.com/ha/">https://cdn.seovx.com/ha/</a></p><p><a href="https://cdn.seovx.com/ha/?mom=302">https://cdn.seovx.com/ha/?mom=302</a></p><h2 id="32-糖豆子API"><a href="#32-糖豆子API" class="headerlink" title="32 糖豆子API"></a>32 糖豆子API</h2><p>他家的都是返回文本，所以只能访问后再查看了。</p><p>糖豆子api <a href="http://api.tangdouz.com/">http://api.tangdouz.com/</a><br>随机二次元<a href="http://api.tangdouz.com/sjdmbz.php">http://api.tangdouz.com/sjdmbz.php</a><br>随机兽耳<a href="http://api.tangdouz.com/sjer.php">http://api.tangdouz.com/sjer.php</a><br>随机二次元竖图<a href="http://api.tangdouz.com/abz/dm.php">http://api.tangdouz.com/abz/dm.php</a><br>随机美腿<a href="http://api.tangdouz.com/mt.php">http://api.tangdouz.com/mt.php</a><br>美女图<a href="http://api.tangdouz.com/mn.php">http://api.tangdouz.com/mn.php</a></p><h2 id="33-希速云API"><a href="#33-希速云API" class="headerlink" title="33 希速云API"></a>33 希速云API</h2><p>他家现在需要 APIKey，所以暂不支持显示预览。</p><p>随机二次元</p><p><a href="https://api.sdbj.top/api/ecy?apiKey=%E4%BD%A0%E7%9A%84apikey">https://api.sdbj.top/api/ecy?apiKey=你的apikey</a></p><h2 id="34-遇见API"><a href="#34-遇见API" class="headerlink" title="34 遇见API"></a>34 遇见API</h2><p><a href="https://api.yujn.cn/">https://api.yujn.cn/</a></p><p>随机动漫图：</p><p style="text-align:center;"><img src="../../../../loading2.svg" data-original="http://api.yujn.cn/api/ecy.php" height="300" alt="点击刷新预览图" title="点击刷新预览图" align onclick="event.stopPropagation();src=src+'?'+Math.random()*5;" style="height:300px;"></p><p>高质量acg图片：</p><p style="text-align:center;"><img src="../../../../loading2.svg" data-original="http://api.yujn.cn/api/ACG.php" height="300" alt="点击刷新预览图" title="点击刷新预览图" align onclick="event.stopPropagation();src=src+'?'+Math.random()*5;" style="height:300px;"></p><p>原神图：</p><p style="text-align:center;"><img src="../../../../loading2.svg" data-original="http://api.yujn.cn/api/ys.php" height="300" alt="点击刷新预览图" title="点击刷新预览图" align onclick="event.stopPropagation();src=src+'?'+Math.random()*5;" style="height:300px;"></p><h2 id="35-最要学习API"><a href="#35-最要学习API" class="headerlink" title="35 最要学习API"></a>35 最要学习API</h2><p><a href="https://api.zylearning.top/">https://api.zylearning.top/</a></p><p>动漫壁纸：</p><p style="text-align:center;"><img src="../../../../loading2.svg" data-original="http://api.zylearning.top/api/wallpaper?lx=dm" height="300" alt="点击刷新预览图" title="点击刷新预览图" align onclick="event.stopPropagation();src=src+'?'+Math.random()*5;" style="height:300px;"></p><h2 id="36-TenAPI"><a href="#36-TenAPI" class="headerlink" title="36 TenAPI"></a>36 TenAPI</h2><p><a href="https://tenapi.cn/">https://tenapi.cn/</a></p><p>随机动漫图 <a href="https://tenapi.cn/v2/acg">https://tenapi.cn/v2/acg</a></p><p>请求示例一：</p><p style="text-align:center;"><img src="../../../../loading2.svg" data-original="https://api.qicaiyun.top/sjbz/api.php?lx=dongman" height="300" alt="点击刷新预览图" title="点击刷新预览图" align onclick="event.stopPropagation();src=src+'?'+Math.random()*5;" style="height:300px;"></p><p>请求示例二：</p><p style="text-align:center;"><img src="../../../../loading2.svg" data-original="https://api.qicaiyun.top/sjbz/api.php?method=mobile&lx=suiji" height="300" alt="点击刷新预览图" title="点击刷新预览图" align onclick="event.stopPropagation();src=src+'?'+Math.random()*5;" style="height:300px;"></p><p>请求参数说明：<br>名称    必填    类型    说明<br>method         string    mobiel(手机端),pc(电脑端)<br>lx         string    dongman(动漫壁纸),meizi(美女壁纸),fengjing(风景壁纸)suiji(动漫和美女随机)</p><h2 id="37-ALAPI"><a href="#37-ALAPI" class="headerlink" title="37 ALAPI"></a>37 ALAPI</h2><p><a href="https://www.alapi.cn/">https://www.alapi.cn/</a></p><p>随机动漫图</p><p style="text-align:center;"><img src="../../../../loading2.svg" data-original="https://v2.alapi.cn/api/acg?token=KA6k5H7oBNZavgEJ" height="300" alt="点击刷新预览图" title="点击刷新预览图" align onclick="event.stopPropagation();src=src+'?'+Math.random()*5;" style="height:300px;"></p><h2 id="38-玖逸API"><a href="#38-玖逸API" class="headerlink" title="38 玖逸API"></a>38 玖逸API</h2><p><a href="http://api.idcnow.cn/">http://api.idcnow.cn/</a></p><p>这个貌似是点进去后下载<br>二次元随机背景图：<a href="http://api.idcnow.cn/api/ecyimg.php">http://api.idcnow.cn/api/ecyimg.php</a><br>新浪反代：<a href="https://cdn.cdnjson.com/%E5%90%8E%E9%9D%A2%E5%8A%A0%E6%96%B0%E6%B5%AA%E5%9B%BE%E7%89%87%E7%9A%84%E5%9F%9F%E5%90%8D%EF%BC%8C%E4%B8%8D%E5%B8%A6https://">https://cdn.cdnjson.com/后面加新浪图片的域名，不带https://</a></p><h2 id="39-故梦API"><a href="#39-故梦API" class="headerlink" title="39 故梦API"></a>39 故梦API</h2><p><a href="https://api.gumengya.com/">https://api.gumengya.com</a></p><p>随机二次元壁纸</p><p style="text-align:center;"><img src="../../../../loading2.svg" data-original="https://api.gumengya.com/Api/DmImg?format=image" height="300" alt="点击刷新预览图" title="点击刷新预览图" align onclick="event.stopPropagation();src=src+'?'+Math.random()*5;" style="height:300px;"></p><h2 id="40-殇白API"><a href="#40-殇白API" class="headerlink" title="40 殇白API"></a>40 殇白API</h2><p><a href="http://api.caonmtx.cn/">http://api.caonmtx.cn/</a></p><p>随机动漫图片</p><p style="text-align:center;"><img src="../../../../loading2.svg" data-original="http://api.caonmtx.cn/api/dongman.php" height="300" alt="点击刷新预览图" title="点击刷新预览图" align onclick="event.stopPropagation();src=src+'?'+Math.random()*5;" style="height:300px;"></p><p>写在最后：如果你也有好的图片API，欢迎联系博主反馈！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="真正的生产力" scheme="https://blog.pengdonglai.com/categories/%E7%9C%9F%E6%AD%A3%E7%9A%84%E7%94%9F%E4%BA%A7%E5%8A%9B/"/>
    
    
    <category term="二次元图片" scheme="https://blog.pengdonglai.com/tags/%E4%BA%8C%E6%AC%A1%E5%85%83%E5%9B%BE%E7%89%87/"/>
    
    <category term="API" scheme="https://blog.pengdonglai.com/tags/API/"/>
    
  </entry>
  
  <entry>
    <title>日语动词练习——N5上</title>
    <link href="https://blog.pengdonglai.com/2024/04/05/japanese-words-1/"/>
    <id>https://blog.pengdonglai.com/2024/04/05/japanese-words-1/</id>
    <published>2024-04-05T08:49:18.000Z</published>
    <updated>2024-09-22T09:18:57.152Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://japanese-beta.vercel.app/words/verb/words.css"><!-- <link rel="stylesheet" type="text/css" href="./words.css"> -->写在前面：<p>本博客的主人在这段时间内学日语，这里会列举一些日语动词以便于帮助记忆，并且可以提供一些打字练习。</p><h2 id="变化规则"><a href="#变化规则" class="headerlink" title="变化规则"></a>变化规则</h2><h3 id="ます形"><a href="#ます形" class="headerlink" title="ます形"></a>ます形</h3><p>①五段动词：将结尾假名变成它同行的前一个假名后+ます</p><p>例：行く～行きます 買う～買います</p><p>②一段动词：去る＋ます</p><p>例：食べる～食べます 起きる～起きます</p><p>③カ变动词：来（く）る～来（き）ます</p><p>④サ变动词：する～します</p><p>例：勉強する～勉強します</p><p>特殊五段动词：帰る～帰ります 知る～知ります</p><p>入る～入ります 要る～要ります</p><p>切る～切ります 走る～走ります</p><h3 id="ない形"><a href="#ない形" class="headerlink" title="ない形"></a>ない形</h3><p>①五段动词：将结尾假名变成它同行的あ段上的假名后+ない。</p><p>例：行く→行かない 買う→買わない</p><p>②一段动词：去る+ない</p><p>例：食べる→食べない 起きる→起きない</p><p>③カ变动词：来る→来（こ）ない</p><p>④サ变动词：する→しない</p><p>例：勉強する→勉強しない</p><p>特殊五段动词：帰る→帰らない 知る→知らない</p><p>其它的以此类推，将る变成ら+ない</p><h3 id="て形"><a href="#て形" class="headerlink" title="て形"></a>て形</h3><p>（1）五段动词：</p><p>①く→いて ぐ→いで</p><p>例：書く→書いて 脱ぐ→脱いで</p><p>②う、つ、る为结尾的，去掉う、つ、る＋って</p><p>例：買う→買って 立つ→立って 終わる→終わって</p><p>③む、ぬ、ぶ为结尾的去掉+む、ぬ、ぶ＋んで</p><p>例：飲む→飲んで 死ぬ→死んで 飛ぶ→飛んで</p><p>④以す为结尾的す→して</p><p>例：話す→話して</p><p>（2）一段动词：去る+て</p><p>例：食べる→食べて 起きる→起きて</p><p>（3）カ变动词：来る→来（き）て</p><p>（4）サ变动词：する→して</p><p>例：勉強する→勉強して</p><p>例外：行く→行って 帰る→帰って 知る→知って</p><h3 id="た型"><a href="#た型" class="headerlink" title="た型"></a>た型</h3><p>同て型，将て变为た即可。</p><h3 id="可能形"><a href="#可能形" class="headerlink" title="可能形"></a>可能形</h3><p>①五段动词：将结尾假名变成它同行的下一个假名后+る。</p><p>例：行く→行ける 買う→買える</p><p>②一段动词：去る+られる。</p><p>例：食べる→食べられる 起きる→起きられる</p><p>③カ变动词：来る→来（こ）られる</p><p>④サ变动词：する→できる</p><p>例：勉強する→勉強できる</p><h3 id="假定形"><a href="#假定形" class="headerlink" title="假定形"></a>假定形</h3><p>①五段动词：将结尾假名变成它同行的下一个假名后+ば</p><p>例：行く→行けば 買う→買えば</p><p>②一段动词：去る+れば</p><p>例：食べる→食べれば 起きる→起きれば</p><p>③カ变动词：来る→来（く）れば</p><p>④サ变动词：する→すれば</p><p>例：散歩する→散歩すれば</p><p>⑤形容词：去い+ければ</p><p>例：安い→安ければ おいしい→おいしければ</p><p>⑥形容动词：去だ+なら</p><p>例：暇だ→暇なら 簡単だ→簡単なら</p><p>名词：名词直接+なら</p><p>例：日本人→日本人なら</p><h3 id="意向形"><a href="#意向形" class="headerlink" title="意向形"></a>意向形</h3><p>①五段动词：将结尾假名变成它同行的最后一个假名后+う</p><p>例：行く→行こう 買う→買おう</p><p>②一段动词：去る+よう</p><p>例：食べる→食べよう 起きる→起きよう</p><p>③カ变动词：来る→来（こ）よう</p><p>④サ变动词： する→しよう</p><p>例：散歩する→散歩しよう</p><h3 id="命令形"><a href="#命令形" class="headerlink" title="命令形"></a>命令形</h3><p>①五段动词：将结尾假名变成它同行的下一个假名即可.</p><p>例：行く→行け 買う→買え</p><p>②一段动词：去る+ろ</p><p>例：起きる→起きろ 食べる→食べろ</p><p>③カ变动词：来る→来（こ）い</p><p>④サ变动词：する→しろ</p><p>例：勉強する→勉強しろ</p><h3 id="禁止形"><a href="#禁止形" class="headerlink" title="禁止形"></a>禁止形</h3><p>所有词的字典形（原形、基本形）+な</p><p>例：行く→行くな 起きる→起きるな 来る→来（く）るな 勉強する→勉強するな</p><h3 id="被动形"><a href="#被动形" class="headerlink" title="被动形"></a>被动形</h3><p>①五段动词：将结尾假名变成它所在行的あ段上假名后+れる</p><p>例：踏む→踏まれる 呼ぶ→呼ばれる</p><p>②一段动词：去る+られる</p><p>例：褒める→褒められる 食べる→食べられる</p><p>③カ变动词： 来る→来（こ）られる</p><p>④サ变动词：する→される</p><p>例：発明する→発明される</p><h3 id="使役形"><a href="#使役形" class="headerlink" title="使役形"></a>使役形</h3><p>①五段动词：将结尾假名变成它所在行的あ段上假名后+せる。</p><p>例：行く→行かせる 飲む→飲ませる</p><p>②一段动词：去る+させる</p><p>例：食べる→食べさせる 起きる→起きさせる</p><p>③カ变动词：来る→来（こ）させる</p><p>④サ变动词： する→させる</p><p>例：勉強する→勉強させる</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>本篇介绍 N5 他动词。具体来说，可以通过本篇内容去对动词本身记忆，以及它的变形，进行刷题练习，达到记忆的效果。接下来是关于练习的说明：</p><ul><li>这里点击按钮你要学习的词性，点击后展开，再点击关闭</li></ul><div class="flex-row-box"><button class="btn-small waves-effect waves-light" onclick="hideALine(event, 'chinese')">隐藏中文</button><button class="btn-small waves-effect waves-light" onclick="hideALine(event, 'jisyo')">隐藏字典型</button><button class="btn-small waves-effect waves-light" onclick="hideALine(event, 'masu')">隐藏ます型</button><button class="btn-small waves-effect waves-light" onclick="hideALine(event, 'te')">展开て型</button><button class="btn-small waves-effect waves-light" onclick="hideALine(event, 'nai')">展开ない型</button><button class="btn-small waves-effect waves-light" onclick="hideALine(event, 'ta')">展开た型</button><button class="btn-small waves-effect waves-light" onclick="hideALine(event, 'meirei')">展开命令型</button><button class="btn-small waves-effect waves-light" onclick="hideALine(event, 'ishi')">展开意志型</button><button class="btn-small waves-effect waves-light" onclick="hideALine(event, 'ba')">展开ば型</button><button class="btn-small waves-effect waves-light" onclick="hideALine(event, 'kanou')">展开可能型</button><button class="btn-small waves-effect waves-light" onclick="hideALine(event, 'ukemi')">展开被动型</button><button class="btn-small waves-effect waves-light" onclick="hideALine(event, 'shieki')">展开使役型</button></div><ul><li>这里点击测试按钮，可以测试一下自己是否能正确打出单词，会以选择的词性为判断正确答案</li></ul><div class="flex-row-box"><button class="btn-small waves-effect waves-light" onclick="changeHeimuStatus('chinese')">测试中文</button><button class="btn-small waves-effect waves-light" onclick="changeHeimuStatus('jisyo')">测试字典型</button><button class="btn-small waves-effect waves-light" onclick="changeHeimuStatus('masu')">测试ます型</button><button class="btn-small waves-effect waves-light" onclick="changeHeimuStatus('te')">测试て型</button><button class="btn-small waves-effect waves-light" onclick="changeHeimuStatus('nai')">测试ない型</button><button class="btn-small waves-effect waves-light" onclick="changeHeimuStatus('ta')">测试た型</button><button class="btn-small waves-effect waves-light" onclick="changeHeimuStatus('meirei')">测试命令型</button><button class="btn-small waves-effect waves-light" onclick="changeHeimuStatus('ishi')">测试意志型</button><button class="btn-small waves-effect waves-light" onclick="changeHeimuStatus('ba')">测试ば型</button><button class="btn-small waves-effect waves-light" onclick="changeHeimuStatus('kanou')">测试可能型</button><button class="btn-small waves-effect waves-light" onclick="changeHeimuStatus('ukemi')">测试被动型</button><button class="btn-small waves-effect waves-light" onclick="changeHeimuStatus('shieki')">测试使役型</button></div><div class="test-mode">当前测试模式：无</div><div class="japanese-words"></div><script src="https://cdn.jsdelivr.net/npm/kuroshiro@1.1.0/dist/kuroshiro.min.js"></script><script src="https://cdn.jsdelivr.net/npm/kuroshiro-analyzer-kuromoji@1.1.0/dist/kuroshiro-analyzer-kuromoji.min.js"></script><script src="https://japanese-beta.vercel.app/words/verb/words.js"></script><!-- <script src="./words.js"></script> --><script>  process('n5t');</script><div align="center">  <img src="../../../../loading2.svg" data-original="/2024/04/05/japanese-words-1/1.webp"></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="日语学习" scheme="https://blog.pengdonglai.com/categories/%E6%97%A5%E8%AF%AD%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="日本語" scheme="https://blog.pengdonglai.com/tags/%E6%97%A5%E6%9C%AC%E8%AA%9E/"/>
    
    <category term="动词" scheme="https://blog.pengdonglai.com/tags/%E5%8A%A8%E8%AF%8D/"/>
    
    <category term="自动化测试" scheme="https://blog.pengdonglai.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>N4 日语部分语法点归总</title>
    <link href="https://blog.pengdonglai.com/2024/02/09/japanese-grammar-1/"/>
    <id>https://blog.pengdonglai.com/2024/02/09/japanese-grammar-1/</id>
    <published>2024-02-09T04:18:41.000Z</published>
    <updated>2024-09-22T09:18:57.150Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>本文会不定期打补丁。本文引用了部分公开于互联网的信息，若部分内容对您的著作权等权利造成了侵犯，请及时联系我，我会核实后及时删除这部分内容。</p></blockquote><p>我们一般说 N4N5 两个级别，是日语的初级级别。这个级别相对来说学习的语法比较简单，单词也很多都是在日常当中出现的比较多的。这其中，N5 的考试标准是学完新标准日本语初级上册，N4 的考试标准是学完新标准日本语上下册，比 N5 多了一本书。N5 需要学完一本书，词汇量大概在 1200 左右。</p><p>作为参考，官方对 N4 给出了这样的定义：</p><p>读：能够阅读和理解由基本词汇及汉字所组成的讲述日常生活中最熟悉话题的文章。<br>听：能够大致听懂语速稍慢的日常会话。</p><p>听的部分，后面会和之前英语一样，整理几篇学习的资料。不过，这个方面应该各位喜欢二次元的同好如果抱着对二次元的热爱，从学习的角度出发去一边训练听力，一边追求爱好，那进步应该会更加潜移默化一些。</p><p>在笔者看来，如果把初级语法定义为「稍微会一点」日语的门槛，这个门槛进入之后，对于日语的理解对于完全的小白来说，会有个完全不一样的认知。也拥有了所谓自学的能力。初级的语法中，相对比较难的部分，就放在了 N4。因此从 N4 开始，我会对所有的语法进行总结，从而让我自己能对知识进行快速定位。</p><h2 id="第一类：名词类"><a href="#第一类：名词类" class="headerlink" title="第一类：名词类"></a>第一类：名词类</h2><h3 id="规律汇总"><a href="#规律汇总" class="headerlink" title="规律汇总"></a>规律汇总</h3><h4 id="名词：N-二类形容词：A2"><a href="#名词：N-二类形容词：A2" class="headerlink" title="名词：N &#x2F; 二类形容词：A2"></a>名词：N &#x2F; 二类形容词：A2</h4><p>N＋の＋N・A2＋な＋N</p><p>Nではない＋N・A2ではない＋N</p><p>Nだった＋N・A2だった＋N</p><p>Nではなかった＋N・A2ではなかった＋N</p><h4 id="一类形容词：A1"><a href="#一类形容词：A1" class="headerlink" title="一类形容词：A1"></a>一类形容词：A1</h4><p>A1い＋N</p><p>A1くない＋N</p><p>A1かった＋N</p><p>A1くなかった＋N</p><h4 id="动词：する"><a href="#动词：する" class="headerlink" title="动词：する"></a>动词：する</h4><p>动词普通型+N</p><p>する＋N</p><p>しない＋N</p><p>した＋N</p><p>しなかった＋N</p><h3 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h3><h4 id="つもり、予定"><a href="#つもり、予定" class="headerlink" title="つもり、予定"></a>つもり、予定</h4><p>〜つもり：打算</p><p>留学のつもり。打算留学。</p><p>タバコを吸わないつもり。不打算抽烟。</p><p>〜予定 计划（比つもり正式,有具体的安排）</p><p>一週間滞在の予定です。计划逗留一周。</p><p>出張する予定。计划出差。</p><h4 id="はず"><a href="#はず" class="headerlink" title="はず"></a>はず</h4><p>〜はず：照理说应该 客观推断</p><p>行くはず、行かないはず、綺麗なはず、忙しいはず</p><p>留守のはず</p><p>その単語は先週勉強したはずですが、忘れてしまいました。那个单词应该上周学过的，但现在却忘了。</p><h4 id="ほうがいい、たらどうですか"><a href="#ほうがいい、たらどうですか" class="headerlink" title="ほうがいい、たらどうですか"></a>ほうがいい、たらどうですか</h4><p>均表示某种「提议」。</p><p>〜ほうがいい：我建议你还是…的好</p><p>タバコは止めたほうがいいです。我建议你香烟还是别抽的好</p><p>飲まないほうがいいです。 我建议你还是不要吃的好</p><p>注意这个意思和后面的〜たらどうですか意思是差不多的。这个相比于〜たらどうですか更为委婉。</p><p>〜たらどうですか：「…那样做怎么样」，表示提议或劝诱。这种意思下，どうですか是可以省略的内容，尤其是在口语中。</p><p>吉田君、パーティーには出席しないって。吉田说他不来参加宴会了。</p><p>もう一度誘ってみたら。你再邀请他一次吧。</p><h4 id="とおりに"><a href="#とおりに" class="headerlink" title="とおりに"></a>とおりに</h4><p>〜とおりに〜　按照、照着</p><p>彼が言ったとおりに、やってください。请照着他说的做</p><p>見たとおりに、話してください。请把你看见的说出来</p><p>説明書のとおりに、組み立てました。按说明书进行了组装</p><h4 id="あとで"><a href="#あとで" class="headerlink" title="あとで"></a>あとで</h4><p>〜あとで：之后</p><p>ご飯を食べたあとで散歩します。吃饭之后散步。</p><p>食事のあとで、散歩します。吃饭之后散步。</p><h4 id="ように、ような"><a href="#ように、ような" class="headerlink" title="ように、ような"></a>ように、ような</h4><p>ように有多重意思。注意不要和よう搞混了。</p><ol><li>Ａ（非意志Vる／Vない）+ように：为了（〜ようになる、〜ようにする）。前面跟的动词不能是「意志动词」。</li></ol><p>家が買えるように、貯金します。为了买房而存钱。</p><blockquote><p>意志动词：只要动词无法以「たい、ましょう、ください、てもいいです、なければなりません、禁止形」等方式表现时就是「非意志动词」。</p></blockquote><blockquote><p>接續「ために」時，前面是放「意志動詞」或「名詞」，因此形成以下這種句型：「Ａ（意志Vる／名詞の）＋ために＋Ｂます」。</p></blockquote><ol start="2"><li>Ａのように〜：表示比喻，跟…一样。&#x3D; ような</li></ol><p>数学の先生は鬼婆のように怖いです。数学老师像鬼婆婆一样可怕。</p><ol start="3"><li>V原／Vない＋ようになりました：表示能力变化。</li></ol><p>生のものも食べ慣れるようになりました。可以吃生的东西了（以前吃不了生的东西、以前没有的东西现在变得有了）</p><ol start="4"><li>V原／Vない＋ようにしています：表示受到影响习惯的或持续努力的动作。</li></ol><p>毎日運動して、何でも食べるようにしています。我每天运动，这让我什么都吃。（表示有一个持续性的的动作，表示习惯的或持续努力的动作）</p><ol start="5"><li>V原／Vない＋ようにする：表示将某行为设置为目标并且努力去做到。</li></ol><p>仕事内容と経歴を整理して、すぐに答えられるようにした。整理工作内容与经历，以便于能马上就回答问题。</p><ol start="6"><li>V原／Vない+ようにしてください：比较客气的叮嘱对方。</li></ol><p>遅刻しないようにしてください。请不要迟到哦！</p><ol start="7"><li>V原／Vない+ように：表示希望。</li></ol><p>后多接「祈る、願う、望む、祈念する」等表示期望的动词。但是也可以不接，直接放在结尾。</p><p>皆さんが日本語能力試験に合格できますように。希望大家的日语能力测验都能合格。</p><p>早く回復するよう祈っています。祝你早日康复。</p><h4 id="ために"><a href="#ために" class="headerlink" title="ために"></a>ために</h4><p>〜ために：为了。和おうに其中一个用法是一样的。</p><p>日本語を勉強するために。为了学习日语。</p><p>人は何のために生きているのだろう？人是为什么而活的呢？</p><h4 id="のは、のを、のが"><a href="#のは、のを、のが" class="headerlink" title="のは、のを、のが"></a>のは、のを、のが</h4><p>〜のは、のを、のが就是动词的名词化</p><p>テニスをするのは面白い　打网球很有趣</p><p>歩くのが速い　走路很快</p><p>バナナを買うのを忘れた　忘了买香蕉</p><h4 id="途中で"><a href="#途中で" class="headerlink" title="途中で"></a>途中で</h4><p>〜途中で　~的路上</p><p>学校へ行く途中で 去学校的路上</p><p>ジョギングの途中で  跑步的路上</p><h4 id="ところ・ばかり"><a href="#ところ・ばかり" class="headerlink" title="ところ・ばかり"></a>ところ・ばかり</h4><p>〜ところ 正要（强调瞬间完成的事情）</p><p>これから大阪へ行くところです。我这就去大阪</p><p>〜ばかり：た形＋ばかり 表示刚刚（相比ところ时间拉的更长一些，只要说话者觉得时间短就行）</p><p>先週会社に入ったばかりですから、何もわかりません。我上周刚进公司，啥都不懂</p><p>ばかり还有总是…、都是…、一味…的意思。具体表示什么意思得看接续：</p><p>N＋ばかり：表示「都是」的意思。</p><p>ここ数日、雨ばかりね。这几天一直在下雨呢。</p><p>て形＋ばかりいる／Nばかり～ている：一直，总是（大概率表示负面意思）</p><p>食べてばかりいると、太りますよ。如果一直吃，就会发胖哦。</p><p>彼はいつも嘘ばかりついているから、信用されていない。因为他总是在撒谎，所以不被信任。</p><h4 id="場合は"><a href="#場合は" class="headerlink" title="場合は"></a>場合は</h4><p>〜場合は  在~~的时候 (各类词的接续)</p><p>雨の場合は　在下雨的时候</p><p>必要な場合は　在需要的时候</p><p>調子が悪い場合は　状态不好的时候</p><p>遅れた場合は　迟到了的时候</p><p>なければならない場合は　不得已的时候</p><h4 id="まま"><a href="#まま" class="headerlink" title="まま"></a>まま</h4><p>意思：保持原样</p><p>昨日は電気をつけたまま寝てしまった。昨天我开着灯睡着了。</p><p>これは生のままでも食べられますか？这个可以生吃吗？</p><h4 id="ことがある、ことになる、ことにする"><a href="#ことがある、ことになる、ことにする" class="headerlink" title="ことがある、ことになる、ことにする"></a>ことがある、ことになる、ことにする</h4><p>ことがある、ことになる、ことにする前面均接动词终止形。</p><p>ことになる、ことにする的区别是「是否为自己强烈的意志做决定」。</p><p>ことがある：有时也会</p><p>私は会議中でも、寝てしまうことがある。我在开会时，偶尔也会不小心睡着。</p><p>ことになる：尽管不是自己决定的，委婉地表达自己将要做某事</p><p>多数決の結果、次の生徒会長は僕がすることになった。根据多数票的结果，我将成为下一任学生会长。</p><p>ことにする：表达自己决定将要做某事。</p><p>ダイエットのために、お菓子をやめることにします。为了减肥，我决定戒掉甜食。</p><h2 id="第二类：动词变形类"><a href="#第二类：动词变形类" class="headerlink" title="第二类：动词变形类"></a>第二类：动词变形类</h2><h3 id="可能型"><a href="#可能型" class="headerlink" title="可能型"></a>可能型</h3><p>表示能够进行某种动作。与“〜ことができます”意义相同。</p><p>一类动词：う段 ⇒  え段 ＋ る (基本形的最后一个音变成相应的“え”段上的音，再加“る”)</p><p>二类动词：る ⇒ られる (基本形的“る”变成“られる”)</p><p>三类动词：来る ⇒ 来られる、する ⇒ できる</p><table align="center" border="1" cellpadding="1" cellspacing="1" style="width:573px;"><caption>   <strong><span>动词可能形式变化规则</span></strong>  </caption><tbody><tr><td style="width:78px;"><strong>类形</strong></td><td style="width:122px;"><strong>基本形</strong></td><td style="width:171px;"><strong>可能形式(基本形)</strong></td><td style="width:199px;"><strong>可能形式(ます形)</strong></td></tr><tr><td colspan="1" rowspan="2" style="width:78px;">一类动词</td><td style="width:122px;">書く (かく)</td><td style="width:171px;">書ける(かける)</td><td style="width:199px;">書けます(かけます)</td></tr><tr><td style="width:122px;">読む (よむ)</td><td style="width:171px;">読める(読める)</td><td style="width:199px;">読めます(よめます)</td></tr><tr><td colspan="1" rowspan="2" style="width:78px;">二类动词</td><td style="width:122px;">食べる (たべる)</td><td style="width:171px;">食べられる (たべられる)</td><td style="width:199px;">食べられます(たべられます)</td></tr><tr><td style="width:122px;">見る (みる)</td><td style="width:171px;"> <p>見られる (みられる)</p> </td><td style="width:199px;">見られます(みられます)</td></tr><tr><td colspan="1" rowspan="2" style="width:78px;">三类动词</td><td style="width:122px;">来る (くる)</td><td style="width:171px;">来られる(こられる)</td><td style="width:199px;"> <p>来られます(こられます)</p> </td></tr><tr><td style="width:122px;">する</td><td style="width:171px;">できる</td><td style="width:199px;">できます</td></tr></tbody></table><h3 id="命令型"><a href="#命令型" class="headerlink" title="命令型"></a>命令型</h3><p>说话人对听话人下达命令的表达形式。</p><p>一类动词：う段 ⇒  え段 (基本形的最后一个音变成相应的“え”段上的音)</p><p>二类动词：る ⇒ ろ (基本形的“る”变成“ろ”)  ★  “くれる”的命令形是例外，为“くれ”。</p><p>三类动词：来る ⇒ 来い、する ⇒ しろ</p><table align="center" border="1" cellpadding="1" cellspacing="1" style="width:500px;"><caption>   <strong><span>动词命令形变化规则</span></strong>  </caption><tbody><tr><td><strong>类形</strong></td><td><strong>基本形</strong></td><td><strong>命令形</strong></td></tr><tr><td colspan="1" rowspan="2" style="width:144px;">一类动词</td><td style="width:143px;">書く (かく)</td><td style="width:241px;">書け (かけ)</td></tr><tr><td style="width:143px;">読む (よむ)</td><td style="width:241px;">読め (よめ)</td></tr><tr><td colspan="1" rowspan="3" style="width:144px;">二类动词</td><td style="width:143px;">食べる (たべる)</td><td style="width:241px;">食べろ (たべろ)</td></tr><tr><td style="width:143px;">見る (みる)</td><td style="width:241px;">見ろ (みろ)</td></tr><tr><td style="width:143px;"><span><strong>くれる</strong></span></td><td style="width:241px;"><span><strong>くれ</strong></span></td></tr><tr><td colspan="1" rowspan="2" style="width:144px;">三类动词</td><td style="width:143px;">来る (くる)</td><td style="width:241px;">来い (こい)</td></tr><tr><td style="width:143px;">する</td><td style="width:241px;">しろ</td></tr></tbody></table><h3 id="意志型"><a href="#意志型" class="headerlink" title="意志型"></a>意志型</h3><p>说话人当场表示自己的决心、意志。</p><p>一类动词：う段 ⇒  お段 ＋ う(基本形的最后一个音变成相应的“お”段上的长音)</p><p>二类动词：る ⇒ よう (基本形的“る”变成“よう”)</p><p>三类动词：来る ⇒ 来よう、する ⇒ しよう</p><table align="center" border="1" cellpadding="1" cellspacing="1" style="width:500px;"><caption>   <strong><span>动词意志形变化规则</span></strong>  </caption><tbody><tr><td><strong>类形</strong></td><td style="width:154px;"><strong>基本形</strong></td><td style="width:207px;"><strong>意志形</strong></td></tr><tr><td colspan="1" rowspan="2" style="width:144px;">一类动词</td><td style="width:154px;">書く (かく)</td><td style="width:207px;">書こう (かこう)</td></tr><tr><td style="width:154px;">読む (よむ)</td><td style="width:207px;">読もう (よもう)</td></tr><tr><td colspan="1" rowspan="2" style="width:144px;">二类动词</td><td style="width:154px;">食べる (たべる)</td><td style="width:207px;">食べよう (たべよう)</td></tr><tr><td style="width:154px;">見る (みる)</td><td style="width:207px;">見よう (みよう)</td></tr><tr><td colspan="1" rowspan="2" style="width:144px;">三类动词</td><td style="width:154px;">来る (くる)</td><td style="width:207px;">来よう (こよう)</td></tr><tr><td style="width:154px;">する</td><td style="width:207px;">しよう</td></tr></tbody></table><h3 id="ば形、假定型"><a href="#ば形、假定型" class="headerlink" title="ば形、假定型"></a>ば形、假定型</h3><p>表示假定条件时(如果…)。ば形有“动词ば形”和“一类形容词ば形”。</p><p>一类动词：う段 ⇒  え段 ＋ ば (基本形的最后一个音变成相应的“え”段上的音，再加“ば”)</p><p>二类动词：る ⇒ れば (基本形的“る”变成“れば”)</p><p>三类动词：来る ⇒ 来れば、する ⇒ すれば</p><table align="center" border="1" cellpadding="1" cellspacing="1" style="width:500px;"><caption>   <strong><span>动词ば形变化规则</span></strong>  </caption><tbody><tr><td><strong>类形</strong></td><td style="width:145px;"><strong>基本形</strong></td><td style="width:239px;"><strong>ば形</strong></td></tr><tr><td colspan="1" rowspan="2" style="width:144px;">一类动词</td><td style="width:145px;">書く (かく)</td><td style="width:239px;">書けば (かけば)</td></tr><tr><td style="width:145px;">読む (よむ)</td><td style="width:239px;">読めば (よめば)</td></tr><tr><td colspan="1" rowspan="2" style="width:144px;">二类动词</td><td style="width:145px;">食べる (たべる)</td><td style="width:239px;">食べれば (たべれば)</td></tr><tr><td style="width:145px;">見る (みる)</td><td style="width:239px;"> <p>見れば (みれば)</p> </td></tr><tr><td colspan="1" rowspan="2" style="width:144px;">三类动词</td><td style="width:145px;">来る (くる)</td><td style="width:239px;">来れば (<strong>くれば</strong>)</td></tr><tr><td style="width:145px;">する</td><td style="width:239px;">すれば</td></tr></tbody></table><p>除了动词，一类形容词也拥有假定型：把词尾的“い” ⇒ “ければ”</p><table align="center" border="1" cellpadding="1" cellspacing="1" style="width:500px;"><caption>   <strong><span>一类形容词ば形变化规则</span></strong>  </caption><tbody><tr><td style="width:116px;"><strong>类形</strong></td><td style="width:169px;"><strong>基本形</strong></td><td style="width:216px;"><strong>ば形</strong></td></tr><tr><td colspan="1" rowspan="2" style="width:116px;">一类形容词</td><td style="width:169px;">ない </td><td style="width:216px;">なければ</td></tr><tr><td style="width:169px;">楽しい (たのしい)</td><td style="width:216px;">楽しければ (たのしければ)</td></tr></tbody></table><p>〜ばよかった: はあ、こんなもの買わなければよかった。損した。啊，要是没买这个东西就好了。真吃亏。</p><h3 id="被动型"><a href="#被动型" class="headerlink" title="被动型"></a>被动型</h3><p>表示作主语的人或者事物承受某种动作或影响</p><p>一类动词：把ない形的“ない” ⇒ “れる”</p><p>二类动词：把ない形的“ない” ⇒ “られる”</p><p>三类动词：来る ⇒ 来られる、する ⇒ される</p><table align="center" border="1" cellpadding="1" cellspacing="1" style="width:573px;"><caption>   <strong><span>动词被动形式变化规则</span></strong>  </caption><tbody><tr><td style="width:78px;"><strong>类形</strong></td><td style="width:122px;"><strong>基本形</strong></td><td style="width:171px;"><strong>被动形式(基本形)</strong></td><td style="width:199px;"><strong>被动形式(ます形)</strong></td></tr><tr><td colspan="1" rowspan="2" style="width:78px;">一类动词</td><td style="width:122px;">書く (かく)</td><td style="width:171px;">書かれる(かかれる)</td><td style="width:199px;">書かれます(かかれます)</td></tr><tr><td style="width:122px;">読む (よむ)</td><td style="width:171px;">読まれる(よまれる)</td><td style="width:199px;">読まれます(よまれます)</td></tr><tr><td colspan="1" rowspan="2" style="width:78px;">二类动词</td><td style="width:122px;">食べる (たべる)</td><td style="width:171px;">食べられる (たべられる)</td><td style="width:199px;">食べられます(たべられます)</td></tr><tr><td style="width:122px;">見る (みる)</td><td style="width:171px;"> <p>見られる (みられる)</p> </td><td style="width:199px;">見られます(みられます)</td></tr><tr><td colspan="1" rowspan="2" style="width:78px;">三类动词</td><td style="width:122px;">来る (くる)</td><td style="width:171px;">来られる(こられる)</td><td style="width:199px;"> <p>来られます(こられます)</p> </td></tr><tr><td style="width:122px;">する</td><td style="width:171px;">される</td><td style="width:199px;">されます</td></tr></tbody></table><h3 id="使役型"><a href="#使役型" class="headerlink" title="使役型"></a>使役型</h3><p>表示使役主体强制或指示动作主体进行动作；使役主体对动作主体的行为许可或放任。</p><p>一类动词：把ない形的“ない” ⇒ “せる”</p><p>二类动词：把ない形的“ない” ⇒ “させる”</p><p>三类动词：来る ⇒ 来させる、する ⇒ させる</p><table align="center" border="1" cellpadding="1" cellspacing="1" style="width:573px;"><caption>   <strong><span>动词使役形式变化规则</span></strong>  </caption><tbody><tr><td style="width:78px;"><strong>类形</strong></td><td style="width:122px;"><strong>基本形</strong></td><td style="width:171px;"><strong>使役形式(基本形)</strong></td><td style="width:199px;"><strong>使役形式(ます形)</strong></td></tr><tr><td colspan="1" rowspan="2" style="width:78px;">一类动词</td><td style="width:122px;">書く (かく)</td><td style="width:171px;">書かせる(かかせる)</td><td style="width:199px;">書かせます(かかせます)</td></tr><tr><td style="width:122px;">読む (よむ)</td><td style="width:171px;">読ませる(よませる)</td><td style="width:199px;">読ませます(よませます)</td></tr><tr><td colspan="1" rowspan="2" style="width:78px;">二类动词</td><td style="width:122px;">食べる (たべる)</td><td style="width:171px;">食べさせる(たべさせる)</td><td style="width:199px;">食べさせます(たべさせます)</td></tr><tr><td style="width:122px;">見る (みる)</td><td style="width:171px;"> <p>見させる (みさせる)</p> </td><td style="width:199px;">見させます(みさせます)</td></tr><tr><td colspan="1" rowspan="2" style="width:78px;">三类动词</td><td style="width:122px;">来る (くる)</td><td style="width:171px;">来させる(こさせる)</td><td style="width:199px;"> <p>来させます(こさせます)</p> </td></tr><tr><td style="width:122px;">する</td><td style="width:171px;">させる</td><td style="width:199px;">させます</td></tr></tbody></table><h3 id="使役被动型"><a href="#使役被动型" class="headerlink" title="使役被动型"></a>使役被动型</h3><p>由使役形式加被动形式构成。一般表示（句子的主语）<strong>被迫</strong>性的动作。</p><p>一类动词：</p><ul><li>第一种方法：把“ない”形的“ない”⇒“せられる”(比较少用)；</li><li>第二种方法：把ない形的“ない” ⇒ “される”(常用，但对于动词结尾是“す”的情况不适用)；</li></ul><p>二类动词：把ない形的“ない” ⇒ “させられる”</p><p>三类动词：来る ⇒ 来させられる、する ⇒ させられる</p><table align="center" border="1" cellpadding="1" cellspacing="1" style="width:573px;"><caption>   <strong><span>动词使役被动形式变化规则</span></strong>  </caption><tbody><tr><td style="width:95px;"><strong>类形</strong></td><td style="width:138px;"><strong>基本形</strong></td><td style="width:159px;"><strong>使役被动形式(基本形)</strong></td><td style="width:178px;"><strong>使役被动形式(ます形)</strong></td></tr><tr><td colspan="1" rowspan="2" style="width:95px;">一类动词</td><td style="width:138px;">書く (かく)</td><td style="width:159px;"> <p>書かされる</p> <p>(かかされる)</p> </td><td style="width:178px;"> <p>書かされます</p> <p>(かかされます)</p> </td></tr><tr><td style="width:138px;">読む (よむ)</td><td style="width:159px;"> <p>読まされる</p> <p>(よまされる)</p> </td><td style="width:178px;"> <p>読まされます</p> <p>(よまされます)</p> </td></tr><tr><td colspan="1" rowspan="2" style="width:95px;">二类动词</td><td style="width:138px;">食べる (たべる)</td><td style="width:159px;"> <p>食べさせられる</p> <p>(たべさせられる)</p> </td><td style="width:178px;"> <p>食べさせられます</p> <p>(たべさせられます)</p> </td></tr><tr><td style="width:138px;">見る (みる)</td><td style="width:159px;"> <p>見させられる</p> <p>(みさせられる)</p> </td><td style="width:178px;"> <p>見させられます</p> <p>(みさせられます)</p> </td></tr><tr><td colspan="1" rowspan="2" style="width:95px;">三类动词</td><td style="width:138px;">来る (くる)</td><td style="width:159px;"> <p>来させられる</p> <p>(こさせられる)</p> </td><td style="width:178px;"> <p>来させられます</p> <p>(こさせられます)</p> </td></tr><tr><td style="width:138px;">する</td><td style="width:159px;">させられる</td><td style="width:178px;">させられます</td></tr></tbody></table><h2 id="第三类：其它语法"><a href="#第三类：其它语法" class="headerlink" title="第三类：其它语法"></a>第三类：其它语法</h2><h3 id="详细介绍-1"><a href="#详细介绍-1" class="headerlink" title="详细介绍"></a>详细介绍</h3><h4 id="なら"><a href="#なら" class="headerlink" title="なら"></a>なら</h4><p><a href="/2024/08/11/japanese-grammar-2/#toc-heading-9">可以在这个链接看 N3 关于「条件、假定」的总结</a></p><p>普通形 + なら<br>N + なら</p><ol><li>表示假定。多用于对未知事物进行假设或把对方提到的事情作为前提条件，后项发表自己的意见，看法，建议等。可译为：要是…，假如…</li></ol><p>車を運転するならお酒を飲んではいけません。 如果开车的话，不能喝酒。</p><ol start="2"><li>提示主题。多用于会话场合，把之前的话题作为自己的主题再次提出。</li></ol><p>鎌倉へ行くなら、このお店がお勧めですよ。 去镰仓的话，推荐去这家店。</p><h4 id="〜か"><a href="#〜か" class="headerlink" title="〜か"></a>〜か</h4><p>在句子内部表示疑问的说法。</p><p>疑問詞 + V（普通形）か〜</p><p>先生がどこにいるか知ってる？你知道老师在哪里吗？</p><p>高雄へどうやって行くか知っていますか。你知道怎么去高雄吗？</p><p>其他接续还有：</p><p>疑問詞 + イA（普通形）か〜</p><p>疑問詞 + ナA（普通形） だ か〜 ※ナA ~~だ</p><h4 id="ても"><a href="#ても" class="headerlink" title="ても"></a>ても</h4><ol><li>〜ても 即使……</li></ol><p>いくら食べても太らないからいいですね。不管怎么吃都不胖，真好。</p><ol start="2"><li>〜てもいい、なくてもいい 表示许可，允许，相当于「可以…..」；「可以不……」</li></ol><p>ねえお母さん、お菓子買ってもいい？自分のお小遣いで買うから。妈妈，我可以买点心吗？用我的零花钱。</p><h4 id="〜んです"><a href="#〜んです" class="headerlink" title="〜んです"></a>〜んです</h4><p>口语用法：んです</p><p>书面用法：のです</p><p>不改变句子原本的意思，只是表示强调作用。中文映射举例：我是因为…原因迟到的；这个时候表示强调迟到的原因。</p><p>考虑以下两个陈述句：</p><ol><li>雨が降っている。客观地陈述了当你向外看时正在下雨的事实。</li><li>雨が降っているんだ。</li></ol><p>2 可能发生在以下场景：</p><p>在一家咖啡店，我看到一个人拿着湿雨伞进来，我问他为什么。</p><p>结果，他说：「下雨了。」雨が降っているんだ。</p><p>考虑以下两个疑问句：</p><ol><li>もう、レポートを書きましたか？只是简单的疑问说，你给对方写报告了吗？</li><li>＜相手の完成したレポートを見て＞ もう、レポートを書いたんですか！？</li></ol><p>2 可能发生在以下场景：</p><p>对方已经写完了。我觉得他写的真的很快。</p><p>我想说，我看到后觉得「真快！」。用于说话人有一定的「前提」，由于看到或听到，就有了说话的欲望。もう、レポートを書いたんですか！？</p><p><strong>在不熟悉用法的时候，尽量不要在日常使用。这是因为这样的表达带有言下之意。</strong></p><h4 id="〜ながら〜"><a href="#〜ながら〜" class="headerlink" title="〜ながら〜"></a>〜ながら〜</h4><p>动词ます形+ながら+动词 指两个动作在同一时间段内进行、一边……一边……(可以一边打工、一边学习)</p><p>吉田さんは音楽を聞きながら勉強します。（吉田先生一边听音乐一边学习）</p><p>动词ます形+ながら 指事物发展中产生了出乎意料的变化，没有达到应有的效果 虽然……但是……<br>毎日よくピアノを弾いていながら、上手にならない。（虽然每天都弹钢琴，但是也没变熟练）</p><p>名词+ながら 前接名词，经常表示事物的全部。全部……，都……<br>クラスメートながら医者になりました。（同学都成为了医生）</p><blockquote><p>动词ます形+当前文法+动词，还可以有这些用法：<br>1.1 〜過ぎます・〜すぎます・过头了<br>1.2 〜やすい・容易: 先生の授業はわかりやすいです。老师讲的课很好懂。<br>1.3 〜にくい・很难: ちょっと言いにくいんだけど、私はあの人が好きじゃないんだ。虽然有点难开口，但我不喜欢那个人。</p></blockquote><h4 id="〜てしまいます"><a href="#〜てしまいます" class="headerlink" title="〜てしまいます"></a>〜てしまいます</h4><p>结束，或者完蛋的意思。</p><p>財布を無くしてしまいました。完蛋，钱包给弄丢了。</p><h4 id="しています、てあります、ておきます"><a href="#しています、てあります、ておきます" class="headerlink" title="しています、てあります、ておきます"></a>しています、てあります、ておきます</h4><p>N5 学过了他动词：他动词＋しています 正在进行 表示一种状态 表示一种习惯</p><p>自动词〜が〜しています 表示某件事情自己已经完成，表示完成的状态。<strong>无所谓目的</strong>。</p><p>他动词〜が〜てあります</p><ol><li>动作结果肉眼能看见的，它表示动作存续，或者表述一种状态。</li></ol><p>壁にピカソの絵がかけしています。墙壁上挂着毕加索的画。</p><ol><li>动作结果肉眼看不见的，一般表示「提前准备」，且这种状态有目的。</li></ol><p>ホテルはもう予約してあります。酒店已经预定了。</p><p>他动词〜を〜ておきます 为了将来而事先做某事。而且常常有「事情已经做完」的意思。</p><p>（孩子马上就要回来吃饭的上下文）ご飯を作っておきます。强调「做饭」这件事情已经做完了，以便于让孩子感受到。</p><ol><li>事先做….. 这种意思非常类似于上面</li></ol><p>新しい内容を勉强する前に、自分でよく予習しておく。学习新内容之前，先自己好好预习。</p><ol start="2"><li>保持住状态</li></ol><p>そのままにしておいてください。请保持原样。</p><h4 id="あげる、くれる、もらう"><a href="#あげる、くれる、もらう" class="headerlink" title="あげる、くれる、もらう"></a>あげる、くれる、もらう</h4><p>共同点：都有主语和宾语。而且通常为主语和宾语之间单向的给、帮助等善意的事情。但是使用方式稍微有点不同。</p><p>あげる・くれる主语都为做事的发出方。もらう则是接受方，对应其「接受」的意思。<br>あげる和くれる主语不同，如果主语为「我」，则使用あげる。详见下面：</p><p>我方给对方的句型：我方 は 对方 に あげる<br>对方给我方的句型：对方 は 我方 に くれる</p><p>和て加在一起，形成复合动词。例如：给你买、给我看等。</p><p>あげる：表示主语给第二、三人称及其一方的人做某事。主语为动作发出者；动作接受者以补语形式出现，用补格助词「に」表示。</p><p>わたしはあなたに少女マンガを買ってあげましょう。我给你买少女漫画吧。</p><p>くれる：表示主语为第一人称及其一方的人做某事。句子的主语是动作发出者，动作接受者则以补语形式出现，但第一人称常省略。</p><p>有希ちゃんが日本で撮った写真を見せてくれました。有希酱给我看了在日本拍的相片。</p><p>もらう：表示主语让别人为自己做某事。主语是动作的接受者，动作发出者以补语形式出现，用补格助词「に」或「から」表示。</p><p>わたしは彼氏からプレゼントを買ってもらいました。男友给我买了礼物。</p><h4 id="でしよう、がもしれない"><a href="#でしよう、がもしれない" class="headerlink" title="でしよう、がもしれない"></a>でしよう、がもしれない</h4><p>でしよう</p><p>漢字の練習なら、この本がいいでしょう。如果你想练习汉字，这本书应该是个不错的选择。</p><p>がもしれない</p><p>山田さんは図書館にいるかもしれません。山田先生可能在图书馆中。</p><p>がもしれない相比于でしよう不可能性，更高。</p><h4 id="かどうか、か〜ないか"><a href="#かどうか、か〜ないか" class="headerlink" title="かどうか、か〜ないか"></a>かどうか、か〜ないか</h4><p>かどうか</p><p>接续：</p><ul><li>名词+かどうか</li><li>动词普通型&#x2F;终止型+かどうか</li><li>形容词普通型&#x2F;终止型+かどうか</li></ul><p>好きかどうか聞けば分かるでしょう。喜欢还是不喜欢，问一下就知道了吧。（名词+かどうか）</p><p>美味しいかどうかは食べてみないとわからない。吃了后才能知道是否好吃。（形容词+かどうか）</p><p>台風で休暇になるかどうかまだわからない。还不知道台风的时候是否会放假。（动词+かどうか）</p><p>か〜ないか</p><p>かどうか中间不断开表示做不做如，か〜ないか中间必须是前面动作的重复语气上更强如，两者也都可以表示「无论」的意思。</p><p>か〜ないかのうちに：刚…还没…时</p><p>日曜休んだか休んでないかのうちに終わってまた月曜。感觉周日还没休息够就又到了周一。</p><h4 id="で、ので、のに"><a href="#で、ので、のに" class="headerlink" title="で、ので、のに"></a>で、ので、のに</h4><p>で：动词，形容词て型：</p><p>毎晩暑くて、寝られません。每晚很热，睡不着。</p><p>ので：可以视作名词，在更正式的场合使用。</p><p>なくて：和否定放在一起的用法。</p><p>旅行にいけなくて、残念です。不能去旅行，好遗憾。</p><p>のに：表示「竟然」的意思，有一种不可思议的意思。</p><p>午後は試験なのに、彼はまだゲー厶をやっています。明明下午要考试，他却还在玩游戏。</p><h4 id="てみます"><a href="#てみます" class="headerlink" title="てみます"></a>てみます</h4><p>尝试去做某事…</p><p>くつを買う前に、サイズが合うかどうか、はいてみます。买鞋前，大小是否合适，要试穿下。</p><h4 id="そうです"><a href="#そうです" class="headerlink" title="そうです"></a>そうです</h4><ol><li>表示推测：表示对某种事物样态的观感或根据某种情形推测事态的发展。</li></ol><p>ます・い类形容词 + そうです</p><ol start="2"><li>表示听说：表示从别人那里听到某种信息。知道具体的信息来源时。</li></ol><p>完整句子 + そうです</p><p>对比ようです：表示「听说」做的判断，使用そうです；表示「自己推测」做的判断使用ようです。</p><p>一般常见的表达还有：そうだ</p><p>おまえ、うまそうだな。你看起来好像很好吃。（表示推测）</p><p>うわさでは、佐藤さんは李さんのことが好きだそうです。据小道消息，佐藤喜欢小李。（表示听说）</p><h4 id="たら、〜たらどうですか、〜たらいいですか"><a href="#たら、〜たらどうですか、〜たらいいですか" class="headerlink" title="たら、〜たらどうですか、〜たらいいですか"></a>たら、〜たらどうですか、〜たらいいですか</h4><ol><li>たら：如果……；</li></ol><p>安かったら、買いたいです。如果便宜的话，我想买。</p><ol start="2"><li>たらどうですか：「…那样做怎么样」，表示提议或劝诱。这种意思下，どうですか是可以省略的内容，尤其是在口语中。</li></ol><p>吉田君、パーティーには出席しないって。吉田说他不来参加宴会了。</p><p>もう一度誘ってみたら。你再邀请他一次吧。</p><ol start="3"><li>たらいいですか：怎么做才好呢，这个就纯表示疑问了。</li></ol><p>ホテルのをキャンセルしたいんですが、 どうしたらいいですか。想取消酒店预订，该怎么做呢？</p><h4 id="〜し"><a href="#〜し" class="headerlink" title="〜し"></a>〜し</h4><p>又…又…</p><ol><li>表示两个或两个以上的事项同时存在。常与も呼应。</li></ol><p>遊んでもいたいし、勉強もしたい。既想玩，又想学习。</p><ol start="2"><li>表示同时存在的事项是后续句子的理由。</li></ol><p>休みだし、天気もいいし，どこかに出かけませんか。今天休息，天气也不错，去哪儿玩玩儿吧。</p><h4 id="しか〜ない、ほかない"><a href="#しか〜ない、ほかない" class="headerlink" title="しか〜ない、ほかない"></a>しか〜ない、ほかない</h4><p>有两种表现形式：</p><p>〜しか〜ない</p><p>〜しかない</p><p>表示提示一个事项而排斥其他。一般被翻译为「只有、只能」的意思。视前面添加动词还是名词而定。</p><p>手伝ってくれる人が誰もいないから。自分でやるしかない。没有人能帮我，只能自己来。</p><p>以上的「しかない」皆可被替换为「ほかない」，如「自分でやるほかない」。</p><p>漫画、わたしはBLしか読まない。漫画，我只看 BL 漫画。</p><h4 id="〜ていただけませんか"><a href="#〜ていただけませんか" class="headerlink" title="〜ていただけませんか"></a>〜ていただけませんか</h4><p>可以帮我……吗</p><p>わたしが日本語で書いた作文を見ていただけませんか。可以帮我看下我的日语作文吗？</p><h4 id="〜といいです"><a href="#〜といいです" class="headerlink" title="〜といいです"></a>〜といいです</h4><p>可以……样。</p><p>A: 日本語の力を試したいんですけど、何かテストがありますか。我测试下自己的日语水平，有什么考试可以推荐吗？</p><p>B: じゃあ、日本語能力試験を受けるといいですよ。恩，你可以参加日本语能力考。</p><h4 id="〜ことにする"><a href="#〜ことにする" class="headerlink" title="〜ことにする"></a>〜ことにする</h4><p>决定… 其中、こと可以省略。</p><p>晩ご飯はおでんにする。晚饭决定吃关东煮。</p><p>明日からダイエットすることにしよう。我决心从明天开始减肥。</p><h4 id="〜とは"><a href="#〜とは" class="headerlink" title="〜とは"></a>〜とは</h4><p>所谓</p><p>神とは何ぞや。（所谓）神究竟是什么？</p><h4 id="〜く・〜に＋する"><a href="#〜く・〜に＋する" class="headerlink" title="〜く・〜に＋する"></a>〜く・〜に＋する</h4><blockquote><p>N5 学过になる&#x2F;くなる。<br>大学の友だちは、英語の先生になりました。大学朋友成为了一名英语老师。</p></blockquote><p>把…变成、将…变成</p><p>高いですね。もっと安くしてください。太贵了，请再便宜点。</p><p>すみませんが、少し静かにしてください。不好意思，请保持安静。</p><h4 id="みたいだ、みたいな-みたいに"><a href="#みたいだ、みたいな-みたいに" class="headerlink" title="みたいだ、みたいな &#x2F; みたいに"></a>みたいだ、みたいな &#x2F; みたいに</h4><p>みたいだ：好像跟…一样。估计是…</p><p>頭が痛いし、体も暑いし、熱があるみたいだ。头又疼，身体又热，好像发烧了。</p><p>みたいな &#x2F; みたいに：像…那样的</p><p>トムみたいに日本語が上手に話せるようになりたいなあ。我希望能像汤姆一样说好日语。</p><h4 id="〜って"><a href="#〜って" class="headerlink" title="〜って"></a>〜って</h4><p>named &#x2F; called。被称呼名字用。被称之为…</p><p>これはビビンバ っていう韓国の食べ物だよ。这是叫做石锅拌饭的韩国料理哦。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="日语学习" scheme="https://blog.pengdonglai.com/categories/%E6%97%A5%E8%AF%AD%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="日本語" scheme="https://blog.pengdonglai.com/tags/%E6%97%A5%E6%9C%AC%E8%AA%9E/"/>
    
    <category term="语法" scheme="https://blog.pengdonglai.com/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
</feed>
