<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="utf-8"><meta name="keywords" content="Network, Lab"><meta name="description" content="这里是海星来来的博客，虽然他是一个程序员，但是这篇博客应该会很少更新技术相关的东西，因为这太无聊了。"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="renderer" content="webkit|ie-stand|ie-comp"><meta name="mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="theme-color" content="#ffffff"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><title>CS144 Lab（2）：TCP 的发送和接收 | 海祇岛的珊瑚森林</title><link rel="manifest" href="/manifest.json"><link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/favicon.webp"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/libs/awesome/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/libs/materialize/materialize.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/libs/aos/aos.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/libs/animate/animate.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/libs/lightGallery/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/css/matery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/css/my.css"><script src="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/libs/jquery/jquery.min.js"></script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="海祇岛的珊瑚森林" type="application/atom+xml"></head><body><script>// 每天切换 banner 图.  Switch banner image every day.
      const _dayOfWeek = new Date().getDay();
      if (_dayOfWeek === 1 || _dayOfWeek === 6) {
        document.body.classList.add('purple');
      } else if (_dayOfWeek >= 2 && _dayOfWeek <= 3) {
        document.body.classList.add('orange');
      } else if (_dayOfWeek == 4) {
        document.body.classList.add('blue');
      }
      _setCookie = (name, value, days) => {
        if (days) {
          var date = new Date();
          date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
          var expires = "; expires=" + date.toGMTString()
        } else var expires = "";
        document.cookie = name + "https://pengdonglaicom=" + value + expires + "; path=/"
      }

      _getCookie = (name) => {
        var nameEQ = name + "https://pengdonglaicom=";
        var ca = document.cookie.split(';');
        for (var i = 0; i < ca.length; i++) {
          var c = ca[i];
          while (c.charAt(0) == ' ') c = c.substring(1, c.length);
          if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length)
        }
        return null
      }

      window.DarkReader = {
        darkmode: _getCookie('targetDarkmode') === '1',
        changeMode: function () {
            if (this.darkmode) {
                document.body.classList.remove('black');
                const d = new Date().getDay();
                if (d === 1 || d === 6) {
                    document.body.classList.add('purple');
                } else if (d >= 2 && d <= 3) {
                    document.body.classList.add('orange');
                } else if (d == 4) {
                    document.body.classList.add('blue');
                }
                this.darkmode = false;
                _setCookie('targetDarkmode', 0, 7);
                window.changePostCalendarDarkMode && changePostCalendarDarkMode();
            } else {
                document.body.classList.remove('purple', 'orange', 'blue');
                document.body.classList.add('black');
                this.darkmode = true;
                _setCookie('targetDarkmode', 1, 7);
                window.changePostCalendarDarkMode && changePostCalendarDarkMode();
            }
        }
      }
      if (_getCookie('targetDarkmode') === '1') {
          document.body.classList.remove('purple', 'orange', 'blue');
          document.body.classList.add('black');
      }</script><header class="navbar-fixed"><nav id="headNav" class="bg-color nav-transparent"><div id="navContainer" class="nav-wrapper container"><div class="brand-logo"><a href="/" class="waves-effect waves-light"><img src="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/favicon.webp" class="logo-img" alt="LOGO"> <span class="logo-span">海祇岛的珊瑚森林</span></a></div><a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a><ul class="right nav-menu"><li class="hide-on-med-and-down nav-item"><a href="/" class="waves-effect waves-light"><i class="fas fa-home" style="zoom:.6"></i> <span>首页</span></a></li><li class="hide-on-med-and-down nav-item"><a href="" class="waves-effect waves-light"><i class="fas fa-folder-plus" style="zoom:.6"></i> <span>文章</span> <i class="fas fa-chevron-down" aria-hidden="true" style="zoom:.6"></i></a><ul class="sub-nav menus_item_child"><li><a href="/tags"><i class="fas fa-tags fa-fw" style="margin-top:-20px;zoom:.6"></i> <span>标签</span></a></li><li><a href="/archives"><i class="fas fa-archive fa-fw" style="margin-top:-20px;zoom:.6"></i> <span>归档</span></a></li><li><a href="/categories"><i class="fas fa-bookmark fa-fw" style="margin-top:-20px;zoom:.6"></i> <span>分类</span></a></li><li><a target="_blank" rel="noopener" href="http://docs.starfishdl.site"><i class="fas fa-file fa-fw" style="margin-top:-20px;zoom:.6"></i> <span>文档站</span></a></li></ul></li><li class="hide-on-med-and-down nav-item"><a href="/about" class="waves-effect waves-light"><i class="fas fa-user-circle" style="zoom:.6"></i> <span>关于</span></a></li><li class="hide-on-med-and-down nav-item"><a href="" class="waves-effect waves-light"><i class="fas fa-list" style="zoom:.6"></i> <span>多媒体</span> <i class="fas fa-chevron-down" aria-hidden="true" style="zoom:.6"></i></a><ul class="sub-nav menus_item_child"><li><a href="/musics"><i class="fas fa-music fa-fw" style="margin-top:-20px;zoom:.6"></i> <span>音乐</span></a></li><li><a target="_blank" rel="noopener" href="http://pengdonglai.com/?show_drawer=true"><i class="fas fa-address-book fa-fw" style="margin-top:-20px;zoom:.6"></i> <span>收藏链接</span></a></li><li><a href="/bangumis"><i class="fas fa-film fa-fw" style="margin-top:-20px;zoom:.6"></i> <span>追番</span></a></li></ul></li><li><a href="#searchModal" class="modal-trigger waves-effect waves-light"><i id="searchIcon" class="fas fa-search" title="搜索" style="zoom:.85"></i></a></li><li><a href="javascript:DarkReader?.changeMode()" class="waves-effect waves-light"><i id="searchIcon" class="fas darkmode-icon" title="暗黑模式开关" style="zoom:.85"></i></a></li></ul><div id="mobile-nav" class="side-nav sidenav"><div class="mobile-head bg-color"><img alt="avatar" src="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/medias/avatar.webp" class="logo-img circle responsive-img"><div class="logo-name">海祇岛的珊瑚森林</div><div class="logo-desc">这里是海星来来的博客，虽然他是一个程序员，但是这篇博客应该会很少更新技术相关的东西，因为这太无聊了。</div></div><ul class="menu-list mobile-menu-list"><li class="m-nav-item"><a href="/" class="waves-effect waves-light"><i class="fa-fw fas fa-home"></i> 首页</a></li><li class="m-nav-item"><a href="javascript:;"><i class="fa-fw fas fa-folder-plus"></i> 文章 <span class="m-icon"><i class="fas fa-chevron-right"></i></span></a><ul><li><a href="/tags" style="margin-left:75px"><i class="fa fas fa-tags fa-fw" style="position:absolute;left:50px"></i> <span>标签</span></a></li><li><a href="/archives" style="margin-left:75px"><i class="fa fas fa-archive fa-fw" style="position:absolute;left:50px"></i> <span>归档</span></a></li><li><a href="/categories" style="margin-left:75px"><i class="fa fas fa-bookmark fa-fw" style="position:absolute;left:50px"></i> <span>分类</span></a></li><li><a target="_blank" rel="noopener" href="http://docs.starfishdl.site" style="margin-left:75px"><i class="fa fas fa-file fa-fw" style="position:absolute;left:50px"></i> <span>文档站</span></a></li></ul></li><li class="m-nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa-fw fas fa-user-circle"></i> 关于</a></li><li class="m-nav-item"><a href="javascript:;"><i class="fa-fw fas fa-list"></i> 多媒体 <span class="m-icon"><i class="fas fa-chevron-right"></i></span></a><ul><li><a href="/musics" style="margin-left:75px"><i class="fa fas fa-music fa-fw" style="position:absolute;left:50px"></i> <span>音乐</span></a></li><li><a target="_blank" rel="noopener" href="http://pengdonglai.com/?show_drawer=true" style="margin-left:75px"><i class="fa fas fa-address-book fa-fw" style="position:absolute;left:50px"></i> <span>收藏链接</span></a></li><li><a href="/bangumis" style="margin-left:75px"><i class="fa fas fa-film fa-fw" style="position:absolute;left:50px"></i> <span>追番</span></a></li></ul></li><li><div class="divider"></div></li><li><a href="https://github.com/umaru2001" class="waves-effect waves-light" target="_blank"><i class="fab fa-github-square fa-fw"></i>来看看我呀~</a></li></ul></div></div><style>.nav-transparent .github-corner{display:none!important}.github-corner{position:absolute;z-index:10;top:0;right:0;border:0;transform:scale(1.1)}.github-corner svg{color:#000;fill:#fff;height:64px;width:64px}.github-corner:hover .octo-arm{animation:a .56s ease-in-out}.github-corner .octo-arm{animation:none}@keyframes a{0%,to{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}</style><a href="https://github.com/umaru2001" class="github-corner tooltipped hide-on-med-and-down" target="_blank" data-tooltip="来看看我呀~" data-position="left" data-delay="50"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a></nav></header><script src="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/libs/cryptojs/crypto-js.min.js"></script><script>(function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();</script><div class="bg-cover pd-header post-cover" style="background-image:url(https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/medias/featureimages/23.webp);background-position:50% 25%"><div class="container" style="right:0;left:0"><div class="row"><div class="col s12 m12 l12"><div class="brand"><h1 class="description center-align post-title">CS144 Lab（2）：TCP 的发送和接收</h1></div></div></div></div></div><main class="post-container content"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/libs/tocbot/tocbot.css"><style>#articleContent h1::before,#articleContent h2::before,#articleContent h3::before,#articleContent h4::before,#articleContent h5::before,#articleContent h6::before{display:block;content:" ";height:100px;margin-top:-100px;visibility:hidden}#articleContent :focus{outline:0}.toc-fixed{position:fixed;top:64px}.toc-widget{width:345px;padding-left:20px}.toc-widget .toc-title{padding:35px 0 15px 17px;font-size:1.5rem;font-weight:700;line-height:1.5rem}.toc-widget ol{padding:0;list-style:none}#toc-content{padding-bottom:30px;overflow:scroll;max-height:75vh}#toc-content::-webkit-scrollbar{background-color:transparent}#toc-content::-webkit-scrollbar-corner{background-color:transparent}#toc-content ol{padding-left:10px}#toc-content ol li{padding-left:10px}#toc-content .toc-link:hover{color:#42b983;font-weight:700;text-decoration:underline;font-size:1.1rem;line-height:30px}.blue #toc-content .toc-link:hover{color:#4169e1}.purple #toc-content .toc-link:hover{color:#6a5acd}.orange #toc-content .toc-link:hover{color:#ff8c00}.black #toc-content .toc-link:hover{color:#faebd7}#toc-content .toc-link::before{background-color:transparent;max-height:25px;position:absolute;right:23.5vw;display:block}#toc-content .toc-list-item.is-active-li{border-left:5px solid #ccc!important;border-color:#42b983!important;visibility:visible;background-color:rgba(238,243,252,.5)}.black #toc-content .toc-list-item.is-active-li{border-color:#faebd7!important;background-color:rgb(68 68 68 / 61%)}.blue #toc-content .toc-list-item.is-active-li{border-color:#4169e1!important}.purple #toc-content .toc-list-item.is-active-li{border-color:#6a5acd!important}.orange #toc-content .toc-list-item.is-active-li{border-color:#ff8c00!important}#toc-content ol.toc-list.is-collapsible{border-left:2px solid #9fabb4;margin:0 0 0 .5em}.black #toc-content ol.toc-list.is-collapsible{border-left:2px solid #898175}#toc-content .is-active-link{color:#0f9d58}.blue #toc-content .is-active-link{color:#4169e1}.purple #toc-content .is-active-link{color:#6a5acd}.orange #toc-content .is-active-link{color:#ff8c00}.black #toc-content .is-active-link{color:#faebd7}#floating-toc-btn{position:fixed;right:15px;bottom:76px;padding-top:15px;margin-bottom:0;z-index:998}#floating-toc-btn .btn-floating{width:48px;height:48px;background:#404040}#floating-toc-btn .btn-floating i{line-height:48px;font-size:1.4rem}</style><div class="row"><div id="main-content" class="col s12 m12 l9"><div id="artDetail"><div class="card"><div class="card-content article-info"><div class="row tag-cate"><div class="col s7"><div class="article-tag"><a href="/tags/Network/"><span class="chip bg-color">Network</span> </a><a href="/tags/Lab/"><span class="chip bg-color">Lab</span></a></div></div><div class="col s5 right-align"><div class="post-cate"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/%E8%A3%85%E9%80%BC/" class="post-category">装逼 </a><a href="/categories/%E8%A3%85%E9%80%BC/CS144/" class="post-category">CS144</a></div></div></div><div class="post-info"><div class="post-date info-break-policy"><i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp; 2025-02-15</div><div class="info-break-policy"><i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp; 14.2k</div></div></div><hr class="clearfix"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/libs/prism/prism.css"><div class="card-content article-card-content"><div id="articleContent"><blockquote><p>前景提要<br>在 lab0 中，我们实现了流控制字节流 <code>ByteStream</code>。<br>在 lab1 中，我们创建了一个模块 <code>StreamReassembler</code>，该模块接受一系列从同一字节流中提取的子字符串，并将它们重新填充回 <code>ByteStream</code>，同时将其内存消耗限制在给定的容量 capacity。</p></blockquote><p>现在，在 lab2 中，你将实现 TCP 中处理入站字节流的部分：<code>TCPReceiver</code>。在编写<code>StreamReassembler</code> 和 <code>ByteStream</code> 时，你已经完成了其中大部分的「算法」工作。<code>TCPReceiver</code> 主要的逻辑是如何将这些类连接到 TCP 格式。</p><p>在 lab3 中，你将实现连接的另一端 <code>TCPSender</code>：一个将出站字节流转换为不可靠数据报中发送段的工具。它负责读取 <code>ByTestStream</code>（由某些发送方应用程序创建并写入），并将流转换为一系列传出 TCP Segment。</p><h2 id="lab2-TCPReceiver"><a href="#lab2-TCPReceiver" class="headerlink" title="lab2: TCPReceiver"></a>lab2: TCPReceiver</h2><h3 id="1-1-序列号"><a href="#1-1-序列号" class="headerlink" title="1.1 序列号"></a>1.1 序列号</h3><h4 id="1-1-1-概念"><a href="#1-1-1-概念" class="headerlink" title="1.1.1 概念"></a>1.1.1 概念</h4><p>实际上我们绝大多数人进入 lab2 就会被这张表格糊脸：</p><table><thead><tr><th>Sequence Numbers</th><th>Absolute Sequence Numbers</th><th>Stream Indices</th></tr></thead><tbody><tr><td>Start at the ISN</td><td>Start at 0</td><td>Start at 0</td></tr><tr><td>Include SYN&#x2F;FIN</td><td>Include SYN&#x2F;FIN</td><td>Omit SYN&#x2F;FIN</td></tr><tr><td>32 bits, wrapping</td><td>64 bits, non-wrapping</td><td>64 bits, non-wrapping</td></tr><tr><td>“seqno”</td><td>“absolute seqno”</td><td>“stream index”</td></tr></tbody></table><h4 id="1-1-2-推导-＆-转换逻辑"><a href="#1-1-2-推导-＆-转换逻辑" class="headerlink" title="1.1.2 推导 ＆ 转换逻辑"></a>1.1.2 推导 ＆ 转换逻辑</h4><p>TCP 的序列号是 32 位的，可能会因为回绕 (wrap around) 的问题，所以需要将其转换为一个更大的数值空间，也就是 absolute_seqno。而 checkpoint 的作用是作为一个参考点，帮助确定最接近的 absolute_seqno 值。也就是说，当多个可能的 absolute_seqno 可能对应同一个 32 位的 seqno 时，选择离 checkpoint 最近的那个。</p><h4 id="1-1-3-与-TCPReceiver-的联系"><a href="#1-1-3-与-TCPReceiver-的联系" class="headerlink" title="1.1.3 与 TCPReceiver 的联系"></a>1.1.3 与 TCPReceiver 的联系</h4><p>那在 TCPReceiver 的 receiver_segment() 中，什么时候需要调用这个 unwrap 函数呢？</p><p>是在处理接收到的 TCP 段的序列号时，需要将其转换为绝对序列号，以便确定数据的位置。例如，当收到一个数据包时，里面的 seqno 是 32 位的，我们需要知道它在整个字节流中的绝对位置，这样才能正确重组数据。</p><p>此时我们已经有了核心方法：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> absolute_seqno <span class="token operator">=</span> <span class="token function">unwrap</span><span class="token punctuation">(</span>seg<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>seqno<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token operator">-></span>_isn<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">/* 未知 checkpoint */</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在调用 unwrap 的时候，应该把第三个参数 checkpoint 设置为什么值？</p><p>我们先明确一个结论：checkpoint 值的设立，是为了确保 <code>segment_received()</code> 获取到的 <code>seqno</code> 转为的 <code>absolute_seqno</code>，符合预期。进一步地说，它能被转为正确的 <code>absolute_seqno</code> 而不是 <code>absolute_seqno - n*2^32</code> 亦或者是 <code>absolute_seqno + n*2^32</code>。因为 checkpoint 值的不同，导致的转化出现不符合预期的情况，就是转化出来的 <code>absolute_seqno</code> 多出或者少了若干个 2^32 的量级。</p><p>我们来直观表示一下。假设我们有三个 2^32 的区间 ，checkpoint 在 (2^32, 2*2^32) 这个区间范围内，我们可以这样表示当前的区间：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">0, ..., 2^32, ..., [checkpoint], ..., 2*2^32, ..., 3*2^32<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>一个 <code>seqno</code> 为 1 的 segment 片段，它有可能被分配到区间内的 <code>1</code>，也有可能被分配到 <code>1+2^32</code> 或者 <code>1+2*2^32</code> 这两个地方。我们站外设计者的视角来看当然希望它转换后的 <code>absolute_seqno</code> 也是 <code>1</code>. 但很可惜，它最终得到的值是 <code>1+2^32</code> 或者 <code>1+2*2^32</code>，因为它们离 checkpoint 更近。具体结果是什么则要取决于它是否离 checkpoint 更加接近了。</p><p>从直观上，离 checkpoint 近的 <code>seqno</code> 才更不容易出错。实际上，它拥有一个十分明确的「边界」，在边界内的 <code>seqno</code> 转换后，一定不会出错。在边界外的 <code>seqno</code> 转换后，一定会出错。我们进一步讨论这个「边界」的范围：</p><p>假定 checkpoint 为 <code>2+2^32</code>，那么它的「边界」是这个样子：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">0, ..., [下边界: 3+2^31], ..., 2^32, ..., [checkpoint: 2+2^32], ..., [上边界: 1+2^32+2^31], ..., 2*2^32, ..., 3*2^32<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>是一个：<strong>以 checkpoint 为中心，大小为 2^32-1 的区间</strong>。</p><p>所以 checkpoint 是什么值，就转化为了：「区间」的中心值是什么值，才能让 <code>seqno</code> 的值尽可能地落在这个区间内。</p><p>也可以等价于，是否能找到一个区间，到达 TCP 接收端的 segment 片段中的 <code>seqno</code> 尽可能落在这个区间。</p><p>当然这个问题实际上我们现在仍然难以证明（笔者写到这里也不知道后续的章节是否会证明这个问题，哈哈哈）所以我们抛出结论：</p><p><strong>checkpoint 的正确取值应为当前接收方期望的下一个字节的绝对序列号，即已成功重组并写入字节流（ByteStream）的字节数量。</strong>具体来说：</p><p>checkpoint 是 <code>stream_out().bytes_written()</code>，即已写入的字节数。</p><ul><li><code>absolute_seqno</code> 从 0 开始计数，每个字节对应一个绝对序列号。例如，第一个字节为 0，第二个为 1，依此类推。</li><li>若已成功重组并写入 k 个字节（<code>stream_out().bytes_written()</code> &#x3D;&#x3D; k），则下一个期望的字节的 <code>absolute_seqno</code> 是 k。</li><li>使用 k 作为 checkpoint，unwrap 会选择最接近 k 的合法 <code>absolute_seqno</code>，确保正确处理序列号回绕。到达 TCP 接收端的 segment 片段中的 <code>seqno</code> 尽可能落在了以 <code>absolute_seqno</code> 为中心，长度为 2^32-1 的区间。</li></ul><p>是不是听着好像也还挺合理的… 和现实中对应，2^32 已经是 4.295GB 大小了。以我们对于 TCP 的控制来说，传输应该不会乱成这个样子吧。康宇的博客也有这样的描述：</p><blockquote><p>但几乎不可能出现相邻到达的两个 segment 序号差值超过 <code>INT32_MAX</code> 的情况，除非延迟以年为单位，或者产生了比特差错（后面的 LAB 可能涉及）。</p></blockquote><p>我们现在不再纠结，然后处理出来应该是这样：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> absolute_seqno <span class="token operator">=</span> <span class="token function">unwrap</span><span class="token punctuation">(</span>seg<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>seqno<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token operator">-></span>_isn<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">stream_out</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bytes_written</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当然在我的项目中，我新增了一个方法获取 <code>StreamReassembler</code> 中的 <code>_first_disassembled_index</code>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">size_t <span class="token class-name">StreamReassembler</span><span class="token double-colon punctuation">::</span><span class="token function">first_disassembled_index</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token operator">-></span>_first_disassembled_index<span class="token punctuation">;</span> 
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>它和 <code>stream_out().bytes_written()</code> 实际上是同一个值。这一点就不再展开。</p><h3 id="1-2-实现"><a href="#1-2-实现" class="headerlink" title="1.2 实现"></a>1.2 实现</h3><p><code>tcp_receiver.hh</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">TCPReceiver</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">//! Our data structure for re-assembling bytes.</span>
    StreamReassembler _reassembler<span class="token punctuation">;</span>

    <span class="token comment">//! The maximum number of bytes we'll store.</span>
    size_t _capacity<span class="token punctuation">;</span>

    std<span class="token double-colon punctuation">::</span>optional<span class="token operator">&lt;</span>WrappingInt32<span class="token operator">></span> _ackno<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

    std<span class="token double-colon punctuation">::</span>optional<span class="token operator">&lt;</span>WrappingInt32<span class="token operator">></span> _isn<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

    <span class="token keyword">void</span> <span class="token function">_update_ackno</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>tcp_receiver.cc</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">TCPReceiver</span><span class="token double-colon punctuation">::</span><span class="token function">segment_received</span><span class="token punctuation">(</span><span class="token keyword">const</span> TCPSegment <span class="token operator">&amp;</span>seg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token operator">-></span>_isn<span class="token punctuation">.</span><span class="token function">has_value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>seg<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>syn<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">this</span><span class="token operator">-></span>_isn <span class="token operator">=</span> seg<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>seqno<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token operator">-></span>_reassembler<span class="token punctuation">.</span><span class="token function">push_substring</span><span class="token punctuation">(</span>seg<span class="token punctuation">.</span><span class="token function">payload</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">copy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> seg<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>fin<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token operator">-></span><span class="token function">_update_ackno</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">auto</span> absolute_seqno <span class="token operator">=</span> <span class="token function">unwrap</span><span class="token punctuation">(</span>seg<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>seqno<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token operator">-></span>_isn<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token operator">-></span>_reassembler<span class="token punctuation">.</span><span class="token function">first_disassembled_index</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// absolute_seqno（绝对序列号）已经包含了一个 syn，因此需要 -1 才能得到正确的起始索引</span>
    <span class="token comment">// 如果这个地方已经收到 fin 了，并且绝对序列号大于 fin，那么就要 -2</span>
    <span class="token comment">// 但我们实际上在绝对序列号大于 fin 的时候在 push_string 内部就会被抛弃掉，因此不必这么做，直接优化成 -1</span>
    <span class="token keyword">this</span><span class="token operator">-></span>_reassembler<span class="token punctuation">.</span><span class="token function">push_substring</span><span class="token punctuation">(</span>seg<span class="token punctuation">.</span><span class="token function">payload</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">copy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> absolute_seqno <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> seg<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>fin<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token operator">-></span><span class="token function">_update_ackno</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

optional<span class="token operator">&lt;</span>WrappingInt32<span class="token operator">></span> <span class="token class-name">TCPReceiver</span><span class="token double-colon punctuation">::</span><span class="token function">ackno</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token operator">-></span>_ackno<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>

size_t <span class="token class-name">TCPReceiver</span><span class="token double-colon punctuation">::</span><span class="token function">window_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token operator">-></span>_capacity <span class="token operator">-</span> <span class="token keyword">this</span><span class="token operator">-></span>_reassembler<span class="token punctuation">.</span><span class="token function">stream_out</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">buffer_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token class-name">TCPReceiver</span><span class="token double-colon punctuation">::</span><span class="token function">_update_ackno</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-></span><span class="token function">stream_out</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">input_ended</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">this</span><span class="token operator">-></span>_ackno <span class="token operator">=</span> <span class="token function">wrap</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-></span>_reassembler<span class="token punctuation">.</span><span class="token function">first_disassembled_index</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token operator">-></span>_isn<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-></span>_isn<span class="token punctuation">.</span><span class="token function">has_value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">this</span><span class="token operator">-></span>_ackno <span class="token operator">=</span> <span class="token function">wrap</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-></span>_reassembler<span class="token punctuation">.</span><span class="token function">first_disassembled_index</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token operator">-></span>_isn<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="lab3-TCPSender"><a href="#lab3-TCPSender" class="headerlink" title="lab3: TCPSender"></a>lab3: TCPSender</h2><h3 id="2-1-理论"><a href="#2-1-理论" class="headerlink" title="2.1 理论"></a>2.1 理论</h3><h4 id="2-1-1-发送数据"><a href="#2-1-1-发送数据" class="headerlink" title="2.1.1 发送数据"></a>2.1.1 发送数据</h4><p>发送数据，就是字面意思…</p><p>当然，我们需要知道两个事情：</p><ul><li>什么时候可以发送数据？</li></ul><p>一种状况是，我们需要判断这些数据我们能完全发送，也就是数据量不能超过我们发送端的承受能力，当然，也不能超过发送端缓冲区的容量（即我们在这一刻时间能拿出多少数据出来发送）。</p><p>另一种情况是，不能超过对方接收端的接收能力。</p><p>因此，需要分两种情况讨论：</p><ol><li>数据量不能超过我们发送端的承受能力</li></ol><p>发送端承受能力，可以用 <code>TCPConfig::MAX_PAYLOAD_SIZE</code> 来表示，这是发送端的一个属性，也是自定义好的，不需要我们为它赋值。</p><p>发送端缓冲区的容量，也就是 <code>this-&gt;_stream.buffer_size()</code>。</p><p>因此，我们可以从这个条件得出发送端的数据条件为：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> sender_max_segment_payload_size <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>TCPConfig<span class="token double-colon punctuation">::</span>MAX_PAYLOAD_SIZE<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token operator">-></span>_stream<span class="token punctuation">.</span><span class="token function">buffer_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>不能超过对方的接收能力</li></ol><p>对方的接收能力，在下一个问题中我们可以知道它是通过唯一的信号 window_size 来通知发送方的。这表示接收端的窗口大小。</p><p>那么，我们可以进一步将 length 表示为：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> segment_payload_size <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>sender_max_segment_payload_size<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token operator">-></span>_window_size<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>发送的时候，也需要有一个特殊条件，那就是对面窗口为 0 的时候，我们需要持续发送数据量为 1 的 Segment，以避免死锁。</p><p>对于这个问题，我们可以在 <code>fill_window()</code> 方法内，设计一个临时参数，欺骗发送端此时对面的 window_size 最小为 1. 这样就可以确保发送端（在对面窗口为 0 的时候）可以一直发送 Segment.payload 为 1 的数据了。</p><p>此时的代码，我们可以这么写：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 为防止死锁，发送数据的时候即便对面窗口为 0，也至少发送 1 单位的数据</span>
<span class="token keyword">auto</span> window_size <span class="token operator">=</span> <span class="token generic-function"><span class="token function">max</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">uint16_t</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token operator">-></span>_window_size<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 中间省略部分逻辑</span>

<span class="token keyword">auto</span> segment_payload_size <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>sender_max_segment_payload_size<span class="token punctuation">,</span> window_size<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对面窗口为 0 的时候，我们需要持续发送数据量为 1 的 Segment。它还有一个作用，那就是处于这种情况的时候不会触发超时重传窗口翻倍的机制。这个我们在「超时重传」中会说明。</p><h4 id="2-1-2-接收-Ack"><a href="#2-1-2-接收-Ack" class="headerlink" title="2.1.2 接收 Ack"></a>2.1.2 接收 Ack</h4><ul><li>最简单过程理解</li></ul><p>怎么理解呢？假如说有三个 Segment，它们的 seqno 为 1,2,3.</p><p>假设我们把这些 Segment 全都发送了。但是我们要怎么知道接收方拿到了这些数据呢？接收方也必须要同时给发送方发送数据，做「信息同步」，或者用互联网黑化「对齐」。</p><p>「信息同步」的信息，会带一个数据叫做 ackno，它的取值巧不巧也正好是 1,2,3. 我们做一个假设，ackno 为 2. 那么发送方就知道 1 和 2 已经被接收了。</p><p>也就是说，ackno 代表的 seqno 及之前所有的 seqno，全都被接收方接受到了。</p><p>另外，我们把已经发送出去但还未成功确认的数据报称作 outstanding segments。</p><ul><li>实际上，同步的数据还包括了 window_size</li></ul><p>在发送数据的时候，我们通过接收方的「窗口大小」，知道了我们最多一次性往 Segment 中放入多少数据。那么窗口大小也必须要从「接收方」同步给「发送方」。</p><p>因此，我们可以解答什么是「接收 Ack」了：实际上就是接收方发送信息，同步发送方信息。这个信息包含两个标志，一个是 ackno，也就是接收方接收到了哪些数据。另一个则是 window_size，也就是接收方的窗口大小，发送方据此调整下一步发送的 Segment 的大小。</p><ul><li>接收 Ack 之后，需要主动发起一次 <code>fill_window()</code></li></ul><p>这个主要是为了防止死锁。</p><h4 id="2-1-3-状态变化"><a href="#2-1-3-状态变化" class="headerlink" title="2.1.3 状态变化"></a>2.1.3 状态变化</h4><ul><li>发送数据包含了一系列的状态变化</li></ul><div align="center"><img src="../../../../loading2.svg" data-original="/2025/02/15/stanford-cs144-2/1.png"></div><p>这张图可以说就是每一个学习网络的孩子都会碰到的图了。我们该如何拆解这张图呢？</p><p>首先我们排除 Error，因为细心的你早就可以发现你在 ByteStream 中已经大概知道 Error 是怎么出现的了~ 当然，也会有一些其它因素导致 Error，但直到这里我们仍然还是不讨论的。请放心。</p><p>观察其它的状态，我们首先要了解两个标志位（SYN 和 FIN 标志位）：</p><ul><li><strong>SYN 标志位</strong><ul><li><strong>含义</strong>：即同步（Synchronize）标志位，用于在 TCP 连接建立时进行同步序列号的操作。</li><li><strong>作用</strong>：发送方（其实就是 TCPSender）发送 SYN 标志位置为 1 的 TCP 报文段，<strong>请求建立连接</strong>，同时在报文中携带一个初始序列号（ISN）。</li></ul></li></ul><p>（服务器收到后，会返回一个 SYN&#x3D;1 且 ACK&#x3D;1 的报文段作为响应，其中也包含自己的初始序列号，这样双方就完成了序列号的同步，为后续可靠的数据传输奠定基础，这也是 TCP 三次握手过程中的关键步骤。）</p><p>–以上这一段是八股文，但是是不是已经有一种理论和实践相结合的体验了–</p><p>SYN 被 TCPSender 发送后，进入 SYN_SENT 状态。收到对应的 SYN&#x3D;1 且 ACK&#x3D;1 的报文段作为响应后，进入 SYN_ACKED 状态。</p><ul><li><strong>FIN 标志位</strong><ul><li><strong>含义</strong>：即结束（Finish）标志位，用于表示发送方已经没有数据要发送了，请求关闭连接。</li><li><strong>作用</strong>：当发送方（其实就是 TCPSender）完成数据传输后，会发送 FIN 标志位置为 1 的 TCP 报文段给对方，告知对方自己的数据发送完毕，请求关闭连接。对方收到后会发送确认报文段（ACK），表示已经收到关闭请求。若接收方也没有数据要发送了，也会发送 FIN 报文段给对方，完成连接的关闭过程，这是 TCP 四次挥手过程中的重要操作。</li></ul></li></ul><p>FIN 基本也是同理，发送端 Sender 发送 FIN 后，进入入 FIN_SENT 状态；收到对应的 FIN&#x3D;1 且 ACK&#x3D;1 的报文段作为响应后，进入 FIN_ACKED 状态。</p><p>关于状态的变化，单元测试套件是如何来判断的呢？我们可以去 <code>tcp_helpers/tcp_state.cc</code> 来学习是如何判断，这对我们理解这几个状态到底是怎么回事很有好处。</p><p>这不是一个必选项，我们实际上无需在程序中写明我们是哪个状态，也不用根据我们当前在哪个状态去做状态机之类的逻辑。因此在我们写代码的时候，不用刻意再去抽离 State 模块。</p><h4 id="2-1-4-超时重传"><a href="#2-1-4-超时重传" class="headerlink" title="2.1.4 超时重传"></a>2.1.4 超时重传</h4><p>TCPSender 承担着两项重要任务：</p><p>其一，它会把原始数据流拆分成多个 TCP 报文（其实就是上一节内容的 Segment），并将这些报文发送出去；这个过程我们在前面说过了。重点了解数据「拆分了」就好。</p><p>其二，它会对每一个已发送出去但尚未被接收方接收的报文，记录其发送时间。倘若存在部分已发送报文，在一段特定的时间内都未得到接收方通过确认号（ackno）进行的确认，那么这些数据包就必须进行重传。</p><p>我们来拆解「其二」，首先就是 1「一段特定的时间」应该如何解释，2「重传哪些数据包」。</p><ol><li>重传所需要的一段特定的时间</li></ol><p>TCPSender 在构造时会被给予一个重传超时时间 RTO 的初始值，它的全称叫 Retransmission Timeout，以下如有可能我们尽可能简称它为 RTO。RTO 是在重新发送未完成 TCP 段之前需要等待的毫秒数，实际上就是「重传所需要的一段特定的时间」的别称。</p><ul><li>RTO 会一直变化，因此它一共是有两个值，它的初始值，和它的现在值。</li><li>RTO 值将会随着时间的流逝（或者更应该说是网络环境的变化）而变化，但初始的RTO将始终不变。</li><li>它的初始值是系统设置好的，不需要我们关心。但它的现值需要我们去根据特定的情况去计算，有一套算法。这就是 <strong>RTO 重传算法</strong>。</li></ul><ol start="2"><li>重传的逻辑：RTO 重传算法</li></ol><p>RTO 重传算法一共有很多种，在理论知识里面我们基本都学了。我们在 lab 中使用较为简单的那一种，它具体描述如下：</p><ul><li>（1）从发送数据包的那一刻开始计时。</li><li>（2）经过一个 RTO 后，没有接收到 Ack。</li><li>（3）此时触发重传，<code>RTO = RTO * 2;</code> 数据包被重新发送。</li><li>（3.1）如果一直没有接受到 ack，那么在上一步重复循环。一直到 uint32_t 下的最大值为止不再继续翻倍。</li><li>（3.2）如果此时接受到了 ackno，无论如何都会将此时的 RTO 重置为初始的 RTO。</li><li>（4.1）此时如果仍然有未确认的包等待重传，那么则基于被重置的 RTO 重新开始计时。</li><li>（4.2）此时如果没有未确认的包（也就是对面收到了我们的全部发送的包），那么计时停止。</li></ul><p>另外，在 2.1.1 我们有提到过，</p><blockquote><p>对面窗口为 0 的时候，我们需要持续发送数据量为 1 的 Segment。它还有一个作用，那就是处于这种情况的时候不会触发超时重传窗口翻倍的机制。</p></blockquote><p>因为这个时候，即便是重传，也只能重传 Segment.payload 为 1 的段。此时它正好处于上述步骤中 2、3、3.1 的区间内，它同样也会一直触发重传，但是不会触发 <code>RTO = RTO * 2;</code> 的机制。此时，<code>RTO = RTO</code>。每次重传都会间隔相同的时间段，且这些时间段都为 RTO。</p><p>实际上的 RTO 重传算法更加复杂，一些课本上的重点特性（快重传、慢启动、选择性确认）我列举在这里供参考（但都是《自顶向下》中学过的）：</p><p>它们更像是 RTO 算法的进一步优化。如果能做完 lab3 并且认真弄懂了其中的内容，再来学习这里会有一种更好的感觉。说不定真的有大神可以把这几个优化做进了 Sender 了呢？</p><p>（这里不看也可以，是选择性阅读，和 lab 没有任何关系）</p><h5 id="超时重传算法补充"><a href="#超时重传算法补充" class="headerlink" title="超时重传算法补充"></a>超时重传算法补充</h5><ol><li>快重传</li></ol><p>而快重传机制是在未等到 RTO 超时的情况下，<strong>通过接收方的反馈信息提前触发重传。</strong></p><p>RTO 重传算法的触发条件是定时器超时，而快重传的触发条件是发送方连续收到三个相同的 ACK（确认号）。例如，发送方发送了数据包 1、2、3、4，接收方成功收到了 1、3、4，但 2 号数据包丢失，接收方会因为没有按序收到 2 号包，而在收到 3、4 号包时，重复发送对 1 号包的确认 ACK。当发送方连续收到三个对 1 号包的 ACK 时，就会触发快重传，不等 RTO 超时就重传 2 号数据包。</p><p>二者相互补充，快重传可以在一定程度上减少因 RTO 设置不合理导致的长时间等待，及时重传丢失的数据，提高传输效率；而 RTO 重传算法则作为一种兜底机制，在快重传未能发挥作用时保证数据最终能够被重传。</p><ol start="2"><li>慢启动</li></ol><p>慢启动是 TCP 协议中用于控制数据发送速率，以避免网络拥塞的一种机制。它是在连接建立初期或网络出现拥塞后恢复时，用来逐渐增加发送方发送数据量的算法，目的是让发送方在开始发送数据时，以一种较为保守、缓慢的方式试探网络的承载能力，防止因发送数据过快过多而导致网络拥塞。</p><ul><li><p><strong>初始阶段</strong>：在 TCP 连接刚建立时，发送方会将拥塞窗口（cwnd）初始化为一个较小的值，通常为 1 个最大段长度（MSS）。这意味着发送方在开始时只能发送一个 MSS 大小的数据段。</p></li><li><p><strong>确认回复与窗口增长</strong>：当发送方发送一个数据段后，会等待接收方的确认（ACK）。一旦收到接收方对该数据段的 ACK，发送方就会将拥塞窗口的大小增加。在慢启动阶段，拥塞窗口是以指数方式增长的，即每收到一个 ACK，拥塞窗口就增加一个 MSS。例如，最初拥塞窗口为 1 个 MSS，收到第一个 ACK 后变为 2 个 MSS，收到第二个 ACK 后变为 4 个 MSS，以此类推。</p></li><li><p><strong>阈值判断</strong>：发送方还会维护一个慢启动阈值（ssthresh）。当拥塞窗口的大小达到或超过慢启动阈值时，慢启动阶段结束，进入拥塞避免阶段，此时拥塞窗口的增长方式会发生变化，不再是指数增长，而是线性增长，以更缓慢、更稳定的方式增加发送速率，避免网络拥塞。</p></li></ul><p>在网络状况不明的情况下，通过缓慢增加发送数据量，可以有效避免因发送方发送速度过快，超出网络承载能力，而导致的网络拥塞。</p><p>虽然慢启动的增长方式看似缓慢，但它能够快速地探测到网络的可用带宽。在网络状况良好时，能迅速增加发送数据量，充分利用网络资源，提高数据传输效率。同时，当网络出现拥塞恢复后，慢启动也能帮助发送方快速恢复到合适的发送速率，尽快恢复数据传输。</p><ol start="3"><li>选择性确认（SACK）</li></ol><p>SACK 机制允许接收方在确认信息中告知发送方哪些数据段已经被正确接收，发送方可以根据这些信息，只重传真正丢失的数据段，避免不必要的重传，从而优化了 RTO 重传算法的性能。</p><p>RTO 重传算法主要关注的是何时触发重传，侧重于解决数据丢失后如何重新发送的问题；而 SACK 机制主要关注的是如何精确地告知发送方哪些数据已经被接收，哪些数据丢失，侧重于提供更详细的接收信息，帮助发送方优化重传策略。</p><h3 id="2-2-细节"><a href="#2-2-细节" class="headerlink" title="2.2 细节"></a>2.2 细节</h3><h4 id="2-2-1-固有字段含义"><a href="#2-2-1-固有字段含义" class="headerlink" title="2.2.1 固有字段含义"></a>2.2.1 固有字段含义</h4><p>根据 TCPSender.hh 的成员变量，我这里做了一份它们的梳理。在这个梳理中，我尽量将我的梳理信息和 2.1 理论知识中的部分挂钩起来，让你可以在拥有理论知识的基础上，</p><h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5><ol><li><strong>以下值会自动初始化，我们只用使用就好</strong>：</li></ol><p>**<code>WrappingInt32 _isn;</code>**：初始序列号（Initial Sequence Number，ISN），用于 TCP 连接建立时的 SYN 段。<code>WrappingInt32</code> 是 32 位包装类型，处理序列号回绕，ISN 是 TCP 连接发送方首字节相对序列号。</p><p>**<code>std::queue&lt;TCPSegment&gt; _segments_out;</code>**：待发送的 TCP 段队列。<code>TCPSender</code> 将需发送的 <code>TCPSegment</code> 对象放入此队列，由 <code>TCPConnection</code> 取出并发送。<br>何为发送数据？就是把 segment 放进它就好了。后面我们会详细讲到。</p><p>**<code>unsigned int _initial_retransmission_timeout;</code>**：连接的初始重传超时时间（Retransmission Timeout，RTO）。段发出后，若在此时长内未收到 ACK 确认，则需重传。</p><p>**<code>ByteStream _stream;</code>**：待发送的字节流，包含未发送的字节数据。<br><code>TCPSender</code> <strong>从此字节流读取数据封装成 TCP 段发送。</strong></p><ol start="2"><li><strong>以下值需要我们主动更新</strong>：</li></ol><p>**<code>uint64_t _next_seqno&#123;0&#125;;</code>**：下一个要发送的字节的绝对序列号。每次发送 TCP 段后，<code>_next_seqno</code> 会依段长度更新。</p><p>**<code>uint64_t _acked_seqno&#123;0&#125;;</code>**：已收到 ACK 确认的最大绝对序列号，用于判断哪些段已被对方成功接收。</p><p>**<code>uint16_t _window_size&#123;1&#125;;</code>**：接收方的窗口大小，表示接收方当前能接收的字节数，初始值为 1。发送方依此窗口大小决定发送数据量。</p><h5 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h5><ol><li><strong>接收 Ack</strong>：</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">ack_received</span><span class="token punctuation">(</span><span class="token keyword">const</span> WrappingInt32 ackno<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">uint16_t</span> window_size<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>功能</strong>：处理接收到的 ACK 确认，依 ACK 号和窗口大小更新 <code>_acked_seqno</code> 和 <code>_window_size</code> 等相关状态，处理未确认段队列。</p><p>是三大核心实现方法之一。用来确认哪些数据已经被接收，（此时发送方不用再维护这些数据，可以抛弃），如果此时仍然保有未接收到的数据，那么启动定时器。（注意不是触发重传！）</p><ol start="2"><li><strong>发送空 Segment</strong>：</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">send_empty_segment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>功能</strong>：生成空负载的 TCP 段（常用于创建空 ACK 段），放入 <code>_segments_out</code> 队列。</p><p>这个直接实现然后发送就好。</p><ol start="3"><li><strong>填充 Receiver 窗口</strong>：</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">fill_window</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>功能</strong>：创建并发送 TCP 段，尽量填满接收方窗口。从 <code>_stream</code> 读取数据，封装成段发送，直到窗口填满或无更多数据可发。</p><p>这个就是实际上的发送方法。也是三大核心实现方法之一。下面我们会着重介绍。</p><ol start="4"><li><strong>时间流逝</strong>：</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">tick</span><span class="token punctuation">(</span><span class="token keyword">const</span> size_t ms_since_last_tick<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>功能</strong>：通知 <code>TCPSender</code> 时间流逝。依流逝时间更新定时器状态，超时则进行重传操作。</p><p>每隔几毫秒，tick 函数将会被调用，其参数声明了过去的时间，是三大核心实现方法之一。因为时间流逝方法中必然要判断当前是否需要触发重传。一旦我们认为需要重传，那么需要重新给定时器设立新的时间，并且从我们暂存的数据结构体中发送最早进入这个暂存数据结构体中的 Segment。</p><p>为什么要这么绕：直接调用 clock 或者 time 将会导致测试套件不可用。</p><ol start="5"><li><strong>访问方法</strong>：</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">size_t <span class="token function">bytes_in_flight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>功能</strong>：返回<strong>已发送但未确认</strong>的字节数，即 <code>_outstanding_seg</code> 队列中所有段占用的序列号数量。</p><p>方法用 <code>fill_window</code> 发出后，对应的 seqno 没有在 <code>receive_ack</code> 中被接收到。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">consecutive_retransmissions</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>功能</strong>：返回连续重传的次数。</p><ol start="6"><li><strong>序列号方法</strong>：</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">uint64_t</span> <span class="token function">next_seqno_absolute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> _next_seqno<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
WrappingInt32 <span class="token function">next_seqno</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">wrap</span><span class="token punctuation">(</span>_next_seqno<span class="token punctuation">,</span> _isn<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>通过这两个方法，用合适的数据类型返回 <code>_next_seqno</code>。</p><hr><p>通过梳理，我们可以知道，主要的三大功能（发送数据、接收 Ack、超时重传）分别由三个主方法完成。我仍然推荐先思考好这三个方法以外的其它方法如何实现，再去一个个推理三个主方法应该怎么写。</p><h4 id="2-2-2-发送-Segment"><a href="#2-2-2-发送-Segment" class="headerlink" title="2.2.2 发送 Segment"></a>2.2.2 发送 Segment</h4><p>发送数据的核心代码实际上就是它：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 发送数据，segments_out 中的数据被发送出去是调用者做的事情，Sender 无需关心</span>
<span class="token keyword">this</span><span class="token operator">-></span><span class="token function">segments_out</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>segment_to_send<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>fill_window()</code> 方法中，我们可以梳理出它的主要逻辑：</p><ol><li><p>只要「已经被发送出去」的数据量，小于对面 window_size 就必须一直发送。在这个过程中 <code>this-&gt;bytes_in_flight()</code> 和 window_size 都会动态变化：</p><ul><li>每发送一次，<code>this-&gt;bytes_in_flight()</code> 都会增长，两者确实会一直差距缩小。</li><li>但由于 Sender 同时也在 receive_ack，因此 window_size 也会一直增长。</li><li>他们是一个动态的过程，因此需要使用 while 一直循环，直到 <code>this-&gt;bytes_in_flight()</code> 即已发送的数据足够多，预计可以填满 window_size 才会满足。</li><li>window_size 变为 0 时，Sender 仍然会一直发送，这个我们后面再进行补充。</li></ul></li><li></li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 只要还有「预订要发送」但是这些数据还没填满 Receiver 窗口的空间，就从 _stream 中读取数据，然后发出去</span>
<span class="token comment">// 要读取到的数据需要充分考虑到 window_size，然后有选择性的读取数据的长度</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-></span><span class="token function">bytes_in_flight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> window_size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    TCPSegment segment_to_send<span class="token punctuation">;</span>

    <span class="token comment">// 给 segment_to_send 添加 seqno</span>
    segment_to_send<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>seqno <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-></span><span class="token function">next_seqno</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 数据是从 _stream 中读取的</span>
    <span class="token keyword">auto</span> payload <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-></span>_stream<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>payload_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    segment_to_send<span class="token punctuation">.</span><span class="token function">payload</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">string</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 发送数据，segments_out 中的数据被发送出去是调用者做的事情，Sender 无需关心</span>
    <span class="token keyword">this</span><span class="token operator">-></span><span class="token function">segments_out</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>segment_to_send<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 更新序列号和发出但未 ACK 的字节数</span>
    <span class="token keyword">this</span><span class="token operator">-></span>_next_seqno <span class="token operator">+=</span> payload_true_size<span class="token punctuation">;</span>  <span class="token comment">// _next_seqno 是 absolute seqno</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><code>std::queue&lt;std::pair&lt;uint64_t, TCPSegment&gt; &gt; _outstanding_seg;</code></strong></p><p>已发出但未收到 ACK 确认的 TCP 段队列。每个元素是 <code>std::pair</code>，<code>uint64_t</code> 表示段的绝对序列号，<code>TCPSegment</code> 是具体段，用于管理未确认段。</p><p>**<code>bool _has_set_fin_flag&#123;false&#125;;</code>**：是否发送了 FIN 标志位的标志。FIN 标志表示发送方无更多数据要发送，请求关闭连接。发送带 FIN 标志的段后，此标志设为 <code>true</code>。</p><p>**<code>bool _has_set_syn_flag&#123;false&#125;;</code>**：是否发送了 SYN 标志位的标志。SYN 标志用于发起 TCP 连接建立。发送带 SYN 标志的段后，此标志设为 <code>true</code>。</p><h4 id="2-2-3-接收-Ack"><a href="#2-2-3-接收-Ack" class="headerlink" title="2.2.3 接收 Ack"></a>2.2.3 接收 Ack</h4><h4 id="2-2-4-超时重传"><a href="#2-2-4-超时重传" class="headerlink" title="2.2.4 超时重传"></a>2.2.4 超时重传</h4><p>一旦我们认为需要重传，那么需要重新给定时器设立新的时间，并且从我们暂存的数据结构体中发送最早进入这个暂存数据结构体中的 Segment。</p><p>**<code>TCPSenderTimer _timer;</code>**：重传定时器，跟踪每个段的发送时间，超时触发重传操作。</p><p>**<code>uint32_t _consecutive_retransmissions_count&#123;0&#125;;</code>**：连续重传的次数。段重传后仍未收到 ACK 确认，继续重传，此计数器记录连续重传次数，用于调整重传超时时间。</p><h3 id="2-3-边界情况"><a href="#2-3-边界情况" class="headerlink" title="2.3 边界情况"></a>2.3 边界情况</h3><h4 id="2-3-1-Test-语句"><a href="#2-3-1-Test-语句" class="headerlink" title="2.3.1 Test 语句"></a>2.3.1 Test 语句</h4><p><code>send_extra.cc</code> 中，助教给了很多用例。这些用例我认为如果可以在编码之前就看的比较明白，就可以帮助我们节省很多时间，也可以帮我们理解 sender 发挥的作用~</p><p>首先我们需要理解这几个 test 语句：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>ExpectSegment<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">with_no_flags</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">with_syn</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">with_payload_size</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">with_seqno</span><span class="token punctuation">(</span>isn<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>TCPSender 发送 SYN 段（序列号为 isn），无数据负载。</p><p><code>ExpectSegment&#123;&#125;</code> 表示的是当前发送了一个 segment，这个 segment 在这个时候已经被 <code>push</code> 到了 <code>this-&gt;_segments_out</code> 中。</p><p>它表示当前 sender 发送了一个段。发送了一个 segment。</p><p>后面一系列的 with 方法实际上就是验证当前 segment 的属性是否正确，如果不符合预期则会抛出异常。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>ExpectNoSegment<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同理可得，当前没有 segment 被发送。也就是说，test 无法在 <code>this-&gt;_segments_out</code> 中取到新的 segment。</p><p>这里要额外说明一种情况就是：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>ExpectSegment<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">with_no_flags</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">with_syn</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">with_payload_size</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">with_seqno</span><span class="token punctuation">(</span>isn<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>ExpectNoSegment<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>实际上它表示的就是 segment 从 <code>this-&gt;_segments_out</code> 中被取出来之后，<code>this-&gt;_segments_out</code> 里面就再也没有了其他数据。这种情况下适合检查的是，<code>this-&gt;_segments_out</code> 里面有好几个 segment 要连着发送的情况。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token function">WriteBytes</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>TCPSender 将 <code>&quot;abc&quot;</code> 写入发送缓冲区。它实际上会执行一次 <code>sender.fill_window()</code> 这意味着通过写入缓冲区内的数据可以在这个过程中被立马放入 <code>this-&gt;_segments_out</code>。</p><p><code>sender_harness.cc</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">WriteBytes</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">SenderAction</span></span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>TCPSender <span class="token operator">&amp;</span>sender<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>queue<span class="token operator">&lt;</span>TCPSegment<span class="token operator">></span> <span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>
        sender<span class="token punctuation">.</span><span class="token function">stream_in</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>_bytes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>_end_input<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            sender<span class="token punctuation">.</span><span class="token function">stream_in</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">end_input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        sender<span class="token punctuation">.</span><span class="token function">fill_window</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>Tick<span class="token punctuation">&#123;</span>rto <span class="token operator">-</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>时间流逝 RTO-5 个时间单位，未触发超时。</p><p>Tick 都表示当前时间是逐步在流逝的。测试框架会主动触发时间的流逝这一「行为」。和现实世界中的流逝是毫无关系的。</p><p>一般来说，Tick 常常用于测试重传机制相关的内容。如果有如下过程：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>Tick<span class="token punctuation">&#123;</span>rto <span class="token operator">-</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这表示过了 RTO-5 个时间单位后，再过 6 个时间单位。这其中过了一个 RTO 单位，<strong>一般情况下</strong>会触发重传一次，也会触发一次回退。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>AckReceived<span class="token punctuation">&#123;</span>WrappingInt32<span class="token punctuation">&#123;</span>isn <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">with_win</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接收方确认 SYN，ACK 号为 <code>isn+1</code>（表示期望下一个字节是 <code>isn+1</code>）。</p><p>这表示 sender 接受到了一个 Ack，实际上会执行 <code>this-&gt;ack_received()</code> 方法。z之后也会直接开始执行 <code>sender.fill_window();</code> 方法。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">AckReceived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">SenderAction</span></span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>TCPSender <span class="token operator">&amp;</span>sender<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>queue<span class="token operator">&lt;</span>TCPSegment<span class="token operator">></span> <span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>
        sender<span class="token punctuation">.</span><span class="token function">ack_received</span><span class="token punctuation">(</span>_ackno<span class="token punctuation">,</span> _window_advertisement<span class="token punctuation">.</span><span class="token function">value_or</span><span class="token punctuation">(</span>DEFAULT_TEST_WINDOW<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        sender<span class="token punctuation">.</span><span class="token function">fill_window</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>ExpectState<span class="token punctuation">&#123;</span>TCPSenderStateSummary<span class="token double-colon punctuation">::</span>SYN_ACKED<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个就真的是顾名思义了，它需要检查你当前的 sender 处于哪个状态。</p><p>你可以通过 <code>tcp_helpers/tcp_state.cc</code> 来得知 test 框架判断 sender 处于哪个状态的依据。</p><h4 id="2-3-2-初始情况"><a href="#2-3-2-初始情况" class="headerlink" title="2.3.2 初始情况"></a>2.3.2 初始情况</h4><p>一般来说，测试环境都会有一个 SYN —&gt; ACK 的过程，其实就是我们熟悉的三次握手。它大概可以用以下过程来描述：</p><ol><li><p>发送 SYN 段（建立连接）<br>TCPSender 发送 SYN 段（序列号为 isn），无数据负载。</p></li><li><p>接收 SYN-ACK 确认<br>接收方确认 SYN，ACK 号为 isn+1（表示期望下一个字节是 isn+1）。窗口大小设为 1000，允许发送方传输数据。</p></li></ol><p>对应代码为：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>ExpectSegment<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">with_no_flags</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">with_syn</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">with_payload_size</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">with_seqno</span><span class="token punctuation">(</span>isn<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>AckReceived<span class="token punctuation">&#123;</span>WrappingInt32<span class="token punctuation">&#123;</span>isn <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">with_win</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>ExpectState<span class="token punctuation">&#123;</span>TCPSenderStateSummary<span class="token double-colon punctuation">::</span>SYN_ACKED<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="2-3-3-情况-1"><a href="#2-3-3-情况-1" class="headerlink" title="2.3.3 情况 1"></a>2.3.3 情况 1</h4><p>过程描述：<br>验证当 TCPSender 已启动且定时器在运行时，发送新数据段是否会干扰现有定时器。<br>根据测试名称，正确行为是：定时器应继续运行，不会被新发送的段重置，从而保证超时重传的可靠性。</p><p>详细过程：<br>(从初始情况开始)</p><ol><li><p>写入数据 <code>&quot;abc&quot;</code> 并发送</p><ul><li>将 <code>&quot;abc&quot;</code> 写入发送缓冲区。</li><li>发送数据段，序列号为 <code>isn + 1</code>，负载为 3 字节的 <code>&quot;abc&quot;</code>。此时启动重传定时器（RTO 初始值）。</li></ul></li><li><p>时间流逝</p><ul><li>时间流逝 <code>RTO - 5</code> 个时间单位，未触发超时。</li><li>确认没有重传发生，即没有新的数据段被发送。</li></ul></li><li><p>写入新数据 <code>&quot;def&quot;</code> 并发送</p><ul><li>将 <code>&quot;def&quot;</code> 写入发送缓冲区。</li><li>发送新数据段 <code>&quot;def&quot;</code>，序列号从 <code>isn + 1 + 3</code> 开始（这里代码未显式体现序列号，默认按照顺序）。<strong>新数据发送后，原有定时器仍在运行，未被重置。</strong></li></ul></li><li><p>时间流逝</p><ul><li>时间流逝 200 个时间单位，假设 <code>RTO - 5 + 200 &gt; RTO</code>，超过 RTO 触发超时。</li><li>重传最早的未确认段 <code>&quot;abc&quot;</code>，序列号为 <code>isn + 1</code>，证明定时器未被新数据段重置。</li><li>确认没有其他段被发送（如 <code>&quot;def&quot;</code> 尚未超时）。</li></ul></li></ol><p>关键结论：</p><ul><li><strong>定时器独立性</strong>：TCPSender 在发送新数据时，不会重置已有的重传定时器。定时器始终跟踪最早未确认的段（此处为 “abc”）。</li><li><strong>重传优先级</strong>：超时后优先重传最早的未确认数据，确保可靠性，避免旧数据丢失导致传输中断。</li><li><strong>窗口管理与多段处理</strong>：新数据 “def” 在窗口允许下被发送，但其确认与否不影响 “abc” 的定时器逻辑。</li></ul><h4 id="2-3-2-情况-2"><a href="#2-3-2-情况-2" class="headerlink" title="2.3.2 情况 2"></a>2.3.2 情况 2</h4><p><strong>过程描述</strong>：验证 <code>fill_window()</code> 方法是否能正确填充一个较大的窗口。根据测试名称，正确行为是：<code>fill_window()</code> 方法应根据窗口大小和数据量，合理地将数据分段发送，确保每个数据段的大小符合配置要求，且序列号连续，以充分利用窗口空间。</p><p>这个过程比较清晰的描述了一次 <code>fill_window()</code> 最大可发送量为：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> size_t expected_size <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>TCPConfig<span class="token double-colon punctuation">::</span>MAX_PAYLOAD_SIZE<span class="token punctuation">,</span> <span class="token function">min</span><span class="token punctuation">(</span>bigstring<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> window_size<span class="token punctuation">)</span> <span class="token operator">-</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>假设此时发送端缓冲区很长，超出 expected_size 的部分仍然不能发送。</p><p><strong>详细过程</strong>：<br>(从初始情况开始)</p><ol><li><strong>循环发送数据段</strong>：<ul><li>开始一个循环，循环条件是 <code>i + TCPConfig::MAX_PAYLOAD_SIZE &lt; min(bigstring.size(), window_size)</code>，其中 <code>i</code> 是当前已经处理的数据偏移量。</li><li>在每次循环中，计算期望的数据段大小 <code>expected_size</code>，取 <code>TCPConfig::MAX_PAYLOAD_SIZE</code> 和剩余可发送数据量（<code>min(bigstring.size(), window_size) - i</code>）中的较小值。</li><li>发送一个数据段，该数据段没有额外标志，负载大小为 <code>expected_size</code>，数据为 <code>bigstring</code> 从偏移量 <code>i</code> 开始长度为 <code>expected_size</code> 的子串，序列号为 <code>isn + 1 + i</code>。</li></ul></li></ol><p><strong>关键结论</strong>：</p><ul><li><strong>窗口填充正确性</strong>：<code>fill_window()</code> 方法能够根据窗口大小和数据量，正确地将数据分段发送，确保每个数据段的大小不超过配置的最大负载大小，充分利用了窗口空间。</li><li><strong>序列号连续性</strong>：每个数据段的序列号是连续的，保证了接收方能够正确地按顺序接收和重组数据，维护了数据传输的有序性。</li><li><strong>数据完整性</strong>：通过循环发送数据段，将整个 <code>bigstring</code> 数据按要求分段发送，确保了数据的完整性，避免了数据丢失或错误传输。</li></ul><h4 id="2-3-3-情况-3"><a href="#2-3-3-情况-3" class="headerlink" title="2.3.3 情况 3"></a>2.3.3 情况 3</h4><p>一句话：FIN 和 SYN 标志位都同样需要重传机制。含有 FIN 标志位的 segment 中，无论是否携带了其它数据，也都需要有重传机制。</p><p><strong>过程描述</strong>：验证包含 FIN 标志的数据段是否能像其他数据段一样进行重传。根据测试名称，正确行为是：当包含 FIN 标志的数据段未被确认且超时发生时，应像普通数据段一样进行重传，以确保连接的正常关闭。</p><p><strong>详细过程</strong>：<br>(从初始情况开始)</p><ol><li><strong>写入数据并发送含 FIN 的数据段</strong>：<ul><li>将 <code>&quot;abc&quot;</code> 写入发送缓冲区，并标记输入结束（<code>with_end_input(true)</code>）。</li><li>发送一个数据段，负载为 3 字节的 <code>&quot;abc&quot;</code>，序列号为 <code>isn + 1</code>，同时带有 FIN 标志，表示连接关闭请求。</li></ul></li><li><strong>时间流逝（未触发超时）</strong>：<ul><li>时间流逝 <code>RTO - 1</code> 个时间单位，未触发超时。</li><li>确认没有重传发生，即没有新的数据段被发送。</li></ul></li><li><strong>时间继续流逝（触发超时）</strong>：<ul><li>时间再流逝 2 个时间单位，此时总时间超过了 RTO，触发超时。</li><li>重传之前带有 FIN 标志的数据段，负载为 3 字节的 <code>&quot;abc&quot;</code>，序列号为 <code>isn + 1</code>，FIN 标志保持为 <code>true</code>。</li></ul></li></ol><p><strong>关键结论</strong>：</p><ul><li><strong>FIN 段重传机制</strong>：包含 FIN 标志的数据段在未被确认且超时发生时，会像普通数据段一样进行重传。这确保了即使在连接关闭阶段，数据的可靠传输也能得到保障。</li><li><strong>可靠性保障</strong>：通过重传 FIN 段，保证了连接关闭请求能够被接收方正确收到，避免因丢包导致连接无法正常关闭，维护了 TCP 连接的可靠性。</li><li><strong>定时器一致性</strong>：对包含 FIN 标志的数据段使用与普通数据段相同的定时器和重传逻辑，体现了 TCPSender 重传机制的一致性和稳定性。</li></ul><h4 id="2-3-4-情况-4"><a href="#2-3-4-情况-4" class="headerlink" title="2.3.4 情况 4"></a>2.3.4 情况 4</h4><p>什么情况下需要添加 FIN 标志位？</p><p><strong>过程描述</strong>：<br>验证在发送数据段时，如果添加 FIN 标志会使数据段超出接收方窗口大小，是否不会添加 FIN 标志。根据测试名称，正确行为是：当添加 FIN 标志会导致数据段大小超过接收方窗口时，不添加 FIN 标志，直到窗口大小足够容纳含 FIN 标志的数据段。<br>验证当接收方窗口已满时，是否不会单独发送仅含 FIN 标志的数据段。根据测试名称，正确行为是：在窗口空间不足的情况下，不会单独发送 FIN 段，直到窗口有足够空间，以保证数据传输的合理性和可靠性。</p><p><strong>详细过程 1</strong>：<br>(从初始情况开始)</p><ol><li><strong>写入数据并准备关闭连接</strong>：<ul><li>将 <code>&quot;abc&quot;</code> 写入发送缓冲区，并标记输入结束（<code>with_end_input(true)</code>），表示有关闭连接的需求（即要添加 FIN 标志）。</li></ul></li><li><strong>接收 ACK 并发送普通数据段</strong>：<ul><li>模拟接收到对 SYN 段的 ACK，确认号为 <code>isn + 1</code>，窗口大小为 3。</li><li>发送一个数据段，负载为 3 字节的 <code>&quot;abc&quot;</code>，序列号为 <code>isn + 1</code>，无 FIN 标志，因为此时添加 FIN 可能会使数据段超出窗口大小。</li></ul></li><li><strong>多次接收 ACK 但不发送新段</strong>：<ul><li>模拟接收到确认号为 <code>isn + 2</code>，窗口大小为 2 的 ACK，此时窗口大小不足以添加 FIN 标志，确认没有新的数据段被发送。</li><li>模拟接收到确认号为 <code>isn + 3</code>，窗口大小为 1 的 ACK，同样窗口大小不够，确认没有新的数据段被发送。</li></ul></li><li><strong>接收合适 ACK 并发送含 FIN 段</strong>：<ul><li>模拟接收到确认号为 <code>isn + 4</code>，窗口大小为 1 的 ACK，此时窗口大小足够容纳一个仅含 FIN 标志（无数据负载）的数据段。</li><li>发送一个仅含 FIN 标志、无数据负载的数据段，序列号为 <code>isn + 4</code>。</li></ul></li></ol><p><strong>详细过程 2</strong>：<br>(从初始情况开始)</p><ol><li><strong>写入数据但不发送</strong>：<ul><li>将 <code>&quot;abc&quot;</code> 写入发送缓冲区，但由于此时还未收到合适的 ACK 来确定窗口大小，所以没有数据段被发送。</li></ul></li><li><strong>接收 ACK 并发送普通数据段</strong>：<ul><li>模拟接收到对 SYN 段的 ACK，确认号为 <code>isn + 1</code>，窗口大小为 3。</li><li>检查 TCPSender 状态，期望状态为 <code>SYN_ACKED</code>。</li><li>发送一个数据段，负载为 3 字节的 <code>&quot;abc&quot;</code>，序列号为 <code>isn + 1</code>，无特殊标志。</li></ul></li><li><strong>请求关闭连接但不发送 FIN 段</strong>：<ul><li>调用 <code>Close</code> 操作，表示要关闭连接，即需要发送含 FIN 标志的数据段。</li><li>但由于此时窗口空间可能不足以单独发送 FIN 段，确认没有新的数据段被发送。</li></ul></li><li><strong>多次接收 ACK 仍不发送 FIN 段</strong>：<ul><li>模拟接收到确认号为 <code>isn + 2</code>，窗口大小为 2 的 ACK，窗口空间仍不足，确认没有新的数据段被发送。</li><li>模拟接收到确认号为 <code>isn + 3</code>，窗口大小为 1 的 ACK，窗口空间还是不足，确认没有新的数据段被发送。</li></ul></li><li><strong>接收合适 ACK 并发送含 FIN 段</strong>：<ul><li>模拟接收到确认号为 <code>isn + 4</code>，窗口大小为 1 的 ACK，此时窗口有足够空间容纳一个仅含 FIN 标志（无数据负载）的数据段。</li><li>发送一个仅含 FIN 标志、无数据负载的数据段，序列号为 <code>isn + 4</code>。</li></ul></li></ol><p><strong>关键结论</strong>：</p><ul><li><strong>窗口限制机制</strong>：TCPSender 会根据接收方的窗口大小来决定是否添加 FIN 标志。当添加 FIN 会使数据段超出窗口大小时，会等待窗口大小足够，体现了窗口管理对数据段发送的限制作用。</li><li><strong>窗口限制下的 FIN 发送策略</strong>：TCPSender 会根据接收方的窗口大小来决定是否单独发送 FIN 段。当窗口已满或空间不足时，不会单独发送 FIN 段，避免不必要的数据段发送，体现了窗口管理对数据传输的控制作用。</li><li><strong>可靠性与效率平衡</strong>：通过不添加 FIN 避免数据段溢出窗口，保证了数据传输的可靠性，同时在窗口允许时及时发送含 FIN 段，实现了连接关闭的高效性。</li><li><strong>ACK 与窗口管理协同</strong>：ACK 的接收不仅更新了确认号，还影响了窗口大小，从而决定了数据段的发送策略，体现了 ACK 处理与窗口管理的协同工作。</li></ul><h4 id="2-3-5-情况-5"><a href="#2-3-5-情况-5" class="headerlink" title="2.3.5 情况 5"></a>2.3.5 情况 5</h4><p><code>TCPConfig::MAX_PAYLOAD_SIZE</code> 仅对数据段的负载部分起限制作用，SYN 和 FIN 标志不受此限制。以确保数据段的正常发送和连接的正确关闭。</p><p><strong>过程描述</strong>：验证 <code>MAX_PAYLOAD_SIZE</code> 仅对数据段的负载部分起限制作用。根据测试名称，正确行为是：在发送数据段时，数据段的负载大小应受 <code>MAX_PAYLOAD_SIZE</code> 限制，但其他标志（如 FIN 标志）不受此限制，以确保数据段的正常发送和连接的正确关闭。</p><p><strong>详细过程</strong>：<br>(从初始情况开始)</p><ol><li><strong>写入大量数据并准备关闭连接</strong>：<ul><li>将一个较大的字符串 <code>bigstring</code> 写入发送缓冲区，并标记输入结束（<code>with_end_input(true)</code>），表示要关闭连接（添加 FIN 标志）。</li></ul></li><li><strong>接收 ACK 并发送数据段</strong>：<ul><li>模拟接收到对 SYN 段的 ACK，确认号为 <code>isn + 1</code>，窗口大小为 40000。</li><li>发送一个数据段，负载大小为 <code>TCPConfig::MAX_PAYLOAD_SIZE</code>，数据为 <code>bigstring</code>，序列号为 <code>isn + 1</code>，同时带有 FIN 标志。这表明即使数据量较大，但负载大小被 <code>MAX_PAYLOAD_SIZE</code> 限制，而 FIN 标志正常添加。</li></ul></li><li><strong>检查状态</strong>：<ul><li>检查 TCPSender 状态，期望状态为 <code>FIN_SENT</code>，确认包含 FIN 标志的数据段已成功发送。</li></ul></li><li><strong>接收 ACK 并再次检查状态</strong>：<ul><li>模拟接收到确认号为 <code>isn + 2 + TCPConfig::MAX_PAYLOAD_SIZE</code> 的 ACK。</li><li>检查 TCPSender 状态，期望状态为 <code>FIN_ACKED</code>，确认包含 FIN 标志的数据段已被正确确认，连接关闭流程正常完成。</li></ul></li></ol><p><strong>关键结论</strong>：</p><ul><li><strong><code>MAX_PAYLOAD_SIZE</code> 限制作用</strong>：<code>MAX_PAYLOAD_SIZE</code> 仅对数据段的负载部分起限制作用，确保负载大小不会超过设定值，维护了数据段的合理大小。</li><li><strong>标志独立性</strong>：FIN 标志等控制标志不受 <code>MAX_PAYLOAD_SIZE</code> 的限制，可以正常添加到数据段中，保证了连接关闭等控制功能的正常实现。</li><li><strong>状态转换正确性</strong>：通过正确的 ACK 接收和状态检查，验证了 TCPSender 在发送和确认含 FIN 标志数据段过程中的状态转换是正确的，确保了连接管理的可靠性。</li></ul><h4 id="2-3-6-情况-6"><a href="#2-3-6-情况-6" class="headerlink" title="2.3.6 情况 6"></a>2.3.6 情况 6</h4><p>验证在填充窗口时，将窗口大小为 <code>0</code> 的情况视为窗口大小为 <code>1</code> 进行处理。</p><p><strong>过程描述</strong>：验证在填充窗口时，将窗口大小为 <code>0</code> 的情况视为窗口大小为 <code>1</code> 进行处理，同时不进行重传超时时间（RTO）的回退操作。根据测试名称，正确行为是：当窗口大小为 <code>0</code> 时，仍能按顺序发送数据段，且每次超时后重传未确认的数据段，RTO 保持不变。</p><p>但是，非 0 窗口则需要严格限制，一旦 flight 中的 data 容量大于窗口容量，这个时候必须处于停止发送的状态中。</p><p><strong>详细过程</strong>：<br>(从初始情况开始)</p><ol><li><strong>接收窗口大小为 0 的 ACK 并发送数据段</strong>：<ul><li>模拟接收到对 SYN 段的 ACK，确认号为 <code>isn + 1</code>，窗口大小为 <code>0</code>。</li><li>检查 TCPSender 状态，期望状态为 <code>SYN_ACKED</code>。</li><li>发送一个负载大小为 1 字节、数据为 <code>&quot;a&quot;</code>、序列号为 <code>isn + 1</code> 的数据段，无其他特殊标志，体现了将窗口大小 <code>0</code> 视为 <code>1</code> 来发送数据。</li></ul></li><li><strong>请求关闭连接但不发送新段</strong>：<ul><li>调用 <code>Close</code> 操作，表示要关闭连接，但由于窗口大小限制，此时没有新的数据段被发送。</li></ul></li><li><strong>对 <code>&quot;a&quot;</code> 数据段进行多次超时重传</strong>：<ul><li>进行 5 次循环，每次先让时间流逝 <code>RTO - 1</code> 个时间单位，期间没有数据段发送。</li><li>再让时间流逝 1 个时间单位，触发超时，重传负载为 <code>&quot;a&quot;</code>、序列号为 <code>isn + 1</code> 的数据段，且每次重传的 RTO 没有回退。</li></ul></li><li><strong>接收新 ACK 并发送 <code>&quot;b&quot;</code> 数据段及重传</strong>：<ul><li>模拟接收到确认号为 <code>isn + 2</code>、窗口大小为 <code>0</code> 的 ACK。</li><li>发送一个负载大小为 1 字节、数据为 <code>&quot;b&quot;</code>、序列号为 <code>isn + 2</code> 的数据段。</li><li>同样进行 5 次循环，每次先让时间流逝 <code>RTO - 1</code> 个时间单位，无数据段发送，再流逝 1 个时间单位触发超时，重传 <code>&quot;b&quot;</code> 数据段，RTO 保持不变。</li></ul></li><li><strong>接收新 ACK 并发送 <code>&quot;c&quot;</code> 数据段及重传</strong>：<ul><li>模拟接收到确认号为 <code>isn + 3</code>、窗口大小为 <code>0</code> 的 ACK。</li><li>发送一个负载大小为 1 字节、数据为 <code>&quot;c&quot;</code>、序列号为 <code>isn + 3</code> 的数据段。</li><li>进行 5 次循环，每次先让时间流逝 <code>RTO - 1</code> 个时间单位，无数据段发送，再流逝 1 个时间单位触发超时，重传 <code>&quot;c&quot;</code> 数据段，RTO 不回退。</li></ul></li><li><strong>接收新 ACK 并发送含 FIN 段及重传</strong>：<ul><li>模拟接收到确认号为 <code>isn + 4</code>、窗口大小为 <code>0</code> 的 ACK。</li><li>发送一个负载大小为 0 字节、序列号为 <code>isn + 4</code>、带有 FIN 标志的数据段。</li><li>进行 5 次循环，每次先让时间流逝 <code>RTO - 1</code> 个时间单位，无数据段发送，再流逝 1 个时间单位触发超时，重传含 FIN 标志的数据段，RTO 保持不变。</li></ul></li></ol><p><strong>关键结论</strong>：</p><ul><li><strong>窗口大小处理策略</strong>：当接收方窗口大小为 <code>0</code> 时，TCPSender 将其视为窗口大小为 <code>1</code> 来处理，能够按顺序发送数据段，保证了数据的持续传输。</li><li><strong>RTO 稳定性</strong>：在多次超时重传过程中，RTO 没有进行回退操作，保持了定时器的稳定性，确保了重传机制的可靠性。</li><li><strong>数据和控制信息传输</strong>：无论是普通数据段（如 <code>&quot;a&quot;</code>、<code>&quot;b&quot;</code>、<code>&quot;c&quot;</code>）还是含 FIN 标志的控制数据段，都能在窗口大小为 <code>0</code> 的情况下正常发送和重传，保证了数据和连接管理的正常进行。</li></ul><h4 id="2-3-7-情况-7"><a href="#2-3-7-情况-7" class="headerlink" title="2.3.7 情况 7"></a>2.3.7 情况 7</h4><p><strong>过程描述</strong>：验证重复的 ACK 和过时的 ACK 对 TCPSender 的正常工作没有影响。根据测试名称，正确行为是：发送方在接收到重复或过时的 ACK 时，不会产生异常行为，仍能按照正常逻辑处理数据发送和连接关闭操作。</p><p><strong>详细过程</strong>：<br>(从初始情况开始)</p><ol><li><strong>写入数据并发送数据段</strong>：<ul><li>将 <code>&quot;abcdefg&quot;</code> 写入发送缓冲区。</li><li>发送一个负载大小为 7 字节、数据为 <code>&quot;abcdefg&quot;</code>、序列号为 <code>isn + 1</code> 的数据段。</li></ul></li><li><strong>接收正确 ACK 及重复 ACK</strong>：<ul><li>模拟接收到确认号为 <code>isn + 8</code> 的 ACK，窗口大小为 1000，表明 <code>&quot;abcdefg&quot;</code> 已被正确接收。</li><li>多次重复接收确认号为 <code>isn + 8</code> 的 ACK，期间没有新的数据段被发送，确认重复 ACK 不影响发送方。</li></ul></li><li><strong>接收过时 ACK</strong>：<ul><li>多次接收确认号为 <code>isn + 1</code> 的过时 ACK，没有新的数据段被发送，说明过时 ACK 不会干扰发送方的正常状态。</li></ul></li><li><strong>写入新数据并发送含 FIN 段</strong>：<ul><li>将 <code>&quot;ijkl&quot;</code> 写入发送缓冲区，并标记输入结束（<code>with_end_input(true)</code>）。</li><li>发送一个负载大小为 4 字节、数据为 <code>&quot;ijkl&quot;</code>、序列号为 <code>isn + 8</code> 且带有 FIN 标志的数据段。</li></ul></li><li><strong>多次接收各种 ACK</strong>：<ul><li>多次接收确认号为 <code>isn + 1</code>、<code>isn + 8</code>、<code>isn + 12</code> 的 ACK，包括重复和过时的 ACK，发送方未产生异常。</li></ul></li><li><strong>超时重传</strong>：<ul><li>时间流逝 <code>5 * RTO</code>，触发超时，重传负载为 <code>&quot;ijkl&quot;</code>、序列号为 <code>isn + 8</code> 且带有 FIN 标志的数据段。</li><li>之后确认没有新的数据段被发送。</li></ul></li><li><strong>接收最终 ACK 并检查状态</strong>：<ul><li>模拟接收到确认号为 <code>isn + 13</code> 的 ACK，以及再次接收确认号为 <code>isn + 1</code> 的过时 ACK。</li><li>时间流逝 <code>5 * RTO</code>，没有新的数据段被发送。</li><li>检查 TCPSender 状态，期望状态为 <code>FIN_ACKED</code>，确认连接正常关闭。</li></ul></li></ol><blockquote><p>多次接收确认号为 <code>isn + 1</code>、<code>isn + 8</code>、<code>isn + 12</code> 的 ACK，包括重复和过时的 ACK，发送方未产生异常。如何验证？</p></blockquote><ol><li>多次接收确认号为 <code>isn + 8</code> 的 ACK 时的验证</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>AckReceived<span class="token punctuation">&#123;</span>WrappingInt32<span class="token punctuation">&#123;</span>isn <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">with_win</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>ExpectNoSegment<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>AckReceived<span class="token punctuation">&#123;</span>WrappingInt32<span class="token punctuation">&#123;</span>isn <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">with_win</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>AckReceived<span class="token punctuation">&#123;</span>WrappingInt32<span class="token punctuation">&#123;</span>isn <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">with_win</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>AckReceived<span class="token punctuation">&#123;</span>WrappingInt32<span class="token punctuation">&#123;</span>isn <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">with_win</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>ExpectNoSegment<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里先接收了一次确认号为 <code>isn + 8</code> 的 ACK，然后使用 <code>ExpectNoSegment&#123;&#125;</code> 确认没有新的数据段被发送。之后又多次接收确认号为 <code>isn + 8</code> 的 ACK，最后再次使用 <code>ExpectNoSegment&#123;&#125;</code> 确认在这一系列重复 ACK 接收过程中没有异常的数据段发送。</p><ol start="2"><li>多次接收确认号为 <code>isn + 1</code> 的 ACK 时的验证</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>AckReceived<span class="token punctuation">&#123;</span>WrappingInt32<span class="token punctuation">&#123;</span>isn <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">with_win</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>AckReceived<span class="token punctuation">&#123;</span>WrappingInt32<span class="token punctuation">&#123;</span>isn <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">with_win</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>AckReceived<span class="token punctuation">&#123;</span>WrappingInt32<span class="token punctuation">&#123;</span>isn <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">with_win</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>ExpectNoSegment<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这里多次接收确认号为 <code>isn + 1</code> 的过时 ACK，最后使用 <code>ExpectNoSegment&#123;&#125;</code> 确认在接收这些过时 ACK 期间没有异常的数据段发送。</p><ol start="3"><li>后续多次接收不同 ACK 时的验证</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>AckReceived<span class="token punctuation">&#123;</span>WrappingInt32<span class="token punctuation">&#123;</span>isn <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">with_win</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>AckReceived<span class="token punctuation">&#123;</span>WrappingInt32<span class="token punctuation">&#123;</span>isn <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">with_win</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>AckReceived<span class="token punctuation">&#123;</span>WrappingInt32<span class="token punctuation">&#123;</span>isn <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">with_win</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>AckReceived<span class="token punctuation">&#123;</span>WrappingInt32<span class="token punctuation">&#123;</span>isn <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">with_win</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>AckReceived<span class="token punctuation">&#123;</span>WrappingInt32<span class="token punctuation">&#123;</span>isn <span class="token operator">+</span> <span class="token number">12</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">with_win</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>AckReceived<span class="token punctuation">&#123;</span>WrappingInt32<span class="token punctuation">&#123;</span>isn <span class="token operator">+</span> <span class="token number">12</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">with_win</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>AckReceived<span class="token punctuation">&#123;</span>WrappingInt32<span class="token punctuation">&#123;</span>isn <span class="token operator">+</span> <span class="token number">12</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">with_win</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>AckReceived<span class="token punctuation">&#123;</span>WrappingInt32<span class="token punctuation">&#123;</span>isn <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">with_win</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 这里虽然没有紧跟 ExpectNoSegment&#123;&#125;，但后续通过超时重传等操作的正常执行也侧面验证没有异常</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这一系列多次接收不同确认号（包括重复和过时的）的 ACK 过程中，后续代码里的超时重传等操作正常执行，也从侧面验证了发送方在接收这些 ACK 时没有产生异常。例如后续的超时重传：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>Tick<span class="token punctuation">&#123;</span><span class="token number">5</span> <span class="token operator">*</span> rto<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>ExpectSegment<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">with_payload_size</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">with_data</span><span class="token punctuation">(</span><span class="token string">"ijkl"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">with_seqno</span><span class="token punctuation">(</span>isn <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">with_fin</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
test<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>ExpectNoSegment<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果在接收那些 ACK 时发送方产生了异常，这里的超时重传可能就无法正常执行。</p><p>综上所述，通过 <code>ExpectNoSegment&#123;&#125;</code> 以及后续操作的正常执行，验证了发送方在接收多次 ACK（包括重复和过时的 ACK）时未产生异常。</p><p><strong>关键结论</strong>：</p><ul><li><strong>ACK 处理的健壮性</strong>：TCPSender 能够正确处理重复的 ACK 和过时的 ACK，不会因为这些异常 ACK 而产生错误的行为，保证了系统的健壮性。</li><li><strong>重传机制正常</strong>：在超时情况下，发送方能够正常重传未确认的数据段，确保了数据传输的可靠性。</li><li><strong>连接关闭正常</strong>：即使在接收到各种异常 ACK 的情况下，发送方仍能正确处理连接关闭请求，最终达到 <code>FIN_ACKED</code> 状态，完成连接的正常关闭。</li></ul><h3 id="2-4-具体实现"><a href="#2-4-具体实现" class="headerlink" title="2.4 具体实现"></a>2.4 具体实现</h3><p>我的具体实现基本上借鉴了大佬的实现… 所以思路看上去很像那确实是我太菜了。</p><p><code>fill_window()</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">TCPSender</span><span class="token double-colon punctuation">::</span><span class="token function">fill_window</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-></span>_has_set_fin_flag<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 为防止死锁，发送数据的时候即便对面窗口为 0，也至少发送 1 单位的数据</span>
    <span class="token keyword">auto</span> window_size <span class="token operator">=</span> <span class="token generic-function"><span class="token function">max</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">uint16_t</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token operator">-></span>_window_size<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 只要还有「预订要发送」但是这些数据还没填满 Receiver 窗口的空间，就从 _stream 中读取数据，然后发出去</span>
    <span class="token comment">// 要读取到的数据需要充分考虑到 window_size，然后有选择性的读取数据的长度</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-></span><span class="token function">bytes_in_flight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> window_size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        TCPSegment segment_to_send<span class="token punctuation">;</span>

        <span class="token comment">// 给 segment_to_send 添加 seqno</span>
        segment_to_send<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>seqno <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-></span><span class="token function">next_seqno</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token operator">-></span>_has_set_syn_flag<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            segment_to_send<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>syn <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token operator">-></span>_has_set_syn_flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token comment">// MAX_PAYLOAD_SIZE 只限制字符串长度并不包括 SYN 和 FIN，但是 window_size 包括 SYN 和 FIN</span>
        <span class="token keyword">auto</span> payload_size <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>TCPConfig<span class="token double-colon punctuation">::</span>MAX_PAYLOAD_SIZE<span class="token punctuation">,</span>
                                <span class="token function">min</span><span class="token punctuation">(</span>window_size <span class="token operator">-</span> <span class="token keyword">this</span><span class="token operator">-></span><span class="token function">bytes_in_flight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> segment_to_send<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>syn<span class="token punctuation">,</span>
                                    <span class="token keyword">this</span><span class="token operator">-></span>_stream<span class="token punctuation">.</span><span class="token function">buffer_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 数据是从 _stream 中读取的</span>
        <span class="token keyword">auto</span> payload <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-></span>_stream<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>payload_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
        segment_to_send<span class="token punctuation">.</span><span class="token function">payload</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">string</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 如果读到 EOF 了且 window_size 还有空位，那就把 fin 给放进去</span>
        <span class="token comment">// 注意这里有一个细节，那就是这里不需要检查 TCPConfig::MAX_PAYLOAD_SIZE，因为即便是它满了，那也可以放入 FIN</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token operator">-></span>_has_set_fin_flag <span class="token operator">&amp;&amp;</span> _stream<span class="token punctuation">.</span><span class="token function">eof</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
            <span class="token keyword">this</span><span class="token operator">-></span><span class="token function">bytes_in_flight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> segment_to_send<span class="token punctuation">.</span><span class="token function">length_in_sequence_space</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> window_size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            segment_to_send<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>fin <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token operator">-></span>_has_set_fin_flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token comment">// payload_true_size 包含了 fin 和 syn 后的大小</span>
        <span class="token keyword">uint64_t</span> payload_true_size <span class="token operator">=</span> segment_to_send<span class="token punctuation">.</span><span class="token function">length_in_sequence_space</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 空数据报就不发送了</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>payload_true_size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token comment">// 发送数据，segments_out 中的数据被发送出去是调用者做的事情，Sender 无需关心</span>
        <span class="token keyword">this</span><span class="token operator">-></span><span class="token function">segments_out</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>segment_to_send<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 如果定时器关闭，则启动定时器</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token operator">-></span>_timer<span class="token punctuation">.</span><span class="token function">is_running</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">this</span><span class="token operator">-></span>_timer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token comment">// 保存备份，重发时可能会用</span>
        <span class="token keyword">this</span><span class="token operator">-></span>_outstanding_seg<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-></span>_next_seqno<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>segment_to_send<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 更新序列号和发出但未 ACK 的字节数</span>
        <span class="token keyword">this</span><span class="token operator">-></span>_next_seqno <span class="token operator">+=</span> payload_true_size<span class="token punctuation">;</span>  <span class="token comment">// _next_seqno 是 absolute seqno</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>ack_received()</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">TCPSender</span><span class="token double-colon punctuation">::</span><span class="token function">ack_received</span><span class="token punctuation">(</span><span class="token keyword">const</span> WrappingInt32 ackno<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">uint16_t</span> window_size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 和接收方原理一样，checkpoint 为 next_seqno_absolute</span>
    <span class="token keyword">auto</span> abs_ackno <span class="token operator">=</span> <span class="token function">unwrap</span><span class="token punctuation">(</span>ackno<span class="token punctuation">,</span> _isn<span class="token punctuation">,</span> <span class="token function">next_seqno_absolute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 传入的 ACK 是不可靠的，直接丢弃</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>abs_ackno <span class="token operator">></span> <span class="token keyword">this</span><span class="token operator">-></span><span class="token function">next_seqno_absolute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 在接受到 ack 的时候如果收到窗口为 0，窗口大小发送方仍将其视为 1，允许发送 1 字节的数据。</span>
    <span class="token comment">// 但是这个时候，未采用 TCP 标准的 指数退避策略（即 RTO 不翻倍）</span>
    <span class="token keyword">this</span><span class="token operator">-></span>_window_size <span class="token operator">=</span> window_size<span class="token punctuation">;</span>

    <span class="token comment">// 用于标记是否有 segment 是否成功</span>
    <span class="token keyword">bool</span> some_seg_ack_successful <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token comment">// 处理已经收到的包（序列号空间要小于 ACK）</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token operator">-></span>_outstanding_seg<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">auto</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span>abs_seq<span class="token punctuation">,</span> segment<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-></span>_outstanding_seg<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>abs_seq <span class="token operator">+</span> segment<span class="token punctuation">.</span><span class="token function">length_in_sequence_space</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&lt;</span> abs_ackno<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            some_seg_ack_successful <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token operator">-></span>_acked_seqno <span class="token operator">+=</span> segment<span class="token punctuation">.</span><span class="token function">length_in_sequence_space</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token operator">-></span>_outstanding_seg<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 有成功 ACK 的包，则重置定时器（触发 RTO），清零连续重传次数</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>some_seg_ack_successful<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">this</span><span class="token operator">-></span>_consecutive_retransmissions_count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token operator">-></span>_timer<span class="token punctuation">.</span><span class="token function">set_time_out</span><span class="token punctuation">(</span>_initial_retransmission_timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token operator">-></span>_timer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 没有等待 ACK 的包了，则关闭定时器</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-></span><span class="token function">bytes_in_flight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">this</span><span class="token operator">-></span>_timer<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 尝试继续填满窗口发送</span>
    <span class="token function">fill_window</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Timer 类则是完全照搬，这里不再做赘述。</p></div><hr><div class="reprint" id="reprint-statement"><div class="reprint__author"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-user">文章作者: </i></span><span class="reprint-info"><a href="/about" rel="external nofollow noreferrer">海星来来</a></span></div><div class="reprint__type"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-link">文章链接: </i></span><span class="reprint-info"><a href="https://blog.pengdonglai.com/2025/02/15/stanford-cs144-2/">https://blog.pengdonglai.com/2025/02/15/stanford-cs144-2/</a></span></div><div class="reprint__notice"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-copyright">版权声明: </i></span><span class="reprint-info">本博客所有文章除特別声明外，均采用 <a href="https://creativecommons.org/licenses/by/4.0/deed.zh-hans" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a> 许可协议。转载请注明来源 <a href="/about" target="_blank">海星来来</a> !</span></div></div><script async defer>document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }</script><div class="tag_share" style="display:block"><div class="post-meta__tag-list" style="display:inline-block"><div class="article-tag"><a href="/tags/Network/"><span class="chip bg-color">Network</span> </a><a href="/tags/Lab/"><span class="chip bg-color">Lab</span></a></div></div><div class="post_share" style="zoom:80%;width:fit-content;display:inline-block;float:right;margin:-.15rem 0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/libs/share/css/share.min.css"><div id="article-share"><div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div><script src="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/libs/share/js/social-share.min.js"></script></div></div></div></div></div><article id="prenext-posts" class="prev-next articles"><div class="row article-row"><div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up"><div class="article-badge left-badge text-color"><i class="far fa-dot-circle"></i>&nbsp;本篇</div><div class="card"><a href="/2025/02/15/stanford-cs144-2/"><div class="card-image"><img src="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/medias/featureimages/23.webp" class="responsive-img" alt="CS144 Lab（2）：TCP 的发送和接收"> <span class="card-title">CS144 Lab（2）：TCP 的发送和接收</span></div></a><div class="card-content article-content"><div class="summary block-with-text">上班了还在做 lab，没事找事，太典了。</div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i>2025-02-15 </span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/%E8%A3%85%E9%80%BC/" class="post-category">装逼 </a><a href="/categories/%E8%A3%85%E9%80%BC/CS144/" class="post-category">CS144</a></span></div></div><div class="card-action article-tags"><a href="/tags/Network/"><span class="chip bg-color">Network</span> </a><a href="/tags/Lab/"><span class="chip bg-color">Lab</span></a></div></div></div><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge right-badge text-color">下一篇&nbsp;<i class="fas fa-chevron-right"></i></div><div class="card"><a href="/2025/02/04/stanford-cs144/"><div class="card-image"><img src="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/medias/featureimages/1.webp" class="responsive-img" alt="CS144 Lab（1）：启动"> <span class="card-title">CS144 Lab（1）：启动</span></div></a><div class="card-content article-content"><div class="summary block-with-text">上班了还在做 lab，没事找事，太典了。</div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i>2025-02-04 </span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/%E8%A3%85%E9%80%BC/" class="post-category">装逼 </a><a href="/categories/%E8%A3%85%E9%80%BC/CS144/" class="post-category">CS144</a></span></div></div><div class="card-action article-tags"><a href="/tags/Network/"><span class="chip bg-color">Network</span> </a><a href="/tags/Lab/"><span class="chip bg-color">Lab</span></a></div></div></div></div></article></div><script>$("#articleContent").on("copy",function(e){var n,t,o,i;void 0!==window.getSelection&&((""+(n=window.getSelection())).length<Number.parseInt("80")||(t=document.getElementsByTagName("body")[0],(o=document.createElement("div")).style.position="absolute",o.style.left="-99999px",t.appendChild(o),o.appendChild(n.getRangeAt(0).cloneContents()),"PRE"===n.getRangeAt(0).commonAncestorContainer.nodeName&&(o.innerHTML="<pre>"+o.innerHTML+"</pre>"),i=document.location.href,o.innerHTML+='<br />来源: 海祇岛的珊瑚森林<br />文章作者: 海星来来<br />文章链接: <a href="'+i+'">'+i+"</a><br />本文章著作权归作者所有，任何形式的转载都请注明出处。",n.selectAllChildren(o),window.setTimeout(function(){t.removeChild(o)},200)))})</script><script src="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/libs/codeBlock/codeBlockFuction.js"></script><script src="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/libs/codeBlock/codeLang.js"></script><script src="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/libs/codeBlock/codeCopy.js"></script><script src="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/libs/codeBlock/codeShrink.js"></script></div><div id="toc-aside" class="expanded col l3 hide-on-med-and-down"><div class="toc-widget card"><div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div><div id="toc-content"></div></div></div></div><div id="floating-toc-btn" class="hide-on-med-and-down"><a class="btn-floating btn-large bg-color"><i class="fas fa-list-ul"></i></a></div><script src="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/libs/tocbot/tocbot.min.js"></script><script>$(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });</script></main><footer class="page-footer bg-color"><div class="container row center-align" style="margin-bottom:0!important"><div class="col s12 m8 l8 copy-right">Copyright&nbsp;&copy; <span id="year">2019-2025</span> <span id="year">2019</span> <a href="/about" target="_blank">海星来来</a> |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a> |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a> <span id="translate">|&nbsp;繁/简：</span><a id="translateLink" href="javascript:translatePage();">繁</a><br>&nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span class="white-color">174.6k</span>&nbsp;字 <span id="busuanzi_container_site_pv">|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv" class="white-color"></span>&nbsp;次 </span><span id="busuanzi_container_site_uv">|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv" class="white-color"></span>&nbsp;人</span><br><br></div><div class="col s12 m4 l4 social-link social-statis"><a href="https://github.com/umaru2001" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"><i class="fab fa-github"></i> </a><a href="mailto:donglaistarfish@gmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50"><i class="fas fa-envelope-open"></i> </a><a href="https://www.zhihu.com/people/hao-ba-50-81-68" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/hao-ba-50-81-68" data-position="top" data-delay="50"><i class="fab fa-zhihu1">知</i> </a><a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50"><i class="fas fa-rss"></i></a></div></div></footer><div class="progress-bar"></div><div id="searchModal" class="modal"><div class="modal-content"><div class="search-header"><span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span> <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input"></div><div id="searchResult"></div></div></div><script>$(function(){!function(t,s,i){"use strict";$.ajax({url:t,dataType:"xml",success:function(t){var e=$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get(),n=document.getElementById(s),r=document.getElementById(i);n.addEventListener("input",function(){var f='<ul class="search-result-list">',m=this.value.trim().toLowerCase().split(/[\s\-]+/);r.innerHTML="",this.value.trim().length<=0||(e.forEach(function(t){var n,e,r,s,i,l=!0,a=t.title.trim().toLowerCase(),c=t.content.trim().replace(/<[^>]+>/g,"").toLowerCase(),u=0===(u=t.url).indexOf("/")?t.url:"/"+u,o=-1,h=-1;""!==a&&""!==c&&m.forEach(function(t,e){n=a.indexOf(t),o=c.indexOf(t),n<0&&o<0?l=!1:(o<0&&(o=0),0===e&&(h=o))}),l&&(f+="<li><a href='"+u+"' class='search-result-title'>"+a+"</a>",e=t.content.trim().replace(/<[^>]+>/g,""),0<=h&&(s=h+80,(r=h-20)<0&&(r=0),0===r&&(s=100),s>e.length&&(s=e.length),i=e.substr(r,s),m.forEach(function(t){var e=new RegExp(t,"gi");i=i.replace(e,'<em class="search-keyword">'+t+"</em>")}),f+='<p class="search-result">'+i+"...</p>"),f+="</li>")}),f+="</ul>",r.innerHTML=f)})}})}("/search.xml","searchInput","searchResult")})</script><div id="backTop" class="top-scroll"><a class="btn-floating btn-large waves-effect waves-light" href="#!"><i class="fas fa-arrow-up"></i></a></div><script src="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/libs/materialize/materialize.min.js"></script><script src="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/libs/masonry/masonry.pkgd.min.js"></script><script src="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/libs/aos/aos.js"></script><script src="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/libs/scrollprogress/scrollProgress.min.js"></script><script src="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/libs/lightGallery/js/lightgallery-all.min.js"></script><script src="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/js/matery.js"></script><script src="/live2d-widget/autoload.js"></script><script src="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/libs/others/clicklove.js" async></script><script async src="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/libs/others/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/js/tw_cn.js"></script><script>var defaultEncoding=2,translateDelay=0,cookieDomain="https://blog.pengdonglai.com",msgToTraditionalChinese="繁",msgToSimplifiedChinese="简",translateButtonId="translateLink";translateInitilization()</script><script src="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/libs/instantpage/instantpage.js" type="module"></script>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 3,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,d=o();function o(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=o());for(var e,i=0;i<d.length;i++)0<=(e=(e=d[i]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,a,n,o=d[i];e=function(){d=d.filter(function(t){return o!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(o)},(t=o).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,n=t.getAttribute("data-original"),a.onload=function(){t.src=n,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=n},t.src!==n&&(a.src=n)))}()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)}(this);</script></body></html>