<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="utf-8"><meta name="keywords" content="Android, JVM"><meta name="description" content="这里是海星来来的博客，虽然他是一个程序员，但是这篇博客应该会很少更新技术相关的东西，因为这太无聊了。"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="renderer" content="webkit|ie-stand|ie-comp"><meta name="mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="theme-color" content="#ffffff"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><title>安卓（2）-语法基础：Kotlin 常用库（1） | 海祇岛的珊瑚森林</title><link rel="manifest" href="/manifest.json"><link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/favicon.webp"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/libs/awesome/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/libs/materialize/materialize.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/libs/aos/aos.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/libs/animate/animate.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/libs/lightGallery/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/css/matery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/css/my.css"><script src="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/libs/jquery/jquery.min.js"></script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="海祇岛的珊瑚森林" type="application/atom+xml"></head><body><script>// 每天切换 banner 图.  Switch banner image every day.
      const _dayOfWeek = new Date().getDay();
      if (_dayOfWeek === 1 || _dayOfWeek === 6) {
        document.body.classList.add('purple');
      } else if (_dayOfWeek >= 2 && _dayOfWeek <= 3) {
        document.body.classList.add('orange');
      } else if (_dayOfWeek == 4) {
        document.body.classList.add('blue');
      }
      _setCookie = (name, value, days) => {
        if (days) {
          var date = new Date();
          date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
          var expires = "; expires=" + date.toGMTString()
        } else var expires = "";
        document.cookie = name + "https://pengdonglaicom=" + value + expires + "; path=/"
      }

      _getCookie = (name) => {
        var nameEQ = name + "https://pengdonglaicom=";
        var ca = document.cookie.split(';');
        for (var i = 0; i < ca.length; i++) {
          var c = ca[i];
          while (c.charAt(0) == ' ') c = c.substring(1, c.length);
          if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length)
        }
        return null
      }

      window.DarkReader = {
        darkmode: _getCookie('targetDarkmode') === '1',
        changeMode: function () {
            if (this.darkmode) {
                document.body.classList.remove('black');
                const d = new Date().getDay();
                if (d === 1 || d === 6) {
                    document.body.classList.add('purple');
                } else if (d >= 2 && d <= 3) {
                    document.body.classList.add('orange');
                } else if (d == 4) {
                    document.body.classList.add('blue');
                }
                this.darkmode = false;
                _setCookie('targetDarkmode', 0, 7);
                window.changePostCalendarDarkMode && changePostCalendarDarkMode();
            } else {
                document.body.classList.remove('purple', 'orange', 'blue');
                document.body.classList.add('black');
                this.darkmode = true;
                _setCookie('targetDarkmode', 1, 7);
                window.changePostCalendarDarkMode && changePostCalendarDarkMode();
            }
        }
      }
      if (_getCookie('targetDarkmode') === '1') {
          document.body.classList.remove('purple', 'orange', 'blue');
          document.body.classList.add('black');
      }</script><header class="navbar-fixed"><nav id="headNav" class="bg-color nav-transparent"><div id="navContainer" class="nav-wrapper container"><div class="brand-logo"><a href="/" class="waves-effect waves-light"><img src="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/favicon.webp" class="logo-img" alt="LOGO"> <span class="logo-span">海祇岛的珊瑚森林</span></a></div><a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a><ul class="right nav-menu"><li class="hide-on-med-and-down nav-item"><a href="/" class="waves-effect waves-light"><i class="fas fa-home" style="zoom:.6"></i> <span>首页</span></a></li><li class="hide-on-med-and-down nav-item"><a href="" class="waves-effect waves-light"><i class="fas fa-folder-plus" style="zoom:.6"></i> <span>文章</span> <i class="fas fa-chevron-down" aria-hidden="true" style="zoom:.6"></i></a><ul class="sub-nav menus_item_child"><li><a href="/tags"><i class="fas fa-tags fa-fw" style="margin-top:-20px;zoom:.6"></i> <span>标签</span></a></li><li><a href="/archives"><i class="fas fa-archive fa-fw" style="margin-top:-20px;zoom:.6"></i> <span>归档</span></a></li><li><a href="/categories"><i class="fas fa-bookmark fa-fw" style="margin-top:-20px;zoom:.6"></i> <span>分类</span></a></li><li><a target="_blank" rel="noopener" href="http://docs.starfishdl.site"><i class="fas fa-file fa-fw" style="margin-top:-20px;zoom:.6"></i> <span>文档站</span></a></li></ul></li><li class="hide-on-med-and-down nav-item"><a href="/about" class="waves-effect waves-light"><i class="fas fa-user-circle" style="zoom:.6"></i> <span>关于</span></a></li><li class="hide-on-med-and-down nav-item"><a href="" class="waves-effect waves-light"><i class="fas fa-list" style="zoom:.6"></i> <span>多媒体</span> <i class="fas fa-chevron-down" aria-hidden="true" style="zoom:.6"></i></a><ul class="sub-nav menus_item_child"><li><a href="/musics"><i class="fas fa-music fa-fw" style="margin-top:-20px;zoom:.6"></i> <span>音乐</span></a></li><li><a target="_blank" rel="noopener" href="http://pengdonglai.com/?show_drawer=true"><i class="fas fa-address-book fa-fw" style="margin-top:-20px;zoom:.6"></i> <span>收藏链接</span></a></li><li><a href="/bangumis"><i class="fas fa-film fa-fw" style="margin-top:-20px;zoom:.6"></i> <span>追番</span></a></li></ul></li><li><a href="#searchModal" class="modal-trigger waves-effect waves-light"><i id="searchIcon" class="fas fa-search" title="搜索" style="zoom:.85"></i></a></li><li><a href="javascript:DarkReader?.changeMode()" class="waves-effect waves-light"><i id="searchIcon" class="fas darkmode-icon" title="暗黑模式开关" style="zoom:.85"></i></a></li></ul><div id="mobile-nav" class="side-nav sidenav"><div class="mobile-head bg-color"><img alt="avatar" src="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/medias/avatar.webp" class="logo-img circle responsive-img"><div class="logo-name">海祇岛的珊瑚森林</div><div class="logo-desc">这里是海星来来的博客，虽然他是一个程序员，但是这篇博客应该会很少更新技术相关的东西，因为这太无聊了。</div></div><ul class="menu-list mobile-menu-list"><li class="m-nav-item"><a href="/" class="waves-effect waves-light"><i class="fa-fw fas fa-home"></i> 首页</a></li><li class="m-nav-item"><a href="javascript:;"><i class="fa-fw fas fa-folder-plus"></i> 文章 <span class="m-icon"><i class="fas fa-chevron-right"></i></span></a><ul><li><a href="/tags" style="margin-left:75px"><i class="fa fas fa-tags fa-fw" style="position:absolute;left:50px"></i> <span>标签</span></a></li><li><a href="/archives" style="margin-left:75px"><i class="fa fas fa-archive fa-fw" style="position:absolute;left:50px"></i> <span>归档</span></a></li><li><a href="/categories" style="margin-left:75px"><i class="fa fas fa-bookmark fa-fw" style="position:absolute;left:50px"></i> <span>分类</span></a></li><li><a target="_blank" rel="noopener" href="http://docs.starfishdl.site" style="margin-left:75px"><i class="fa fas fa-file fa-fw" style="position:absolute;left:50px"></i> <span>文档站</span></a></li></ul></li><li class="m-nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa-fw fas fa-user-circle"></i> 关于</a></li><li class="m-nav-item"><a href="javascript:;"><i class="fa-fw fas fa-list"></i> 多媒体 <span class="m-icon"><i class="fas fa-chevron-right"></i></span></a><ul><li><a href="/musics" style="margin-left:75px"><i class="fa fas fa-music fa-fw" style="position:absolute;left:50px"></i> <span>音乐</span></a></li><li><a target="_blank" rel="noopener" href="http://pengdonglai.com/?show_drawer=true" style="margin-left:75px"><i class="fa fas fa-address-book fa-fw" style="position:absolute;left:50px"></i> <span>收藏链接</span></a></li><li><a href="/bangumis" style="margin-left:75px"><i class="fa fas fa-film fa-fw" style="position:absolute;left:50px"></i> <span>追番</span></a></li></ul></li><li><div class="divider"></div></li><li><a href="https://github.com/umaru2001" class="waves-effect waves-light" target="_blank"><i class="fab fa-github-square fa-fw"></i>来看看我呀~</a></li></ul></div></div><style>.nav-transparent .github-corner{display:none!important}.github-corner{position:absolute;z-index:10;top:0;right:0;border:0;transform:scale(1.1)}.github-corner svg{color:#000;fill:#fff;height:64px;width:64px}.github-corner:hover .octo-arm{animation:a .56s ease-in-out}.github-corner .octo-arm{animation:none}@keyframes a{0%,to{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}</style><a href="https://github.com/umaru2001" class="github-corner tooltipped hide-on-med-and-down" target="_blank" data-tooltip="来看看我呀~" data-position="left" data-delay="50"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a></nav></header><script src="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/libs/cryptojs/crypto-js.min.js"></script><script>(function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();</script><div class="bg-cover pd-header post-cover" style="background-image:url(https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/medias/featureimages/0.webp);background-position:50% 25%"><div class="container" style="right:0;left:0"><div class="row"><div class="col s12 m12 l12"><div class="brand"><h1 class="description center-align post-title">安卓（2）-语法基础：Kotlin 常用库（1）</h1></div></div></div></div></div><main class="post-container content"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/libs/tocbot/tocbot.css"><style>#articleContent h1::before,#articleContent h2::before,#articleContent h3::before,#articleContent h4::before,#articleContent h5::before,#articleContent h6::before{display:block;content:" ";height:100px;margin-top:-100px;visibility:hidden}#articleContent :focus{outline:0}.toc-fixed{position:fixed;top:64px}.toc-widget{width:345px;padding-left:20px}.toc-widget .toc-title{padding:35px 0 15px 17px;font-size:1.5rem;font-weight:700;line-height:1.5rem}.toc-widget ol{padding:0;list-style:none}#toc-content{padding-bottom:30px;overflow:scroll;max-height:75vh}#toc-content::-webkit-scrollbar{background-color:transparent}#toc-content::-webkit-scrollbar-corner{background-color:transparent}#toc-content ol{padding-left:10px}#toc-content ol li{padding-left:10px}#toc-content .toc-link:hover{color:#42b983;font-weight:700;text-decoration:underline;font-size:1.1rem;line-height:30px}.blue #toc-content .toc-link:hover{color:#4169e1}.purple #toc-content .toc-link:hover{color:#6a5acd}.orange #toc-content .toc-link:hover{color:#ff8c00}.black #toc-content .toc-link:hover{color:#faebd7}#toc-content .toc-link::before{background-color:transparent;max-height:25px;position:absolute;right:23.5vw;display:block}#toc-content .toc-list-item.is-active-li{border-left:5px solid #ccc!important;border-color:#42b983!important;visibility:visible;background-color:rgba(238,243,252,.5)}.black #toc-content .toc-list-item.is-active-li{border-color:#faebd7!important;background-color:rgb(68 68 68 / 61%)}.blue #toc-content .toc-list-item.is-active-li{border-color:#4169e1!important}.purple #toc-content .toc-list-item.is-active-li{border-color:#6a5acd!important}.orange #toc-content .toc-list-item.is-active-li{border-color:#ff8c00!important}#toc-content ol.toc-list.is-collapsible{border-left:2px solid #9fabb4;margin:0 0 0 .5em}.black #toc-content ol.toc-list.is-collapsible{border-left:2px solid #898175}#toc-content .is-active-link{color:#0f9d58}.blue #toc-content .is-active-link{color:#4169e1}.purple #toc-content .is-active-link{color:#6a5acd}.orange #toc-content .is-active-link{color:#ff8c00}.black #toc-content .is-active-link{color:#faebd7}#floating-toc-btn{position:fixed;right:15px;bottom:76px;padding-top:15px;margin-bottom:0;z-index:998}#floating-toc-btn .btn-floating{width:48px;height:48px;background:#404040}#floating-toc-btn .btn-floating i{line-height:48px;font-size:1.4rem}</style><div class="row"><div id="main-content" class="col s12 m12 l9"><div id="artDetail"><div class="card"><div class="card-content article-info"><div class="row tag-cate"><div class="col s7"><div class="article-tag"><a href="/tags/Android/"><span class="chip bg-color">Android</span> </a><a href="/tags/Kotlin/"><span class="chip bg-color">Kotlin</span> </a><a href="/tags/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"><span class="chip bg-color">基础语法</span></a></div></div><div class="col s5 right-align"><div class="post-cate"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/Android/" class="post-category">Android </a><a href="/categories/Android/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" class="post-category">基础语法</a></div></div></div><div class="post-info"><div class="post-date info-break-policy"><i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp; 2025-01-29</div><div class="info-break-policy"><i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp; 14k</div></div></div><hr class="clearfix"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/libs/prism/prism.css"><div class="card-content article-card-content"><div id="articleContent"><blockquote><p>2024 年我开始逐渐介入客户端的研发，因此我开始学习客户端的知识。<br>从服务端开始，转到前端来其实完全代表着我的编码风格的转变。我喜欢 UI 编程那「所见即所得」的惊艳，也喜欢人机交互相关的内容。<br>做 C 端 App，前端技术实际上更多是一种强行「卷」过来的结果：首先，基础肯定是客户端技术 Android&#x2F;iOS，但是前端的作用越来越清晰。当然，目前的大环境下走入前端甚至客户端开发通常被认为是一种开倒车的举动。但这种东西谁又说得好呢——难道做算法调优几个版本实验指标波动，亦或者做服务端大半夜被机器人打电话就能让人兴奋了吗？<br>人总有无知的时候，在已知信息差的时候我们总有一天要为认知买单。所以就让我们为梦想，做出一次不那么受到束缚的选择吧。<br>这是安卓系列的第一期，它包含以下内容：<br><a href="/2025/01/29/android-1/">安卓（1）-语法基础：Kotlin ＆ Java ＆ TS 对比</a><br><a href="/2025/01/29/android-2/">安卓（2）-语法基础：Kotlin 常用库（1）</a><br><a href="/2025/01/29/android-3/">安卓（3）-实用篇：UI（1）</a><br>我使用了 AI 来辅助我创作了一些重复性的工作，第一期内容会以相关知识的罗列为主，所以最好的阅读方式是阅读后进行查漏补缺。<br>希望大家可以喜欢这些教程！</p></blockquote><p>本文是安卓系列的第二个内容，衔接前一篇内容的 Kotlin 基础语法，主要介绍了 Kotlin 常用库的一些基础用法，学习 Kotlin 常用库的用法可以提高开发效率、增强代码可读性、简化复杂任务、获得社区支持，并提升应用性能，从而更好地利用 Kotlin 的优势构建高效、可维护的应用。</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><table><thead><tr><th>特性</th><th>MutableList</th><th>List</th></tr></thead><tbody><tr><td>可变性</td><td>可变，允许添加、删除和修改元素</td><td>不可变，一旦创建，元素不可修改</td></tr><tr><td>使用场景</td><td>当需要对列表中的元素进行频繁的修改操作时，例如动态存储数据集合，并且需要不断地添加、删除或更新元素时，使用 MutableList。</td><td>当需要存储一组固定的数据，不希望在程序运行过程中对其进行修改，仅用于读取元素或传递不可变的数据集合时，使用 List。</td></tr><tr><td>Kotlin 使用：</td><td></td><td></td></tr></tbody></table><p>以下是 <code>MutableList</code> 和 <code>List</code> 在不同操作上的区别和常用方法的表格：</p><table><thead><tr><th>操作</th><th><code>MutableList</code></th><th><code>List</code></th></tr></thead><tbody><tr><td>构造</td><td>- <code>mutableListOf()</code>：创建一个可变列表，可传入初始元素。<br>例如：<code>val mutableList = mutableListOf(1, 2, 3)</code><br>- <code>ArrayList()</code>（Java 风格）：创建一个空的可变列表，后续可添加元素。<br>例如：<code>val mutableList = ArrayList&lt;Int&gt;()</code></td><td>- <code>listOf()</code>：创建一个不可变列表，可传入初始元素。<br>例如：<code>val list = listOf(1, 2, 3)</code><br>- <code>toList()</code>：将其他集合转换为不可变列表。<br>例如：<code>val list = mutableList.toList()</code></td></tr><tr><td>迭代器</td><td>- <code>iterator()</code>：返回一个迭代器，可用于遍历列表。<br>例如：<br><code>kotlin&lt;br&gt;val mutableList = mutableListOf(1, 2, 3)&lt;br&gt;val iterator = mutableList.iterator()&lt;br&gt;while (iterator.hasNext()) &#123;&lt;br&gt; val element = iterator.next()&lt;br&gt; println(element)&lt;br&gt;&#125;&lt;br&gt;</code></td><td>- <code>iterator()</code>：返回一个迭代器，可用于遍历列表。<br>例如：<br><code>kotlin&lt;br&gt;val list = listOf(1, 2, 3)&lt;br&gt;val iterator = list.iterator()&lt;br&gt;while (iterator.hasNext()) &#123;&lt;br&gt; val element = iterator.next()&lt;br&gt; println(element)&lt;br&gt;&#125;&lt;br&gt;</code></td></tr><tr><td>过滤</td><td>- <code>filter()</code>：返回一个新的 <code>MutableList</code>，包含满足条件的元素。<br>例如：<br><code>kotlin&lt;br&gt;val mutableList = mutableListOf(1, 2, 3, 4)&lt;br&gt;val filteredList = mutableList.filter &#123; it % 2 == 0 &#125;&lt;br&gt;</code></td><td>- <code>filter()</code>：返回一个新的 <code>List</code>，包含满足条件的元素。<br>例如：<br><code>kotlin&lt;br&gt;val list = listOf(1, 2, 3, 4)&lt;br&gt;val filteredList = list.filter &#123; it % 2 == 0 &#125;&lt;br&gt;</code></td></tr><tr><td>加减操作符</td><td>- <code>+</code>：创建一个新的 <code>MutableList</code>，包含原列表和新元素。<br>例如：<code>val newMutableList = mutableList + 4</code><br>- <code>+=</code>：直接在原列表末尾添加元素。<br>例如：<code>mutableList += 4</code><br>- <code>-</code>：创建一个新的 <code>MutableList</code>，不包含指定元素。<br>例如：<code>val newMutableList = mutableList - 2</code><br>- <code>-=</code>：直接从原列表中移除指定元素。<br>例如：<code>mutableList -= 2</code></td><td>- <code>+</code>：创建一个新的 <code>List</code>，包含原列表和新元素。<br>例如：<code>val newList = list + 4</code><br><code>-</code>：创建一个新的 <code>List</code>，不包含指定元素。<br>例如：<code>val newList = list - 2</code></td></tr><tr><td>取集合的一部分</td><td>- <code>subList()</code>：返回一个新的 <code>MutableList</code>，包含指定范围的元素。<br>例如：<code>val subMutableList = mutableList.subList(1, 3)</code></td><td>- <code>subList()</code>：返回一个新的 <code>List</code>，包含指定范围的元素。<br>例如：<code>val subList = list.subList(1, 3)</code></td></tr><tr><td>取单个元素</td><td>- <code>get()</code> 或 <code>[]</code>：获取指定位置的元素。<br>例如：<code>val element = mutableList[1]</code></td><td>- <code>get()</code> 或 <code>[]</code>：获取指定位置的元素。<br>例如：<code>val element = list[1]</code></td></tr><tr><td>排序</td><td>- <code>sort()</code>：对原列表进行排序。<br>例如：<code>mutableList.sort()</code><br>- <code>sorted()</code>：返回一个新的 <code>MutableList</code>，包含排序后的元素，原列表不变。<br>例如：<code>val sortedMutableList = mutableList.sorted()</code></td><td>- <code>sorted()</code>：返回一个新的 <code>List</code>，包含排序后的元素，原列表不变。<br>例如：<code>val sortedList = list.sorted()</code></td></tr><tr><td>聚合操作</td><td>- <code>sum()</code>：计算列表元素的总和（元素需为数字类型）。<br>例如：<code>val sum = mutableList.sum()</code><br>- <code>max()</code>：获取列表中的最大值。<br>例如：<code>val max = mutableList.max()</code><br>- <code>min()</code>：获取列表中的最小值。<br>例如：<code>val min = mutableList.min()</code></td><td>- <code>sum()</code>：计算列表元素的总和（元素需为数字类型）。<br>例如：<code>val sum = list.sum()</code><br>- <code>max()</code>：获取列表中的最大值。<br>例如：<code>val max = list.max()</code><br>- <code>min()</code>：获取列表中的最小值。<br>例如：<code>val min = list.min()</code></td></tr><tr><td>更改集合内容的操作（添加或删除元素）</td><td>- <code>add()</code>：在列表末尾添加元素。<br>例如：<code>mutableList.add(5)</code><br>- <code>remove()</code>：移除指定元素。<br>例如：<code>mutableList.remove(3)</code><br>- <code>removeAt()</code>：移除指定位置的元素。<br>例如：<code>mutableList.removeAt(1)</code></td><td>不支持，因为 <code>List</code> 是不可变的，尝试添加或删除元素会导致编译错误。</td></tr><tr><td>总结：<code>MutableList</code> 是可变的，可以对其元素进行添加、删除、修改等操作；而 <code>List</code> 是不可变的，一旦创建，其元素不能被修改，只能进行读取、过滤、聚合等不改变原列表的操作。</td><td></td><td></td></tr></tbody></table><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">fun main() &#123;
    &#x2F;&#x2F; 构造
    &#x2F;&#x2F; MutableList 的构造
    val mutableList &#x3D; mutableListOf(1, 2, 3)
    val mutableListJavaStyle &#x3D; ArrayList&lt;Int&gt;()
    mutableListJavaStyle.add(4)
    mutableListJavaStyle.add(5)
    println(&quot;MutableList 构造: $mutableList, $mutableListJavaStyle&quot;)

    &#x2F;&#x2F; List 的构造
    val list &#x3D; listOf(6, 7, 8)
    val listFromMutable &#x3D; mutableList.toList()
    println(&quot;List 构造: $list, $listFromMutable&quot;)

    &#x2F;&#x2F; 迭代器
    &#x2F;&#x2F; MutableList 的迭代器
    println(&quot;MutableList 迭代器:&quot;)
    val mutableIterator &#x3D; mutableList.iterator()
    while (mutableIterator.hasNext()) &#123;
        val element &#x3D; mutableIterator.next()
        println(element)
    &#125;

    &#x2F;&#x2F; List 的迭代器
    println(&quot;List 迭代器:&quot;)
    val listIterator &#x3D; list.iterator()
    while (listIterator.hasNext()) &#123;
        val element &#x3D; listIterator.next()
        println(element)
    &#125;

    &#x2F;&#x2F; 过滤
    &#x2F;&#x2F; MutableList 的过滤
    val filteredMutableList &#x3D; mutableList.filter &#123; it % 2 &#x3D;&#x3D; 0 &#125;
    println(&quot;MutableList 过滤: $filteredMutableList&quot;)

    &#x2F;&#x2F; List 的过滤
    val filteredList &#x3D; list.filter &#123; it % 2 &#x3D;&#x3D; 0 &#125;
    println(&quot;List 过滤: $filteredList&quot;)

    &#x2F;&#x2F; 加减操作符
    &#x2F;&#x2F; MutableList 的加减操作符
    val newMutableListPlus &#x3D; mutableList + 9
    println(&quot;MutableList + 操作符: $newMutableListPlus&quot;)
    mutableList +&#x3D; 10
    println(&quot;MutableList +&#x3D; 操作符: $mutableList&quot;)
    val newMutableListMinus &#x3D; mutableList - 2
    println(&quot;MutableList - 操作符: $newMutableListMinus&quot;)
    mutableList -&#x3D; 3
    println(&quot;MutableList -&#x3D; 操作符: $mutableList&quot;)

    &#x2F;&#x2F; List 的加减操作符
    val newListPlus &#x3D; list + 11
    println(&quot;List + 操作符: $newListPlus&quot;)
    val newListMinus &#x3D; list - 7
    println(&quot;List - 操作符: $newListMinus&quot;)

    &#x2F;&#x2F; 取集合的一部分
    &#x2F;&#x2F; MutableList 取集合的一部分
    val subMutableList &#x3D; mutableList.subList(1, 3)
    println(&quot;MutableList 取集合的一部分: $subMutableList&quot;)

    &#x2F;&#x2F; List 取集合的一部分
    val subList &#x3D; list.subList(1, 3)
    println(&quot;List 取集合的一部分: $subList&quot;)

    &#x2F;&#x2F; 取单个元素
    &#x2F;&#x2F; MutableList 取单个元素
    val mutableListElement &#x3D; mutableList[1]
    println(&quot;MutableList 取单个元素: $mutableListElement&quot;)

    &#x2F;&#x2F; List 取单个元素
    val listElement &#x3D; list[1]
    println(&quot;List 取单个元素: $listElement&quot;)

    &#x2F;&#x2F; 排序
    &#x2F;&#x2F; MutableList 的排序
    mutableList.sort()
    println(&quot;MutableList sort() 排序后: $mutableList&quot;)
    val sortedMutableList &#x3D; mutableList.sorted()
    println(&quot;MutableList sorted() 排序后: $sortedMutableList&quot;)

    &#x2F;&#x2F; List 的排序
    val sortedList &#x3D; list.sorted()
    println(&quot;List sorted() 排序后: $sortedList&quot;)

    &#x2F;&#x2F; 聚合操作
    &#x2F;&#x2F; MutableList 的聚合操作
    val mutableListSum &#x3D; mutableList.sum()
    val mutableListMax &#x3D; mutableList.max()
    val mutableListMin &#x3D; mutableList.min()
    println(&quot;MutableList 聚合操作: sum&#x3D;$mutableListSum, max&#x3D;$mutableListMax, min&#x3D;$mutableListMin&quot;)

    &#x2F;&#x2F; List 的聚合操作
    val listSum &#x3D; list.sum()
    val listMax &#x3D; list.max()
    val listMin &#x3D; list.min()
    println(&quot;List 聚合操作: sum&#x3D;$listSum, max&#x3D;$listMax, min&#x3D;$listMin&quot;)

    &#x2F;&#x2F; 更改集合内容的操作（添加或删除元素）
    &#x2F;&#x2F; MutableList 的更改操作
    mutableList.add(12)
    println(&quot;MutableList 添加元素后: $mutableList&quot;)
    mutableList.remove(10)
    println(&quot;MutableList 移除元素后: $mutableList&quot;)
    mutableList.removeAt(1)
    println(&quot;MutableList 移除指定位置元素后: $mutableList&quot;)

    &#x2F;&#x2F; List 不支持更改操作，以下代码会导致编译错误
    &#x2F;&#x2F; list.add(13)
    &#x2F;&#x2F; list.remove(8)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><table><thead><tr><th>特性</th><th>MutableSet</th><th>Set</th></tr></thead><tbody><tr><td>可变性</td><td>可变，允许添加、删除元素</td><td>不可变，元素一旦确定不能修改</td></tr><tr><td>使用场景</td><td>当需要动态存储一组元素，且不允许重复元素，并且在后续操作中需要对集合元素进行添加、删除等修改操作时，使用 MutableSet。</td><td>当需要存储一组不允许重复的元素，且该集合在创建后不允许修改，仅用于元素的检查、遍历等操作时，使用 Set。</td></tr></tbody></table><p>在 Kotlin 中，以下是它们的使用示例：</p><table><thead><tr><th>操作</th><th><code>MutableSet</code></th><th><code>Set</code></th></tr></thead><tbody><tr><td>构造</td><td>- <code>mutableSetOf()</code>：创建一个可变集合，可传入初始元素。<br>例如：<code>val mutableSet = mutableSetOf(1, 2, 3)</code><br>- <code>HashSet()</code>（Java 风格）：创建一个空的可变集合，后续可添加元素。<br>例如：<code>val mutableSet = HashSet&lt;Int&gt;()</code></td><td>- <code>setOf()</code>：创建一个不可变集合，可传入初始元素。<br>例如：<code>val set = setOf(1, 2, 3)</code><br>- <code>toSet()</code>：将其他集合转换为不可变集合。<br>例如：<code>val set = mutableSet.toSet()</code></td></tr><tr><td>迭代器</td><td>- <code>iterator()</code>：返回一个迭代器，可用于遍历集合。<br>例如：<br><code>kotlin&lt;br&gt;val mutableSet = mutableSetOf(1, 2, 3)&lt;br&gt;val iterator = mutableSet.iterator()&lt;br&gt;while (iterator.hasNext()) &#123;&lt;br&gt; val element = iterator.next()&lt;br&gt; println(element)&lt;br&gt;&#125;&lt;br&gt;</code></td><td>- <code>iterator()</code>：返回一个迭代器，可用于遍历集合。<br>例如：<br><code>kotlin&lt;br&gt;val set = setOf(1, 2, 3)&lt;br&gt;val iterator = set.iterator()&lt;br&gt;while (iterator.hasNext()) &#123;&lt;br&gt; val element = iterator.next()&lt;br&gt; println(element)&lt;br&gt;&#125;&lt;br&gt;</code></td></tr><tr><td>过滤</td><td>- <code>filter()</code>：返回一个新的 <code>MutableSet</code>，包含满足条件的元素。<br>例如：<br><code>kotlin&lt;br&gt;val mutableSet = mutableSetOf(1, 2, 3, 4)&lt;br&gt;val filteredSet = mutableSet.filter &#123; it % 2 == 0 &#125;&lt;br&gt;</code></td><td>- <code>filter()</code>：返回一个新的 <code>Set</code>，包含满足条件的元素。<br>例如：<br><code>kotlin&lt;br&gt;val set = setOf(1, 2, 3, 4)&lt;br&gt;val filteredSet = set.filter &#123; it % 2 == 0 &#125;&lt;br&gt;</code></td></tr><tr><td>加减操作符</td><td>- <code>+</code>：创建一个新的 <code>MutableSet</code>，包含原集合和新元素。<br>例如：<code>val newMutableSet = mutableSet + 4</code><br>- <code>+=</code>：直接在原集合中添加元素。<br>例如：<code>mutableSet += 4</code><br>- <code>-</code>：创建一个新的 <code>MutableSet</code>，不包含指定元素。<br>例如：<code>val newMutableSet = mutableSet - 2</code><br>- <code>-=</code>：直接从原集合中移除指定元素。<br>例如：<code>mutableSet -= 2</code></td><td>- <code>+</code>：创建一个新的 <code>Set</code>，包含原集合和新元素。<br>例如：<code>val newSet = set + 4</code><br><code>-</code>：创建一个新的 <code>Set</code>，不包含指定元素。<br>例如：<code>val newSet = set - 2</code></td></tr><tr><td>取集合的一部分</td><td>无直接方法，可先转换为列表操作后再转回集合</td><td>无直接方法，可先转换为列表操作后再转回集合</td></tr><tr><td>取单个元素</td><td>无直接索引获取元素的方法，可通过迭代或查找判断元素是否存在<br>例如：<code>if (mutableSet.contains(2)) &#123;...&#125;</code></td><td>无直接索引获取元素的方法，可通过迭代或查找判断元素是否存在<br>例如：<code>if (set.contains(2)) &#123;...&#125;</code></td></tr><tr><td>排序</td><td>- <code>sorted()</code>：返回一个新的 <code>List</code>（不是 <code>MutableSet</code>），包含排序后的元素，原集合不变。<br>例如：<code>val sortedList = mutableSet.sorted()</code></td><td>- <code>sorted()</code>：返回一个新的 <code>List</code>（不是 <code>Set</code>），包含排序后的元素，原集合不变。<br>例如：<code>val sortedList = set.sorted()</code></td></tr><tr><td>聚合操作</td><td>- <code>sum()</code>：计算集合元素的总和（元素需为数字类型）。<br>例如：<code>val sum = mutableSet.sum()</code><br>- <code>max()</code>：获取集合中的最大值。<br>例如：<code>val max = mutableSet.max()</code><br>- <code>min()</code>：获取集合中的最小值。<br>例如：<code>val min = mutableSet.min()</code></td><td>- <code>sum()</code>：计算集合元素的总和（元素需为数字类型）。<br>例如：<code>val sum = set.sum()</code><br>- <code>max()</code>：获取集合中的最大值。<br>例如：<code>val max = set.max()</code><br>- <code>min()</code>：获取集合中的最小值。<br>例如：<code>val min = set.min()</code></td></tr><tr><td>更改集合内容的操作（添加或删除元素）</td><td>- <code>add()</code>：在集合中添加元素。<br>例如：<code>mutableSet.add(5)</code><br>- <code>remove()</code>：移除指定元素。<br>例如：<code>mutableSet.remove(3)</code></td><td>不支持，因为 <code>Set</code> 是不可变的，尝试添加或删除元素会导致编译错误。</td></tr></tbody></table><p>以下是对应的 Kotlin 代码示例：</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">fun main() &#123;
    &#x2F;&#x2F; 构造
    &#x2F;&#x2F; MutableSet 的构造
    val mutableSet &#x3D; mutableSetOf(1, 2, 3)
    val mutableSetJavaStyle &#x3D; HashSet&lt;Int&gt;()
    mutableSetJavaStyle.add(4)
    mutableSetJavaStyle.add(5)
    println(&quot;MutableSet 构造: $mutableSet, $mutableSetJavaStyle&quot;)

    &#x2F;&#x2F; Set 的构造
    val set &#x3D; setOf(6, 7, 8)
    val setFromMutable &#x3D; mutableSet.toSet()
    println(&quot;Set 构造: $set, $setFromMutable&quot;)

    &#x2F;&#x2F; 迭代器
    &#x2F;&#x2F; MutableSet 的迭代器
    println(&quot;MutableSet 迭代器:&quot;)
    val mutableIterator &#x3D; mutableSet.iterator()
    while (mutableIterator.hasNext()) &#123;
        val element &#x3D; mutableIterator.next()
        println(element)
    &#125;

    &#x2F;&#x2F; Set 的迭代器
    println(&quot;Set 迭代器:&quot;)
    val setIterator &#x3D; set.iterator()
    while (setIterator.hasNext()) &#123;
        val element &#x3D; setIterator.next()
        println(element)
    &#125;

    &#x2F;&#x2F; 过滤
    &#x2F;&#x2F; MutableSet 的过滤
    val filteredMutableSet &#x3D; mutableSet.filter &#123; it % 2 &#x3D;&#x3D; 0 &#125;.toMutableSet()
    println(&quot;MutableSet 过滤: $filteredMutableSet&quot;)

    &#x2F;&#x2F; Set 的过滤
    val filteredSet &#x3D; set.filter &#123; it % 2 &#x3D;&#x3D; 0 &#125;.toSet()
    println(&quot;Set 过滤: $filteredSet&quot;)

    &#x2F;&#x2F; 加减操作符
    &#x2F;&#x2F; MutableSet 的加减操作符
    val newMutableSetPlus &#x3D; mutableSet + 9
    println(&quot;MutableSet + 操作符: $newMutableSetPlus&quot;)
    mutableSet +&#x3D; 10
    println(&quot;MutableSet +&#x3D; 操作符: $mutableSet&quot;)
    val newMutableSetMinus &#x3D; mutableSet - 2
    println(&quot;MutableSet - 操作符: $newMutableSetMinus&quot;)
    mutableSet -&#x3D; 3
    println(&quot;MutableSet -&#x3D; 操作符: $mutableSet&quot;)

    &#x2F;&#x2F; Set 的加减操作符
    val newSetPlus &#x3D; set + 11
    println(&quot;Set + 操作符: $newSetPlus&quot;)
    val newSetMinus &#x3D; set - 7
    println(&quot;Set - 操作符: $newSetMinus&quot;)

    &#x2F;&#x2F; 取单个元素
    &#x2F;&#x2F; MutableSet 取单个元素
    if (mutableSet.contains(2)) &#123;
        println(&quot;MutableSet 包含元素 2&quot;)
    &#125;

    &#x2F;&#x2F; Set 取单个元素
    if (set.contains(7)) &#123;
        println(&quot;Set 包含元素 7&quot;)
    &#125;

    &#x2F;&#x2F; 排序
    &#x2F;&#x2F; MutableSet 的排序
    val sortedMutableList &#x3D; mutableSet.sorted()
    println(&quot;MutableSet sorted() 排序后: $sortedMutableList&quot;)

    &#x2F;&#x2F; Set 的排序
    val sortedSetList &#x3D; set.sorted()
    println(&quot;Set sorted() 排序后: $sortedSetList&quot;)

    &#x2F;&#x2F; 聚合操作
    &#x2F;&#x2F; MutableSet 的聚合操作
    val mutableSetSum &#x3D; mutableSet.sum()
    val mutableSetMax &#x3D; mutableSet.max()
    val mutableSetMin &#x3D; mutableSet.min()
    println(&quot;MutableSet 聚合操作: sum&#x3D;$mutableSetSum, max&#x3D;$mutableSetMax, min&#x3D;$mutableSetMin&quot;)

    &#x2F;&#x2F; Set 的聚合操作
    val setSum &#x3D; set.sum()
    val setMax &#x3D; set.max()
    val setMin &#x3D; set.min()
    println(&quot;Set 聚合操作: sum&#x3D;$setSum, max&#x3D;$setMax, min&#x3D;$setMin&quot;)

    &#x2F;&#x2F; 更改集合内容的操作（添加或删除元素）
    &#x2F;&#x2F; MutableSet 的更改操作
    mutableSet.add(12)
    println(&quot;MutableSet 添加元素后: $mutableSet&quot;)
    mutableSet.remove(10)
    println(&quot;MutableSet 移除元素后: $mutableSet&quot;)

    &#x2F;&#x2F; Set 不支持更改操作，以下代码会导致编译错误
    &#x2F;&#x2F; set.add(13)
    &#x2F;&#x2F; set.remove(8)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：<code>MutableSet</code> 是可变的，可以对其元素进行添加、删除等操作；而 <code>Set</code> 是不可变的，一旦创建，其元素不能被修改，只能进行读取、过滤、聚合等不改变原集合的操作。</p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><table><thead><tr><th>特性</th><th>MutableMap</th><th>Map</th></tr></thead><tbody><tr><td>可变性</td><td>可变，允许添加、删除元素</td><td>不可变，元素一旦确定不能修改</td></tr><tr><td>使用场景</td><td>当需要动态存储一组元素，且不允许重复元素，并且在后续操作中需要对集合元素进行添加、删除等修改操作时，使用 MutableMap。</td><td>当需要存储一组不允许重复的元素，且该集合在创建后不允许修改，仅用于元素的检查、遍历等操作时，使用 Map。</td></tr><tr><td>以下是 <code>Map</code> 和 <code>MutableMap</code> 在不同操作上的区别和常用方法的表格：</td><td></td><td></td></tr></tbody></table><table><thead><tr><th>操作</th><th><code>MutableMap</code></th><th><code>Map</code></th></tr></thead><tbody><tr><td>构造</td><td>- <code>mutableMapOf()</code>：创建一个可变映射，可传入初始键值对。<br>例如：<code>val mutableMap = mutableMapOf(&quot;a&quot; to 1, &quot;b&quot; to 2)</code><br>- <code>HashMap()</code>（Java 风格）：创建一个空的可变映射，后续可添加键值对。<br>例如：<code>val mutableMap = HashMap&lt;String, Int&gt;()</code></td><td>- <code>mapOf()</code>：创建一个不可变映射，可传入初始键值对。<br>例如：<code>val map = mapOf(&quot;a&quot; to 1, &quot;b&quot; to 2)</code><br>- <code>toMap()</code>：将其他映射或键值对集合转换为不可变映射。<br>例如：<code>val map = mutableMap.toMap()</code></td></tr><tr><td>迭代器</td><td>- <code>iterator()</code>：返回一个迭代器，可用于遍历映射的键值对。<br>例如：<br><code>kotlin&lt;br&gt;val mutableMap = mutableMapOf(&quot;a&quot; to 1, &quot;b&quot; to 2)&lt;br&gt;val iterator = mutableMap.iterator()&lt;br&gt;while (iterator.hasNext()) &#123;&lt;br&gt; val entry = iterator.next()&lt;br&gt; println(&quot;$&#123;entry.key&#125;: $&#123;entry.value&#125;&quot;)&lt;br&gt;&#125;&lt;br&gt;</code></td><td>- <code>iterator()</code>：返回一个迭代器，可用于遍历映射的键值对。<br>例如：<br><code>kotlin&lt;br&gt;val map = mapOf(&quot;a&quot; to 1, &quot;b&quot; to 2)&lt;br&gt;val iterator = map.iterator()&lt;br&gt;while (iterator.hasNext()) &#123;&lt;br&gt; val entry = iterator.next()&lt;br&gt; println(&quot;$&#123;entry.key&#125;: $&#123;entry.value&#125;&quot;)&lt;br&gt;&#125;&lt;br&gt;</code></td></tr><tr><td>过滤</td><td>- <code>filter()</code>：返回一个新的 <code>MutableMap</code>，包含满足条件的键值对。<br>例如：<br><code>kotlin&lt;br&gt;val mutableMap = mutableMapOf(&quot;a&quot; to 1, &quot;b&quot; to 2, &quot;c&quot; to 3)&lt;br&gt;val filteredMap = mutableMap.filter &#123; it.value % 2 == 0 &#125;&lt;br&gt;</code></td><td>- <code>filter()</code>：返回一个新的 <code>Map</code>，包含满足条件的键值对。<br>例如：<br><code>kotlin&lt;br&gt;val map = mapOf(&quot;a&quot; to 1, &quot;b&quot; to 2, &quot;c&quot; to 3)&lt;br&gt;val filteredMap = map.filter &#123; it.value % 2 == 0 &#125;&lt;br&gt;</code></td></tr><tr><td>加减操作符</td><td>- <code>+</code>：创建一个新的 <code>MutableMap</code>，包含原映射和新的键值对。<br>例如：<code>val newMutableMap = mutableMap + (&quot;d&quot; to 4)</code><br>- <code>+=</code>：直接在原映射中添加键值对。<br>例如：<code>mutableMap += (&quot;d&quot; to 4)</code><br>- <code>-</code>：创建一个新的 <code>MutableMap</code>，不包含指定键的键值对。<br>例如：<code>val newMutableMap = mutableMap - &quot;a&quot;</code><br>- <code>-=</code>：直接从原映射中移除指定键的键值对。<br>例如：<code>mutableMap -= &quot;a&quot;</code></td><td>- <code>+</code>：创建一个新的 <code>Map</code>，包含原映射和新的键值对。<br>例如：<code>val newMap = map + (&quot;d&quot; to 4)</code><br><code>-</code>：创建一个新的 <code>Map</code>，不包含指定键的键值对。<br>例如：<code>val newMap = map - &quot;a&quot;</code></td></tr><tr><td>取集合的一部分</td><td>- 无直接方法，可通过过滤或转换为其他集合类型操作</td><td>无直接方法，可通过过滤或转换为其他集合类型操作</td></tr><tr><td>取单个元素</td><td>- <code>get()</code> 或 <code>[]</code>：根据键获取对应的值。<br>例如：<code>val value = mutableMap[&quot;a&quot;]</code></td><td>- <code>get()</code> 或 <code>[]</code>：根据键获取对应的值。<br>例如：<code>val value = map[&quot;a&quot;]</code></td></tr><tr><td>排序</td><td>- 对键排序：<code>toSortedMap()</code> 按键排序返回新的 <code>MutableMap</code>。<br>例如：<code>val sortedMutableMap = mutableMap.toSortedMap()</code><br>对值排序：先转换为键值对列表排序再转回映射。<br>例如：<br><code>kotlin&lt;br&gt;val sortedByValue = mutableMap.toList().sortedBy &#123; it.value &#125;.toMap().toMutableMap()&lt;br&gt;</code></td><td>- 对键排序：<code>toSortedMap()</code> 按键排序返回新的 <code>Map</code>。<br>例如：<code>val sortedMap = map.toSortedMap()</code><br>对值排序：先转换为键值对列表排序再转回映射。<br>例如：<br><code>kotlin&lt;br&gt;val sortedByValue = map.toList().sortedBy &#123; it.value &#125;.toMap()&lt;br&gt;</code></td></tr><tr><td>聚合操作</td><td>- <code>values.sum()</code>：计算所有值的总和（值需为数字类型）。<br>例如：<code>val sum = mutableMap.values.sum()</code><br>- <code>values.max()</code>：获取所有值中的最大值。<br>例如：<code>val max = mutableMap.values.max()</code><br>- <code>values.min()</code>：获取所有值中的最小值。<br>例如：<code>val min = mutableMap.values.min()</code></td><td>- <code>values.sum()</code>：计算所有值的总和（值需为数字类型）。<br>例如：<code>val sum = map.values.sum()</code><br>- <code>values.max()</code>：获取所有值中的最大值。<br>例如：<code>val max = map.values.max()</code><br>- <code>values.min()</code>：获取所有值中的最小值。<br>例如：<code>val min = map.values.min()</code></td></tr><tr><td>更改集合内容的操作（添加或删除键值对）</td><td>- <code>put()</code>：添加或更新键值对。<br>例如：<code>mutableMap.put(&quot;e&quot;, 5)</code><br>- <code>remove()</code>：移除指定键的键值对。<br>例如：<code>mutableMap.remove(&quot;b&quot;)</code></td><td>不支持，因为 <code>Map</code> 是不可变的，尝试添加或删除键值对会导致编译错误。</td></tr></tbody></table><p>以下是对应的 Kotlin 代码示例：</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">fun main() &#123;
    &#x2F;&#x2F; 构造
    &#x2F;&#x2F; MutableMap 的构造
    val mutableMap &#x3D; mutableMapOf(&quot;a&quot; to 1, &quot;b&quot; to 2)
    val mutableMapJavaStyle &#x3D; HashMap&lt;String, Int&gt;()
    mutableMapJavaStyle[&quot;c&quot;] &#x3D; 3
    mutableMapJavaStyle[&quot;d&quot;] &#x3D; 4
    println(&quot;MutableMap 构造: $mutableMap, $mutableMapJavaStyle&quot;)

    &#x2F;&#x2F; Map 的构造
    val map &#x3D; mapOf(&quot;e&quot; to 5, &quot;f&quot; to 6)
    val mapFromMutable &#x3D; mutableMap.toMap()
    println(&quot;Map 构造: $map, $mapFromMutable&quot;)

    &#x2F;&#x2F; 迭代器
    &#x2F;&#x2F; MutableMap 的迭代器
    println(&quot;MutableMap 迭代器:&quot;)
    val mutableIterator &#x3D; mutableMap.iterator()
    while (mutableIterator.hasNext()) &#123;
        val entry &#x3D; mutableIterator.next()
        println(&quot;$&#123;entry.key&#125;: $&#123;entry.value&#125;&quot;)
    &#125;

    &#x2F;&#x2F; Map 的迭代器
    println(&quot;Map 迭代器:&quot;)
    val mapIterator &#x3D; map.iterator()
    while (mapIterator.hasNext()) &#123;
        val entry &#x3D; mapIterator.next()
        println(&quot;$&#123;entry.key&#125;: $&#123;entry.value&#125;&quot;)
    &#125;

    &#x2F;&#x2F; 过滤
    &#x2F;&#x2F; MutableMap 的过滤
    val filteredMutableMap &#x3D; mutableMap.filter &#123; it.value % 2 &#x3D;&#x3D; 0 &#125;.toMutableMap()
    println(&quot;MutableMap 过滤: $filteredMutableMap&quot;)

    &#x2F;&#x2F; Map 的过滤
    val filteredMap &#x3D; map.filter &#123; it.value % 2 &#x3D;&#x3D; 0 &#125;
    println(&quot;Map 过滤: $filteredMap&quot;)

    &#x2F;&#x2F; 加减操作符
    &#x2F;&#x2F; MutableMap 的加减操作符
    val newMutableMapPlus &#x3D; mutableMap + (&quot;g&quot; to 7)
    println(&quot;MutableMap + 操作符: $newMutableMapPlus&quot;)
    mutableMap +&#x3D; (&quot;h&quot; to 8)
    println(&quot;MutableMap +&#x3D; 操作符: $mutableMap&quot;)
    val newMutableMapMinus &#x3D; mutableMap - &quot;a&quot;
    println(&quot;MutableMap - 操作符: $newMutableMapMinus&quot;)
    mutableMap -&#x3D; &quot;b&quot;
    println(&quot;MutableMap -&#x3D; 操作符: $mutableMap&quot;)

    &#x2F;&#x2F; Map 的加减操作符
    val newMapPlus &#x3D; map + (&quot;i&quot; to 9)
    println(&quot;Map + 操作符: $newMapPlus&quot;)
    val newMapMinus &#x3D; map - &quot;e&quot;
    println(&quot;Map - 操作符: $newMapMinus&quot;)

    &#x2F;&#x2F; 取单个元素
    &#x2F;&#x2F; MutableMap 取单个元素
    val mutableMapValue &#x3D; mutableMap[&quot;c&quot;]
    println(&quot;MutableMap 取单个元素: $mutableMapValue&quot;)

    &#x2F;&#x2F; Map 取单个元素
    val mapValue &#x3D; map[&quot;f&quot;]
    println(&quot;Map 取单个元素: $mapValue&quot;)

    &#x2F;&#x2F; 排序
    &#x2F;&#x2F; MutableMap 的排序
    val sortedMutableMapByKey &#x3D; mutableMap.toSortedMap()
    println(&quot;MutableMap 按键排序: $sortedMutableMapByKey&quot;)
    val sortedMutableMapByValue &#x3D; mutableMap.toList().sortedBy &#123; it.value &#125;.toMap().toMutableMap()
    println(&quot;MutableMap 按值排序: $sortedMutableMapByValue&quot;)

    &#x2F;&#x2F; Map 的排序
    val sortedMapByKey &#x3D; map.toSortedMap()
    println(&quot;Map 按键排序: $sortedMapByKey&quot;)
    val sortedMapByValue &#x3D; map.toList().sortedBy &#123; it.value &#125;.toMap()
    println(&quot;Map 按值排序: $sortedMapByValue&quot;)

    &#x2F;&#x2F; 聚合操作
    &#x2F;&#x2F; MutableMap 的聚合操作
    val mutableMapSum &#x3D; mutableMap.values.sum()
    val mutableMapMax &#x3D; mutableMap.values.max()
    val mutableMapMin &#x3D; mutableMap.values.min()
    println(&quot;MutableMap 聚合操作: sum&#x3D;$mutableMapSum, max&#x3D;$mutableMapMax, min&#x3D;$mutableMapMin&quot;)

    &#x2F;&#x2F; Map 的聚合操作
    val mapSum &#x3D; map.values.sum()
    val mapMax &#x3D; map.values.max()
    val mapMin &#x3D; map.values.min()
    println(&quot;Map 聚合操作: sum&#x3D;$mapSum, max&#x3D;$mapMax, min&#x3D;$mapMin&quot;)

    &#x2F;&#x2F; 更改集合内容的操作（添加或删除键值对）
    &#x2F;&#x2F; MutableMap 的更改操作
    mutableMap.put(&quot;j&quot;, 10)
    println(&quot;MutableMap 添加键值对后: $mutableMap&quot;)
    mutableMap.remove(&quot;c&quot;)
    println(&quot;MutableMap 移除键值对后: $mutableMap&quot;)

    &#x2F;&#x2F; Map 不支持更改操作，以下代码会导致编译错误
    &#x2F;&#x2F; map.put(&quot;k&quot;, 11)
    &#x2F;&#x2F; map.remove(&quot;f&quot;)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：<code>MutableMap</code> 是可变的，可以对其键值对进行添加、删除、修改等操作；而 <code>Map</code> 是不可变的，一旦创建，其键值对不能被修改，只能进行读取、过滤、聚合等不改变原映射的操作。</p><h3 id="与-Java-集合关系"><a href="#与-Java-集合关系" class="headerlink" title="与 Java 集合关系"></a>与 Java 集合关系</h3><p>以下是关于 <code>List</code>、<code>MutableList</code> 以及 <code>Map</code>、<code>MutableMap</code>、<code>Set</code>、<code>MutableSet</code> 相关的 Java 原型类型的详细说明：</p><h4 id="List-和-MutableList"><a href="#List-和-MutableList" class="headerlink" title="List 和 MutableList"></a><code>List</code> 和 <code>MutableList</code></h4><ul><li><code>**List**</code> 和 <code>MutableList</code> 与 <code>ArrayList</code>、<code>LinkedList</code> 的关系：<ul><li><code>List</code> 是 Kotlin 中的接口，它对应 Java 中的 <code>java.util.List</code> 接口。<code>List</code> 本身是只读的，不允许修改元素。</li><li><code>MutableList</code> 是 Kotlin 中的接口，对应 Java 中的 <code>java.util.List</code> 接口，不过它表示可变的列表，允许对列表元素进行添加、删除和修改等操作。</li><li><code>ArrayList</code> 和 <code>LinkedList</code> 都可以作为 <code>MutableList</code> 的实现。在 Kotlin 中，当你使用 <code>mutableListOf()</code> 函数创建一个可变列表时，默认情况下它会返回一个基于 <code>ArrayList</code> 的实现。例如：</li></ul></li></ul><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">val mutableList &#x3D; mutableListOf(1, 2, 3) &#x2F;&#x2F; 默认是 ArrayList 实现<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>- 如果你想明确使用 `LinkedList`，可以通过 Java 互操作性来实现：
</code></pre><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">import java.util.LinkedList

val linkedList: MutableList&lt;Int&gt; &#x3D; LinkedList&lt;Int&gt;()
linkedList.add(1)
linkedList.add(2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Map-和-MutableMap"><a href="#Map-和-MutableMap" class="headerlink" title="Map 和 MutableMap"></a><code>Map</code> 和 <code>MutableMap</code></h4><ul><li><strong>Java 原型类型</strong>：<ul><li><code>Map</code> 是 Kotlin 中的只读映射接口，对应 Java 中的 <code>java.util.Map</code> 接口。它表示一个键值对的集合，不允许修改其中的键值对。</li><li><code>MutableMap</code> 是 Kotlin 中的可变映射接口，也对应 Java 中的 <code>java.util.Map</code> 接口。它允许对映射中的键值对进行添加、删除和修改等操作。</li><li>在 Kotlin 中，当你使用 <code>mutableMapOf()</code> 函数创建一个可变映射时，默认情况下它会返回一个基于 <code>java.util.HashMap</code> 的实现。例如：</li></ul></li></ul><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">val mutableMap &#x3D; mutableMapOf(&quot;key1&quot; to 1, &quot;key2&quot; to 2) &#x2F;&#x2F; 默认是 HashMap 实现<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Set-和-MutableSet"><a href="#Set-和-MutableSet" class="headerlink" title="Set 和 MutableSet"></a><code>Set</code> 和 <code>MutableSet</code></h4><ul><li><strong>Java 原型类型</strong>：<ul><li><code>Set</code> 是 Kotlin 中的只读集合接口，对应 Java 中的 <code>java.util.Set</code> 接口。它表示一个不包含重复元素的集合，不允许修改集合中的元素。</li><li><code>MutableSet</code> 是 Kotlin 中的可变集合接口，也对应 Java 中的 <code>java.util.Set</code> 接口。它允许对集合中的元素进行添加、删除等操作。</li><li>在 Kotlin 中，当你使用 <code>mutableSetOf()</code> 函数创建一个可变集合时，默认情况下它会返回一个基于 <code>java.util.HashSet</code> 的实现。例如：</li></ul></li></ul><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">val mutableSet &#x3D; mutableSetOf(1, 2, 3) &#x2F;&#x2F; 默认是 HashSet 实现<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>总结如下：</p><table><thead><tr><th>Kotlin 类型</th><th>Java 原型接口</th><th>默认实现类</th></tr></thead><tbody><tr><td><code>List</code></td><td><code>java.util.List</code></td><td>无（只读）</td></tr><tr><td><code>MutableList</code></td><td><code>java.util.List</code></td><td><code>java.util.ArrayList</code></td></tr><tr><td><code>Map</code></td><td><code>java.util.Map</code></td><td>无（只读）</td></tr><tr><td><code>MutableMap</code></td><td><code>java.util.Map</code></td><td><code>java.util.HashMap</code></td></tr><tr><td><code>Set</code></td><td><code>java.util.Set</code></td><td>无（只读）</td></tr><tr><td><code>MutableSet</code></td><td><code>java.util.Set</code></td><td><code>java.util.HashSet</code></td></tr></tbody></table><h3 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h3><p><code>ArrayDeque</code> 是 Java 中的一个双端队列（Deque，Double Ended Queue）实现类，它基于数组实现，既可以作为栈（Stack）使用，也可以作为队列（Queue）使用，提供了高效的插入和删除操作。在 Kotlin 中可以通过 Java 互操作性来使用 <code>ArrayDeque</code>。</p><ul><li><strong>动态数组</strong>：<code>ArrayDeque</code> 内部使用动态数组来存储元素，当数组容量不足时会自动扩容。</li><li><strong>双端操作</strong>：支持在队列的两端（头部和尾部）进行插入和删除操作，时间复杂度为 $O(1)$。</li><li><strong>线程不安全</strong>：<code>ArrayDeque</code> 不是线程安全的，如果需要在多线程环境下使用，需要进行外部同步。</li></ul><p>这里我们列举了它的一些常用方法：</p><ul><li><strong>添加元素</strong>：<ul><li><code>addFirst(element)</code>：在队列头部添加元素。</li><li><code>addLast(element)</code>：在队列尾部添加元素。</li><li><code>offerFirst(element)</code>：在队列头部添加元素，添加失败返回 <code>false</code>。</li><li><code>offerLast(element)</code>：在队列尾部添加元素，添加失败返回 <code>false</code>。</li></ul></li><li><strong>删除元素</strong>：<ul><li><code>removeFirst()</code>：移除并返回队列头部的元素，队列为空时抛出异常。</li><li><code>removeLast()</code>：移除并返回队列尾部的元素，队列为空时抛出异常。</li><li><code>pollFirst()</code>：移除并返回队列头部的元素，队列为空时返回 <code>null</code>。</li><li><code>pollLast()</code>：移除并返回队列尾部的元素，队列为空时返回 <code>null</code>。</li></ul></li><li><strong>获取元素</strong>：<ul><li><code>getFirst()</code>：获取队列头部的元素，队列为空时抛出异常。</li><li><code>getLast()</code>：获取队列尾部的元素，队列为空时抛出异常。</li><li><code>peekFirst()</code>：获取队列头部的元素，队列为空时返回 <code>null</code>。</li><li><code>peekLast()</code>：获取队列尾部的元素，队列为空时返回 <code>null</code>。</li></ul></li></ul><p>以下是基于 Kotlin 的代码示例：</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">import java.util.ArrayDeque

fun main() &#123;
    &#x2F;&#x2F; 创建一个 ArrayDeque 实例
    val deque &#x3D; ArrayDeque&lt;Int&gt;()

    &#x2F;&#x2F; 在队列尾部添加元素
    deque.addLast(1)
    deque.addLast(2)
    deque.addLast(3)
    println(&quot;队列内容: $deque&quot;)

    &#x2F;&#x2F; 在队列头部添加元素
    deque.addFirst(0)
    println(&quot;在头部添加元素后: $deque&quot;)

    &#x2F;&#x2F; 获取队列头部的元素
    val firstElement &#x3D; deque.peekFirst()
    println(&quot;队列头部元素: $firstElement&quot;)

    &#x2F;&#x2F; 获取队列尾部的元素
    val lastElement &#x3D; deque.peekLast()
    println(&quot;队列尾部元素: $lastElement&quot;)

    &#x2F;&#x2F; 移除队列头部的元素
    val removedFirst &#x3D; deque.pollFirst()
    println(&quot;移除的头部元素: $removedFirst&quot;)
    println(&quot;移除头部元素后: $deque&quot;)

    &#x2F;&#x2F; 移除队列尾部的元素
    val removedLast &#x3D; deque.pollLast()
    println(&quot;移除的尾部元素: $removedLast&quot;)
    println(&quot;移除尾部元素后: $deque&quot;)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一般来说，<code>ArrayDeque</code> 用于以下情景：</p><ul><li><strong>栈的实现</strong>：由于 <code>ArrayDeque</code> 支持在一端进行高效的插入和删除操作，因此可以用它来实现栈。例如，在进行深度优先搜索（DFS）时，可以使用 <code>ArrayDeque</code> 来存储待访问的节点。</li><li><strong>队列的实现</strong>：<code>ArrayDeque</code> 也可以作为普通队列使用，支持在一端插入元素，在另一端删除元素。例如，在进行广度优先搜索（BFS）时，可以使用 <code>ArrayDeque</code> 来存储待访问的节点。</li><li><strong>双端队列的应用</strong>：在某些场景下，需要在队列的两端进行插入和删除操作，例如实现一个滑动窗口算法，<code>ArrayDeque</code> 可以提供高效的性能。</li></ul><p>Kotlin 的 <code>kotlinx.serialization</code> 是一个强大的跨平台序列化库，它允许你将 Kotlin 对象序列化为各种格式，以及从这些格式反序列化为 Kotlin 对象。以下是关于 <code>kotlinx.serialization</code> 及其支持的不同格式（JSON、Protocol buffers、CBOR、Properties、HOCON）的详细说明：</p><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p><code>kotlinx.serialization</code> 提供了一个统一的接口来处理不同格式的序列化和反序列化。通过添加相应的格式支持库，你可以轻松地在不同的格式之间切换，而无需编写大量的样板代码。每个格式的序列化和反序列化操作都非常相似，只是使用不同的编码器和解码器。</p><h3 id="导入包-数据类支持"><a href="#导入包-数据类支持" class="headerlink" title="导入包 &amp; 数据类支持"></a>导入包 &amp; 数据类支持</h3><p>首先，你需要在项目中添加相应的依赖。如果你使用的是 Gradle，以下是添加 <code>kotlinx.serialization</code> 核心库以及不同格式支持库的示例：</p><pre class="line-numbers language-Groovy" data-language="Groovy"><code class="language-Groovy">&#x2F;&#x2F; 核心库
implementation &quot;org.jetbrains.kotlinx:kotlinx-serialization-core:1.3.2&quot;

&#x2F;&#x2F; JSON 支持
implementation &quot;org.jetbrains.kotlinx:kotlinx-serialization-json:1.3.2&quot;

&#x2F;&#x2F; Protocol buffers 支持
implementation &quot;org.jetbrains.kotlinx:kotlinx-serialization-protobuf:1.3.2&quot;

&#x2F;&#x2F; CBOR 支持
implementation &quot;org.jetbrains.kotlinx:kotlinx-serialization-cbor:1.3.2&quot;

&#x2F;&#x2F; Properties 支持
implementation &quot;org.jetbrains.kotlinx:kotlinx-serialization-properties:1.3.2&quot;

&#x2F;&#x2F; HOCON 支持
implementation &quot;org.jetbrains.kotlinx:kotlinx-serialization-hocon:1.3.2&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要使用 <code>kotlinx.serialization</code>，你需要将你的数据类标记为 <code>@Serializable</code>。例如：</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">import kotlinx.serialization.Serializable

@Serializable
data class Person(
    val name: String,
    val age: Int
)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="JSON-序列化和反序列化"><a href="#JSON-序列化和反序列化" class="headerlink" title="JSON 序列化和反序列化"></a>JSON 序列化和反序列化</h3><p><code>kotlinx-serialization-json</code> 库用于处理 JSON 格式的序列化和反序列化。</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">import kotlinx.serialization.encodeToString
import kotlinx.serialization.decodeFromString
import kotlinx.serialization.json.Json

fun main() &#123;
    val person &#x3D; Person(&quot;John Doe&quot;, 30)

    &#x2F;&#x2F; 序列化
    val json &#x3D; Json.encodeToString(person)
    println(json) &#x2F;&#x2F; 输出: &#123;&quot;name&quot;:&quot;John Doe&quot;,&quot;age&quot;:30&#125;

    &#x2F;&#x2F; 反序列化
    val decodedPerson &#x3D; Json.decodeFromString&lt;Person&gt;(json)
    println(decodedPerson) &#x2F;&#x2F; 输出: Person(name&#x3D;John Doe, age&#x3D;30)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Protocol-buffers-序列化和反序列化"><a href="#Protocol-buffers-序列化和反序列化" class="headerlink" title="Protocol buffers 序列化和反序列化"></a>Protocol buffers 序列化和反序列化</h3><p><code>kotlinx-serialization-protobuf</code> 库用于处理 Protocol buffers 格式的序列化和反序列化。</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">import kotlinx.serialization.protobuf.ProtoBuf
import kotlinx.serialization.encodeToByteArray
import kotlinx.serialization.decodeFromByteArray

fun main() &#123;
    val person &#x3D; Person(&quot;John Doe&quot;, 30)

    &#x2F;&#x2F; 序列化
    val protoBytes &#x3D; ProtoBuf.encodeToByteArray(person)

    &#x2F;&#x2F; 反序列化
    val decodedPerson &#x3D; ProtoBuf.decodeFromByteArray&lt;Person&gt;(protoBytes)
    println(decodedPerson) &#x2F;&#x2F; 输出: Person(name&#x3D;John Doe, age&#x3D;30)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="CBOR-序列化和反序列化"><a href="#CBOR-序列化和反序列化" class="headerlink" title="CBOR 序列化和反序列化"></a>CBOR 序列化和反序列化</h3><p><code>kotlinx-serialization-cbor</code> 库用于处理 CBOR 格式的序列化和反序列化。</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">import kotlinx.serialization.cbor.Cbor
import kotlinx.serialization.encodeToByteArray
import kotlinx.serialization.decodeFromByteArray

fun main() &#123;
    val person &#x3D; Person(&quot;John Doe&quot;, 30)

    &#x2F;&#x2F; 序列化
    val cborBytes &#x3D; Cbor.encodeToByteArray(person)

    &#x2F;&#x2F; 反序列化
    val decodedPerson &#x3D; Cbor.decodeFromByteArray&lt;Person&gt;(cborBytes)
    println(decodedPerson) &#x2F;&#x2F; 输出: Person(name&#x3D;John Doe, age&#x3D;30)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Properties-序列化和反序列化"><a href="#Properties-序列化和反序列化" class="headerlink" title="Properties 序列化和反序列化"></a>Properties 序列化和反序列化</h3><p><code>kotlinx-serialization-properties</code> 库用于处理 Properties 格式的序列化和反序列化。</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">import kotlinx.serialization.encodeToString
import kotlinx.serialization.decodeFromString
import kotlinx.serialization.properties.Properties

fun main() &#123;
    val person &#x3D; Person(&quot;John Doe&quot;, 30)

    &#x2F;&#x2F; 序列化
    val propertiesString &#x3D; Properties.encodeToString(person)
    println(propertiesString) &#x2F;&#x2F; 输出: name&#x3D;John Doe\nage&#x3D;30

    &#x2F;&#x2F; 反序列化
    val decodedPerson &#x3D; Properties.decodeFromString&lt;Person&gt;(propertiesString)
    println(decodedPerson) &#x2F;&#x2F; 输出: Person(name&#x3D;John Doe, age&#x3D;30)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="HOCON-序列化和反序列化"><a href="#HOCON-序列化和反序列化" class="headerlink" title="HOCON 序列化和反序列化"></a>HOCON 序列化和反序列化</h3><p><code>kotlinx-serialization-hocon</code> 库用于处理 HOCON 格式的序列化和反序列化。</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">import kotlinx.serialization.encodeToString
import kotlinx.serialization.decodeFromString
import kotlinx.serialization.hocon.Hocon

fun main() &#123;
    val person &#x3D; Person(&quot;John Doe&quot;, 30)

    &#x2F;&#x2F; 序列化
    val hoconString &#x3D; Hocon.encodeToString(person)
    println(hoconString) &#x2F;&#x2F; 输出: name &#x3D; &quot;John Doe&quot;\nage &#x3D; 30

    &#x2F;&#x2F; 反序列化
    val decodedPerson &#x3D; Hocon.decodeFromString&lt;Person&gt;(hoconString)
    println(decodedPerson) &#x2F;&#x2F; 输出: Person(name&#x3D;John Doe, age&#x3D;30)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Lincheck 是一个用于测试并发数据结构线性一致性（linearizability）的框架，主要用于 Kotlin 和 Java 语言。以下是关于 Lincheck 的详细介绍：</p><h2 id="Lincheck"><a href="#Lincheck" class="headerlink" title="Lincheck"></a>Lincheck</h2><h3 id="线性一致性（Linearizability）"><a href="#线性一致性（Linearizability）" class="headerlink" title="线性一致性（Linearizability）"></a>线性一致性（Linearizability）</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>线性一致性是并发数据结构的一个重要正确性属性。简单来说，如果一个并发数据结构是线性一致的，<strong>那么它的所有操作看起来就像是以某种原子方式顺序执行的</strong>，即每个操作都在某个时刻瞬间完成，并且这些操作的执行顺序与程序的并发执行历史是一致的。</p><p>在多线程程序中，多个线程可能会访问同一块内存区域或共享变量：</p><ul><li>例如，线程A和线程B可能同时对一个全局变量进行读写操作。线程一致性要求在一个线程对共享数据进行写操作后，其他线程在读取该数据时，能够看到最新的值。如果一个线程更新了数据，另一个线程应该能立即或在合理的时间内看到这个更新。</li><li>为了保证线程一致性，必须确保数据的可见性。即，一个线程对共享数据的修改，应该能被其他线程及时感知到。这通常通过锁、同步机制（如互斥锁、信号量）或内存屏障来实现。</li><li>编译器和处理器可能会对指令进行重排序，以优化性能，这可能导致线程间的执行顺序不一致。为了避免这种情况，程序需要使用适当的同步机制来确保操作的顺序。</li></ul><p>总而言之，在多线程环境下，不满足线程一致性的程序可能会导致这些问题：</p><ul><li><strong>共享资源冲突</strong>：当多个线程同时读写同一块内存或资源时，可能导致数据不一致。</li><li><strong>竞态条件（Race Condition）</strong>：线程执行顺序不确定，导致结果依赖于线程调度顺序。</li><li><strong>内存可见性问题</strong>：某个线程修改了共享数据，其他线程可能无法立即看到修改后的值。</li></ul><p>根据问题分析，我们可以确定相应的解决方案。</p><p>（1）<strong>原子性（Atomicity）</strong></p><ul><li><strong>问题</strong>：一个操作（如 <code>i++</code>）可能被拆分为多个步骤（读、改、写），若中途被其他线程打断，会导致结果错误。</li><li><strong>解决方案</strong>：<ul><li><strong>锁（Lock）</strong>：如 <code>synchronized</code>（Java）、<code>mutex</code>（C++）。</li><li><strong>原子变量（Atomic Variables）</strong>：如 <code>AtomicInteger</code>（Java）、<code>std::atomic</code>（C++）。</li></ul></li></ul><p>（2）<strong>可见性（Visibility）</strong></p><ul><li><strong>问题</strong>：线程A修改了共享变量，但线程B可能因缓存（CPU缓存、寄存器）未刷新而读到旧值。</li><li><strong>解决方案</strong>：<ul><li><code>volatile</code><strong>关键字</strong>（Java）：强制线程从主内存读写变量。</li><li><strong>内存屏障（Memory Barrier）</strong>：确保指令执行顺序和内存可见性。</li></ul></li></ul><p>（3）<strong>有序性（Ordering）</strong></p><ul><li><strong>问题</strong>：编译器或CPU可能对指令重排序（优化），导致代码执行顺序与预期不符。</li><li><strong>解决方案</strong>：<ul><li><code>synchronized</code><strong>或锁</strong>：限制指令重排序。</li><li><code>volatile</code><strong>关键字</strong>：禁止对 volatile 变量的操作重排序。</li></ul></li></ul><p>以<strong>线程安全的数据结构为例子，我们</strong>考虑如下代码 <code>ConcurrentStack</code>，<code>java.util.Stack</code> 是一个典型的线程安全数据结构，即并发栈：</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">class ConcurrentStack&lt;T&gt; &#123;
    private val stack &#x3D; java.util.Stack&lt;T&gt;()

    @Operation
    fun push(value: T) &#123;
        stack.push(value)
    &#125;

    @Operation
    fun pop(): T? &#123;
        return if (stack.isEmpty()) null else stack.pop()
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，多个线程可以同时操作 <code>push</code> 和 <code>pop</code> 方法。</p><h4 id="并发时的行为差异"><a href="#并发时的行为差异" class="headerlink" title="并发时的行为差异"></a>并发时的行为差异</h4><ul><li>非并发情况下的行为</li></ul><p>在非并发（单线程）环境下，<code>ConcurrentStack</code> 的行为是非常直观的。当调用 <code>push</code> 方法时，元素会按顺序依次被添加到栈顶；当调用 <code>pop</code> 方法时，栈顶元素会被移除并返回。操作是顺序执行的，不会出现数据不一致的问题。</p><p>例如，以下是单线程环境下的操作序列：</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">val stack &#x3D; ConcurrentStack&lt;Int&gt;()
stack.push(1)
stack.push(2)
val topElement &#x3D; stack.pop() &#x2F;&#x2F; 返回 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>并发情况下的行为</li></ul><p>在并发（多线程）环境下，<code>ConcurrentStack</code> 的行为会变得复杂。多个线程可能同时尝试对栈进行 <code>push</code> 或 <code>pop</code> 操作，这可能会导致以下几种情况：</p><ol><li><strong>竞态条件（Race Condition）</strong>：<ul><li>多个线程同时调用 <code>push</code> 方法，可能会导致元素的插入顺序不符合预期。例如，线程 A 和线程 B 同时调用 <code>push</code> 方法，由于线程调度的不确定性，最终栈中的元素顺序可能会出现混乱。</li><li>多个线程同时调用 <code>pop</code> 方法，可能会导致某个线程获取到错误的栈顶元素，或者在栈为空时仍然尝试弹出元素。</li></ul></li><li><strong>数据不一致</strong>：<ul><li>当一个线程正在执行 <code>pop</code> 操作，而另一个线程同时执行 <code>push</code> 操作时，可能会导致栈的状态不一致。例如，<code>pop</code> 操作可能会在 <code>push</code> 操作完成之前判断栈为空，从而返回 <code>null</code>，而实际上栈中已经有元素被添加。</li></ul></li></ol><p>具体来说，以下是一些符合线性一致性的示例：</p><ul><li><strong>示例 1：并发</strong><code>**push**</code><strong>操作</strong><ul><li>线程 A 调用 <code>push(1)</code>，线程 B 调用 <code>push(2)</code>，最终栈中的元素顺序应该是 <code>2</code> 在栈顶，<code>1</code> 在栈底，或者 <code>1</code> 在栈顶，<code>2</code> 在栈底，这取决于线程调度的顺序。但无论如何，栈中的元素数量应该是正确的，并且后续的 <code>pop</code> 操作应该按照栈的规则依次返回元素。</li></ul></li><li><strong>示例 2：并发</strong><code>**pop**</code><strong>操作</strong><ul><li>线程 A 和线程 B 同时调用 <code>pop</code> 方法，栈中最初有两个元素 <code>[2, 1]</code>（<code>2</code> 为栈顶）。最终，两个线程应该分别获取到 <code>2</code> 和 <code>1</code>，不会出现两个线程都获取到 <code>2</code> 或者都获取到 <code>1</code> 的情况。</li></ul></li><li><strong>示例 3：并发</strong><code>**push**</code> 和 <code>pop</code><strong>操作</strong><ul><li>线程 A 调用 <code>push(1)</code>，线程 B 调用 <code>pop()</code>。如果 <code>push</code> 操作先于 <code>pop</code> 操作完成，那么 <code>pop</code> 操作应该返回 <code>1</code>；如果 <code>pop</code> 操作在 <code>push</code> 操作之前判断栈为空，那么 <code>pop</code> 操作应该返回 <code>null</code>。</li></ul></li></ul><h3 id="Lincheck-的主要功能和特点"><a href="#Lincheck-的主要功能和特点" class="headerlink" title="Lincheck 的主要功能和特点"></a>Lincheck 的主要功能和特点</h3><p>Lincheck 是一个用于测试并发数据结构线性一致性（linearizability）的框架，主要用于 Kotlin 和 Java 语言。以下是关于 Lincheck 的详细介绍：</p><h4 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h4><ul><li>自动生成测试用例：Lincheck 能够自动生成大量的并发测试用例，这些测试用例包含不同的操作组合和不同的线程交错执行情况。通过随机生成这些测试用例，Lincheck 可以覆盖到各种可能的并发场景，从而更全面地测试并发数据结构的正确性。</li><li>自动检查线性一致性：在执行生成的测试用例后，Lincheck 会自动检查并发数据结构的执行结果是否满足线性一致性。它会分析操作的执行顺序和结果，判断是否存在违反线性一致性的情况。</li></ul><h4 id="简洁易用"><a href="#简洁易用" class="headerlink" title="简洁易用"></a>简洁易用</h4><ul><li>注解驱动：Lincheck 使用注解来定义测试类和测试方法，开发人员只需要在代码中添加少量的注解，就可以快速创建并发测试。例如，使用 <code>@Operation</code> 注解来标记并发数据结构的操作方法，使用 <code>@Param</code> 注解来定义操作的参数范围等。</li><li>集成方便：Lincheck 可以很方便地集成到现有的测试框架中，如 JUnit 或 Kotlin 的测试框架。开发人员可以将 Lincheck 测试作为普通的单元测试来运行，无需进行复杂的配置。</li></ul><h4 id="跨平台支持"><a href="#跨平台支持" class="headerlink" title="跨平台支持"></a>跨平台支持</h4><p>Lincheck 支持多种并发模型和执行环境，包括 Java 的线程、Kotlin 的协程等。这使得它可以在不同的平台和并发编程模型下进行并发数据结构的测试。</p><h4 id="详细的错误报告"><a href="#详细的错误报告" class="headerlink" title="详细的错误报告"></a>详细的错误报告</h4><p>当 Lincheck 检测到并发数据结构存在线性一致性问题时，它会提供详细的错误报告。报告中会包含测试用例的执行历史、操作的调用顺序、线程的交错情况以及违反线性一致性的具体原因等信息。这些信息可以帮助开发人员快速定位和修复并发数据结构中的问题。</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>以下是一个使用 Lincheck 测试并发栈的简单示例：</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">import kotlinx.coroutines.*
import org.jetbrains.kotlinx.lincheck.*
import org.jetbrains.kotlinx.lincheck.annotations.*
import org.jetbrains.kotlinx.lincheck.strategy.managed.modelchecking.*
import org.jetbrains.kotlinx.lincheck.verifier.*

&#x2F;&#x2F; 定义并发栈类
class ConcurrentStack&lt;T&gt; &#123;
    private val stack &#x3D; java.util.Stack&lt;T&gt;()

    @Operation
    fun push(value: T) &#123;
        stack.push(value)
    &#125;

    @Operation
    fun pop(): T? &#123;
        return if (stack.isEmpty()) null else stack.pop()
    &#125;
&#125;

&#x2F;&#x2F; 测试类
class ConcurrentStackTest &#123;
    private val stack &#x3D; ConcurrentStack&lt;Int&gt;()

    @Operation
    fun push(@Param(name &#x3D; &quot;value&quot;) value: Int) &#x3D; stack.push(value)

    @Operation
    fun pop() &#x3D; stack.pop()

    &#x2F;&#x2F; 测试配置
    @Test
    fun test() &#123;
        val options &#x3D; ModelCheckingOptions()
            .iterations(100) &#x2F;&#x2F; 测试迭代次数
            .threads(3) &#x2F;&#x2F; 并发线程数
            .actorsPerThread(5) &#x2F;&#x2F; 每个线程的操作数
        val result &#x3D; ModelCheckingChecker.check(this::class.java, options)
        assert(result.passed())
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个示例中，我们定义了一个简单的并发栈类 <code>ConcurrentStack</code>，并使用 Lincheck 对其进行测试。通过 <code>@Operation</code> 注解标记了栈的 <code>push</code> 和 <code>pop</code> 操作，然后在测试类 <code>ConcurrentStackTest</code> 中定义了相应的测试方法。最后，使用 <code>ModelCheckingChecker</code> 来执行测试，并通过 <code>assert(result.passed())</code> 来验证测试是否通过。</p><p>在 <code>ConcurrentStack</code> 类中，<code>push</code> 和 <code>pop</code> 方法被标记为 <code>@Operation</code> 注解。这是 Lincheck 框架的一个重要特性，用于指定这些方法是并发操作的一部分。通过这种方式，Lincheck 可以自动生成不同的并发测试用例，模拟多个线程同时调用这些方法的情况，从而测试该栈在并发环境下的行为。</p><p>使用 Lincheck 进行测试时，如果 <code>ConcurrentStack</code> 满足线性一致性，测试应该通过，即 <code>ModelCheckingChecker.check</code> 方法的返回结果的 <code>passed()</code> 方法应该返回 <code>true</code>。</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">val result &#x3D; ModelCheckingChecker.check(this::class.java, options)
assert(result.passed())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果测试不通过，Lincheck 会提供详细的错误报告，包括测试用例的执行历史、操作的调用顺序、线程的交错情况以及违反线性一致性的具体原因等信息，帮助开发人员定位和修复问题。</p><p>总之，符合预期的测试结果是 <code>ConcurrentStack</code> 在并发环境下的操作满足线性一致性，不会出现竞态条件和数据不一致的问题。</p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><h3 id="协程与线程进程的关系"><a href="#协程与线程进程的关系" class="headerlink" title="协程与线程进程的关系"></a>协程与线程进程的关系</h3><p>好的！以下是 <strong>协程（Coroutine）、线程（Thread）、进程（Process）</strong> 的关系解析，结合 <strong>Kotlin 代码示例</strong> 说明它们的区别和使用场景。</p><h4 id="关系概述与核心区别"><a href="#关系概述与核心区别" class="headerlink" title="关系概述与核心区别"></a><strong>关系概述与核心区别</strong></h4><table><thead><tr><th><strong>概念</strong></th><th><strong>定义</strong></th><th><strong>关系</strong></th></tr></thead><tbody><tr><td><strong>进程</strong></td><td>操作系统资源分配的基本单位，独立的内存空间和系统资源（如文件句柄）。</td><td><strong>进程 &gt; 线程 &gt; 协程</strong>：一个进程包含多个线程，一个线程可以运行多个协程。协程是线程中的轻量级任务。</td></tr><tr><td><strong>线程</strong></td><td>进程内的执行单元，共享进程的内存和资源，但有自己的栈和寄存器。</td><td>线程由操作系统调度，协程由开发者或协程库调度。</td></tr><tr><td><strong>协程</strong></td><td>用户态的轻量级线程，由程序控制调度（非抢占式），挂起时不会阻塞线程。</td><td>协程运行在线程之上，一个线程可同时执行多个协程（通过挂起&#x2F;恢复）。</td></tr></tbody></table><table><thead><tr><th><strong>特性</strong></th><th><strong>进程</strong></th><th><strong>线程</strong></th><th><strong>协程</strong></th></tr></thead><tbody><tr><td><strong>资源开销</strong></td><td>高（独立内存）</td><td>中（共享内存）</td><td>极低（无内核切换）</td></tr><tr><td><strong>调度方式</strong></td><td>操作系统调度</td><td>操作系统调度</td><td>程序控制（协作式调度）</td></tr><tr><td><strong>并发性</strong></td><td>多进程并行</td><td>多线程并行（需多核CPU）</td><td>单线程内伪并行（通过挂起）</td></tr><tr><td><strong>通信成本</strong></td><td>高（IPC机制）</td><td>中（共享内存+锁）</td><td>低（直接共享变量）</td></tr><tr><td><strong>适用场景</strong></td><td>高隔离性任务（如浏览器）</td><td>CPU密集型任务</td><td>I&#x2F;O密集型、高并发任务</td></tr></tbody></table><p>协程是可挂起计算的一个实例。从概念上讲，它与线程类似，都需要一个代码块与其他代码同时运行。不过，例程并不受制于任何特定的线程。它可以在一个线程中暂停执行，然后在另一个线程中继续执行。</p><p>可以把协程看作轻量级线程，但它们在实际使用中与线程有许多重要区别。</p><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a><strong>代码示例</strong></h4><ul><li><strong>(1) 进程</strong></li></ul><p>Kotlin&#x2F;JVM 中直接操作进程较少见（通常通过 <code>ProcessBuilder</code>），但可以启动独立程序：</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">&#x2F;&#x2F; 启动一个外部进程（如打开计算器）
val process &#x3D; ProcessBuilder(&quot;calc.exe&quot;).start()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><strong>(2) 线程</strong></li></ul><p>Kotlin 通过 <code>thread</code> 函数或 <code>Executor</code> 创建线程：</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">&#x2F;&#x2F; 方式1：直接启动线程
thread(name &#x3D; &quot;MyThread&quot;) &#123;
    println(&quot;Thread running: $&#123;Thread.currentThread().name&#125;&quot;)
    Thread.sleep(1000) &#x2F;&#x2F; 阻塞线程
&#125;

&#x2F;&#x2F; 方式2：使用线程池
val executor &#x3D; Executors.newFixedThreadPool(2)
executor.submit &#123;
    println(&quot;Pool thread: $&#123;Thread.currentThread().name&#125;&quot;)
&#125;
executor.shutdown()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>(3) 协程</strong></li></ul><p>Kotlin 协程通过 <code>kotlinx.coroutines</code> 库实现：</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">import kotlinx.coroutines.*

fun main() &#x3D; runBlocking &#123;
    &#x2F;&#x2F; 启动一个协程（不阻塞当前线程）
    val job &#x3D; launch(Dispatchers.Default) &#123;
        println(&quot;Coroutine started on thread: $&#123;Thread.currentThread().name&#125;&quot;)
        delay(1000) &#x2F;&#x2F; 挂起协程，不阻塞线程
        println(&quot;Coroutine resumed!&quot;)
    &#125;

    &#x2F;&#x2F; 启动多个协程（单线程内并发）
    val deferredResults &#x3D; (1..3).map &#123; i -&gt;
        async &#123;
            delay(1000L * i)
            &quot;Result $i&quot;
        &#125;
    &#125;

    &#x2F;&#x2F; 等待所有结果
    deferredResults.forEach &#123; println(it.await()) &#125;

    job.join() &#x2F;&#x2F; 等待协程结束
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>输出示例：</strong></p><pre class="line-numbers language-PlainText" data-language="PlainText"><code class="language-PlainText">Coroutine started on thread: DefaultDispatcher-worker-1
Result 1
Result 2
Result 3
Coroutine resumed!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="协程与线程的协作"><a href="#协程与线程的协作" class="headerlink" title="协程与线程的协作"></a><strong>协程与线程的协作</strong></h4><p>协程可以指定调度器（Dispatcher），决定它运行在哪个线程：</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">fun main() &#x3D; runBlocking &#123;
    &#x2F;&#x2F; 协程1：运行在IO线程池
    launch(Dispatchers.IO) &#123;
        println(&quot;IO work on: $&#123;Thread.currentThread().name&#125;&quot;)
    &#125;

    &#x2F;&#x2F; 协程2：运行在主线程（Android中常用）
    launch(Dispatchers.Main) &#123;
        println(&quot;UI update on: $&#123;Thread.currentThread().name&#125;&quot;)
    &#125;

    &#x2F;&#x2F; 协程3：切换线程
    withContext(Dispatchers.Default) &#123;
        println(&quot;Computation on: $&#123;Thread.currentThread().name&#125;&quot;)
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>进程</strong>：资源隔离，适合独立任务（如浏览器标签）。</li><li><strong>线程</strong>：共享进程资源，适合CPU密集型任务，但需处理同步问题。</li><li><strong>协程</strong>：轻量级，适合高并发I&#x2F;O任务（如网络请求、数据库操作），通过挂起避免线程阻塞。</li></ul><p>在 Kotlin 中，协程是替代回调&#x2F;线程池的最佳实践，通过 <code>suspend</code> 函数和结构化并发简化异步代码。</p><h3 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h3><p>在 Kotlin 协程中，虽然协程的核心功能由 <code>kotlinx.coroutines</code> 库提供，但语言本身也通过一些关键字和库函数来支持协程编程。以下是关键概念和协程启动过程的详细说明：</p><h4 id="协程的「关键字」与核心概念"><a href="#协程的「关键字」与核心概念" class="headerlink" title="协程的「关键字」与核心概念"></a><strong>协程的「关键字」与核心概念</strong></h4><p>严格来说，Kotlin 协程的专用关键字只有 <code>suspend</code>，其他是协程库中的函数或类。以下是关键术语及其作用：</p><table><thead><tr><th><strong>关键字&#x2F;函数&#x2F;类</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><code>**suspend**</code></td><td>标记函数为挂起函数，只能在协程或其他挂起函数中调用。</td></tr><tr><td><code>**CoroutineScope**</code></td><td>协程作用域，管理协程的生命周期（如取消）。</td></tr><tr><td><code>**launch**</code></td><td>启动一个不返回结果的协程（返回 <code>Job</code>）。</td></tr><tr><td><code>**async**</code></td><td>启动一个返回 <code>Deferred&lt;T&gt;</code> 的协程（可通过 <code>await()</code> 获取结果）。</td></tr><tr><td><code>**runBlocking**</code></td><td>创建一个阻塞当前线程的协程作用域，通常用于测试或 <code>main</code> 函数。</td></tr><tr><td><code>**withContext**</code></td><td>切换协程的上下文（如线程池），并返回结果。</td></tr><tr><td><code>**Job**</code></td><td>表示一个协程的任务，用于控制生命周期（取消、等待完成）。</td></tr><tr><td><code>**Deferred**</code></td><td>继承自 <code>Job</code>，表示一个异步计算的结果（通过 <code>async</code> 启动）。</td></tr><tr><td><code>**CoroutineDispatcher**</code></td><td>协程调度器，决定协程在哪个线程池运行（如 <code>Dispatchers.IO</code>）。</td></tr><tr><td><code>**coroutineScope**</code></td><td>创建一个子作用域，所有子协程完成前不会退出。</td></tr><tr><td><code>**supervisorScope**</code></td><td>类似 <code>coroutineScope</code>，但子协程的失败不会影响其他子协程。</td></tr></tbody></table><h4 id="如何启动一个协程？"><a href="#如何启动一个协程？" class="headerlink" title="如何启动一个协程？"></a><strong>如何启动一个协程？</strong></h4><ul><li><strong>(1) 添加依赖</strong></li></ul><p>在 <code>build.gradle.kts</code> 中添加协程库依赖（必需）：</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">dependencies &#123;
    implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.8.0&quot;)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><strong>(2) 启动协程的两种方式</strong></li></ul><p><strong>方式 1：</strong><code>launch</code><strong>（不返回结果）</strong></p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">import kotlinx.coroutines.*

fun main() &#x3D; runBlocking &#123; &#x2F;&#x2F; 1. 创建阻塞式协程作用域
    val job &#x3D; launch &#123;     &#x2F;&#x2F; 2. 启动协程，返回 Job
        delay(1000)        &#x2F;&#x2F; 3. 挂起协程，不阻塞线程
        println(&quot;World!&quot;)
    &#125;
    println(&quot;Hello,&quot;)
    job.join()            &#x2F;&#x2F; 4. 等待协程完成
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>方式 2：</strong><code>async</code><strong>（返回结果）</strong></p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">import kotlinx.coroutines.*

fun main() &#x3D; runBlocking &#123;
    val deferred &#x3D; async &#123; &#x2F;&#x2F; 启动协程，返回 Deferred&lt;Int&gt;
        delay(1000)
        42
    &#125;
    println(&quot;Result: $&#123;deferred.await()&#125;&quot;) &#x2F;&#x2F; 等待结果
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3. 关键代码元素解析</strong></p><p><strong>(1)</strong><code>**runBlocking**</code></p><ul><li><strong>作用</strong>：创建一个阻塞当前线程的协程作用域，直到内部所有协程完成。</li><li><strong>使用场景</strong>：用于 <code>main</code> 函数或测试代码，将阻塞代码与协程桥接。</li></ul><p><strong>(2)</strong><code>**launch**</code> 和 <code>**async**</code></p><table><thead><tr><th><strong>对比项</strong></th><th><code>**launch**</code></th><th><code>**async**</code></th></tr></thead><tbody><tr><td><strong>返回值</strong></td><td><code>Job</code>（表示任务）</td><td><code>Deferred&lt;T&gt;</code>（延迟计算的结果）</td></tr><tr><td><strong>用途</strong></td><td>执行不需要返回值的任务（如日志、更新UI）</td><td>执行需要返回值的异步计算（如网络请求）</td></tr><tr><td><strong>结果获取</strong></td><td>无</td><td>通过 <code>await()</code> 获取结果</td></tr></tbody></table><p><strong>(3)</strong><code>**suspend**</code><strong>函数</strong></p><ul><li><strong>定义</strong>：只能在协程或其他挂起函数中调用的函数。</li><li><strong>示例</strong>：</li></ul><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">suspend fun fetchData(): String &#123;
    delay(1000)
    return &quot;Data loaded&quot;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>(4)</strong><code>**withContext**</code></p><ul><li><strong>作用</strong>：切换协程的调度器（如从 IO 线程切换到主线程）。</li><li><strong>示例</strong>：</li></ul><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">suspend fun loadData() &#x3D; withContext(Dispatchers.IO) &#123;
    &#x2F;&#x2F; 在 IO 线程执行耗时操作
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="协程调度器（Dispatchers）"><a href="#协程调度器（Dispatchers）" class="headerlink" title="协程调度器（Dispatchers）"></a><strong>协程调度器（Dispatchers）</strong></h4><table><thead><tr><th><strong>调度器</strong></th><th><strong>用途</strong></th></tr></thead><tbody><tr><td><code>Dispatchers.Default</code></td><td>CPU 密集型任务（如计算、排序）</td></tr><tr><td><code>Dispatchers.IO</code></td><td>I&#x2F;O 密集型任务（如网络请求、文件读写）</td></tr><tr><td><code>Dispatchers.Main</code></td><td>主线程更新 UI（Android 或 JavaFX）</td></tr><tr><td><code>Dispatchers.Unconfined</code></td><td>不限制线程（慎用）</td></tr></tbody></table><h4 id="结构化并发示例"><a href="#结构化并发示例" class="headerlink" title="结构化并发示例"></a><strong>结构化并发示例</strong></h4><p>协程通过作用域（<code>CoroutineScope</code>）实现结构化生命周期管理：</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">import kotlinx.coroutines.*

fun main() &#x3D; runBlocking &#123;
    &#x2F;&#x2F; 父协程
    coroutineScope &#123; &#x2F;&#x2F; 所有子协程完成前不会退出
        launch &#123; 
            delay(1000)
            println(&quot;Task 1&quot;)
        &#125;
        launch &#123;
            delay(500)
            println(&quot;Task 2&quot;)
        &#125;
    &#125;
    println(&quot;All tasks completed!&quot;)
&#125;
&#x2F;&#x2F; 输出顺序：Task 2 → Task 1 → All tasks completed!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><ul><li><strong>核心关键字</strong>：<code>suspend</code>。</li><li><strong>启动协程</strong>：通过 <code>launch</code> 或 <code>async</code>，需在协程作用域（如 <code>runBlocking</code>）内调用。</li><li><strong>调度器</strong>：通过 <code>Dispatchers</code> 指定协程运行的线程池。</li><li><strong>结构化并发</strong>：通过 <code>coroutineScope</code> 或 <code>supervisorScope</code> 管理子协程。</li></ul><h3 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h3><h4 id="协程的取消与超时"><a href="#协程的取消与超时" class="headerlink" title="协程的取消与超时"></a>协程的取消与超时</h4><p>Kotlin 协程支持通过 <code>CoroutineScope</code> 来取消协程。你可以调用 <code>cancel()</code> 方法来取消一个协程。使用 <code>withTimeout</code> 函数可以设置一个超时时间，如果在规定时间内协程未完成，则会被取消。</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">import kotlinx.coroutines.*
fun main() &#x3D; runBlocking &#123;
    val job &#x3D; launch &#123;
        &#x2F;&#x2F; 模拟长时间运行的任务
        repeat(1000) &#123; i -&gt;
            println(&quot;Job: $i&quot;)
            delay(500L)
        &#125;
    &#125;

    delay(1300L) &#x2F;&#x2F; 等待一段时间
    job.cancel() &#x2F;&#x2F; 取消协程
    println(&quot;Job cancelled&quot;)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="组合挂起函数"><a href="#组合挂起函数" class="headerlink" title="组合挂起函数"></a>组合挂起函数</h4><p>挂起函数可以组合使用，允许在一个协程中调用多个挂起函数。通过使用 <code>async</code> 和 <code>await</code>，可以并行执行多个任务，并在需要时等待它们完成。</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">suspend fun fetchData(): String &#123;
    &#x2F;&#x2F; 模拟网络请求
    delay(1000)
    return &quot;Data&quot;
&#125;
fun main() &#x3D; runBlocking &#123;
    val data &#x3D; async &#123; fetchData() &#125;
    println(&quot;Fetching data...&quot;)
    println(data.await()) &#x2F;&#x2F; 等待数据返回
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="异步流"><a href="#异步流" class="headerlink" title="异步流"></a>异步流</h4><p>Kotlin 的 <code>Flow</code> 提供了一种异步流的方式来处理数据流。<code>Flow</code> 是冷流（cold stream），只有在收集时才会开始执行。</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">import kotlinx.coroutines.flow.*
fun simpleFlow(): Flow&lt;Int&gt; &#x3D; flow &#123;
    for (i in 1..3) &#123;
        delay(1000) &#x2F;&#x2F; 模拟耗时操作
        emit(i) &#x2F;&#x2F; 发射下一个值
    &#125;
&#125;
fun main() &#x3D; runBlocking &#123;
    simpleFlow().collect &#123; value -&gt;
        println(value)
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h4><p>通道（Channel）是一个用于在协程之间传输数据的非阻塞队列。它可以用于实现生产者-消费者模式。</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">import kotlinx.coroutines.channels.*
fun main() &#x3D; runBlocking &#123;
    val channel &#x3D; Channel&lt;Int&gt;()
    &#x2F;&#x2F; 生产者
    launch &#123;
        for (x in 1..5) channel.send(x * x) &#x2F;&#x2F; 发送平方数
        channel.close() &#x2F;&#x2F; 关闭通道
    &#125;
    &#x2F;&#x2F; 消费者
    for (y in channel) &#123;
        println(y) &#x2F;&#x2F; 接收并打印
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="协程异常处理"><a href="#协程异常处理" class="headerlink" title="协程异常处理"></a>协程异常处理</h4><p>Kotlin 协程提供了 <code>CoroutineExceptionHandler</code> 来处理协程中的异常。</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">val handler &#x3D; CoroutineExceptionHandler &#123; _, exception -&gt;
    println(&quot;Caught $exception&quot;)
&#125;
fun main() &#x3D; runBlocking(handler) &#123;
    launch &#123;
        throw AssertionError(&quot;Something went wrong!&quot;)
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="共享的可变状态与并发"><a href="#共享的可变状态与并发" class="headerlink" title="共享的可变状态与并发"></a>共享的可变状态与并发</h4><p>Kotlin 协程支持共享可变状态，使用 <code>Mutex</code> 和 <code>Atomic</code> 类型来保证线程安全。</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.sync.Mutex
import kotlinx.coroutines.sync.withLock
var counter &#x3D; 0
val mutex &#x3D; Mutex()
suspend fun increment() &#123;
    mutex.withLock &#123;
        counter++
    &#125;
&#125;
fun main() &#x3D; runBlocking &#123;
    val jobs &#x3D; List(100) &#123;
        launch &#123;
            repeat(1000) &#123;
                increment()
            &#125;
        &#125;
    &#125;
    jobs.forEach &#123; it.join() &#125;
    println(&quot;Counter &#x3D; $counter&quot;)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="日期与时间"><a href="#日期与时间" class="headerlink" title="日期与时间"></a>日期与时间</h2><p><code>kotlinx-datetime</code> 是 Kotlin 官方推出的跨平台日期时间处理库，旨在为 Kotlin Multiplatform 项目提供统一的日期时间操作 API。它设计简洁且与 Java 的 <code>java.time</code> 包类似，但完全兼容 Kotlin 的跨平台特性（支持 JVM、JS、Native 等平台）。</p><h3 id="基本使用-2"><a href="#基本使用-2" class="headerlink" title="基本使用"></a>基本使用</h3><ul><li>在 <code>build.gradle.kts</code> 中添加依赖：</li></ul><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">kotlin &#123;
    sourceSets &#123;
        commonMain &#123;
            dependencies &#123;
                implementation(&quot;org.jetbrains.kotlinx:kotlinx-datetime:0.4.0&quot;) &#x2F;&#x2F; 检查最新版本
            &#125;
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>创建日期时间对象</strong></li></ul><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">import kotlinx.datetime.*

&#x2F;&#x2F; 获取当前时间（基于系统时钟）
val now: Instant &#x3D; Clock.System.now()

&#x2F;&#x2F; 创建 LocalDate（日期）
val date &#x3D; LocalDate(2023, 10, 1)

&#x2F;&#x2F; 创建 LocalDateTime（日期 + 时间）
val dateTime &#x3D; LocalDateTime(2023, 10, 1, 12, 30, 15)

&#x2F;&#x2F; 解析字符串为日期时间
val parsedDate &#x3D; LocalDate.parse(&quot;2023-10-01&quot;)
val parsedDateTime &#x3D; LocalDateTime.parse(&quot;2023-10-01T12:30:15&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>格式化与解析</strong></li></ul><p>使用 <code>format</code> 和 <code>parse</code> 进行字符串转换：</p><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">import kotlinx.datetime.format.*

&#x2F;&#x2F; 自定义格式
val format &#x3D; LocalDate.Format &#123;
    year()
    char(&#39;&#x2F;&#39;)
    monthNumber()
    char(&#39;&#x2F;&#39;)
    dayOfMonth()
&#125;

val dateString &#x3D; format.format(LocalDate(2023, 10, 1)) &#x2F;&#x2F; &quot;2023&#x2F;10&#x2F;01&quot;
val parsedDate &#x3D; format.parse(&quot;2023&#x2F;10&#x2F;01&quot;) &#x2F;&#x2F; LocalDate(2023, 10, 1)

&#x2F;&#x2F; 使用预定义的 ISO 格式
val isoDateString &#x3D; LocalDate(2023, 10, 1).toString() &#x2F;&#x2F; &quot;2023-10-01&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>时间计算与差值</strong></li></ul><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">val today &#x3D; LocalDate(2023, 10, 1)
val tomorrow &#x3D; today + DatePeriod(days &#x3D; 1)
val yesterday &#x3D; today - DatePeriod(months &#x3D; 1)

&#x2F;&#x2F; 计算两个日期的差值
val daysBetween &#x3D; today.daysUntil(tomorrow) &#x2F;&#x2F; 1

&#x2F;&#x2F; 计算时间差（Duration）
val start &#x3D; Instant.parse(&quot;2023-10-01T00:00:00Z&quot;)
val end &#x3D; Instant.parse(&quot;2023-10-02T12:00:00Z&quot;)
val duration &#x3D; end - start &#x2F;&#x2F; 36.hours<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>时区处理</strong></li></ul><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">&#x2F;&#x2F; 将 Instant 转换为带时区的日期时间
val timeZone &#x3D; TimeZone.of(&quot;Asia&#x2F;Shanghai&quot;)
val zonedDateTime &#x3D; now.toLocalDateTime(timeZone)

&#x2F;&#x2F; 时区转换
val newYorkTime &#x3D; zonedDateTime.toInstant(TimeZone.of(&quot;America&#x2F;New_York&quot;))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>时间区间与比较</strong></li></ul><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">val date1 &#x3D; LocalDate(2023, 10, 1)
val date2 &#x3D; LocalDate(2023, 10, 5)

&#x2F;&#x2F; 比较日期
val isBefore &#x3D; date1 &lt; date2 &#x2F;&#x2F; true

&#x2F;&#x2F; 创建时间区间
val dateRange &#x3D; date1..date2
val isInRange &#x3D; LocalDate(2023, 10, 3) in dateRange &#x2F;&#x2F; true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>跨平台注意事项：</strong></p><ul><li><strong>JS 和 Native 平台</strong>：部分功能（如复杂时区规则）可能依赖平台实现，需确保目标平台支持。</li><li><strong>与 Java 互操作</strong>：在 JVM 上，可以通过扩展函数与 <code>java.time</code> 互转：</li></ul><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">&#x2F;&#x2F; 转换为 java.time.LocalDate
val javaLocalDate: java.time.LocalDate &#x3D; kotlinDate.toJavaLocalDate()

&#x2F;&#x2F; 从 java.time 转换
val kotlinDate: LocalDate &#x3D; javaLocalDate.toKotlinLocalDate()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="常见场景示例"><a href="#常见场景示例" class="headerlink" title="常见场景示例"></a><strong>常见场景示例</strong></h3><ul><li><strong>获取本周的起始和结束日期</strong></li></ul><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">val today &#x3D; Clock.System.todayIn(TimeZone.currentSystemDefault())
val startOfWeek &#x3D; today - DatePeriod(days &#x3D; today.dayOfWeek.ordinal)
val endOfWeek &#x3D; startOfWeek + DatePeriod(days &#x3D; 6)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><strong>计算任务执行时间</strong></li></ul><pre class="line-numbers language-Kotlin" data-language="Kotlin"><code class="language-Kotlin">val startTime &#x3D; Clock.System.now()
&#x2F;&#x2F; 执行任务...
val endTime &#x3D; Clock.System.now()
val elapsed &#x3D; endTime - startTime
println(&quot;耗时: $&#123;elapsed.inWholeSeconds&#125; 秒&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><hr><div class="reprint" id="reprint-statement"><div class="reprint__author"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-user">文章作者: </i></span><span class="reprint-info"><a href="/about" rel="external nofollow noreferrer">海星来来</a></span></div><div class="reprint__type"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-link">文章链接: </i></span><span class="reprint-info"><a href="https://blog.pengdonglai.com/2025/01/29/android-2/">https://blog.pengdonglai.com/2025/01/29/android-2/</a></span></div><div class="reprint__notice"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-copyright">版权声明: </i></span><span class="reprint-info">本博客所有文章除特別声明外，均采用 <a href="https://creativecommons.org/licenses/by/4.0/deed.zh-hans" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a> 许可协议。转载请注明来源 <a href="/about" target="_blank">海星来来</a> !</span></div></div><script async defer>document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }</script><div class="tag_share" style="display:block"><div class="post-meta__tag-list" style="display:inline-block"><div class="article-tag"><a href="/tags/Android/"><span class="chip bg-color">Android</span> </a><a href="/tags/Kotlin/"><span class="chip bg-color">Kotlin</span> </a><a href="/tags/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"><span class="chip bg-color">基础语法</span></a></div></div><div class="post_share" style="zoom:80%;width:fit-content;display:inline-block;float:right;margin:-.15rem 0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/libs/share/css/share.min.css"><div id="article-share"><div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div><script src="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/libs/share/js/social-share.min.js"></script></div></div></div></div></div><article id="prenext-posts" class="prev-next articles"><div class="row article-row"><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge left-badge text-color"><i class="fas fa-chevron-left"></i>&nbsp;上一篇</div><div class="card"><a href="/2025/01/29/android-1/"><div class="card-image"><img src="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/medias/featureimages/8.webp" class="responsive-img" alt="安卓（1）-语法基础：Kotlin ＆ Java ＆ TS 对比"> <span class="card-title">安卓（1）-语法基础：Kotlin ＆ Java ＆ TS 对比</span></div></a><div class="card-content article-content"><div class="summary block-with-text">安卓小白，在线性感发牌</div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i>2025-01-29 </span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/Android/" class="post-category">Android </a><a href="/categories/Android/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" class="post-category">基础语法</a></span></div></div><div class="card-action article-tags"><a href="/tags/Android/"><span class="chip bg-color">Android</span> </a><a href="/tags/Kotlin/"><span class="chip bg-color">Kotlin</span> </a><a href="/tags/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"><span class="chip bg-color">基础语法</span></a></div></div></div><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge right-badge text-color">下一篇&nbsp;<i class="fas fa-chevron-right"></i></div><div class="card"><a href="/2025/01/29/android-3/"><div class="card-image"><img src="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/medias/featureimages/10.webp" class="responsive-img" alt="安卓（3）-实用篇：UI（1）"> <span class="card-title">安卓（3）-实用篇：UI（1）</span></div></a><div class="card-content article-content"><div class="summary block-with-text">安卓小白，在线性感发牌</div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i>2025-01-29 </span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/Android/" class="post-category">Android </a><a href="/categories/Android/UI/" class="post-category">UI</a></span></div></div><div class="card-action article-tags"><a href="/tags/Android/"><span class="chip bg-color">Android</span> </a><a href="/tags/Kotlin/"><span class="chip bg-color">Kotlin</span> </a><a href="/tags/Jetpack-Compose/"><span class="chip bg-color">Jetpack Compose</span> </a><a href="/tags/Activity/"><span class="chip bg-color">Activity</span></a></div></div></div></div></article></div><script>$("#articleContent").on("copy",function(e){var n,t,o,i;void 0!==window.getSelection&&((""+(n=window.getSelection())).length<Number.parseInt("80")||(t=document.getElementsByTagName("body")[0],(o=document.createElement("div")).style.position="absolute",o.style.left="-99999px",t.appendChild(o),o.appendChild(n.getRangeAt(0).cloneContents()),"PRE"===n.getRangeAt(0).commonAncestorContainer.nodeName&&(o.innerHTML="<pre>"+o.innerHTML+"</pre>"),i=document.location.href,o.innerHTML+='<br />来源: 海祇岛的珊瑚森林<br />文章作者: 海星来来<br />文章链接: <a href="'+i+'">'+i+"</a><br />本文章著作权归作者所有，任何形式的转载都请注明出处。",n.selectAllChildren(o),window.setTimeout(function(){t.removeChild(o)},200)))})</script><script src="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/libs/codeBlock/codeBlockFuction.js"></script><script src="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/libs/codeBlock/codeLang.js"></script><script src="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/libs/codeBlock/codeCopy.js"></script><script src="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/libs/codeBlock/codeShrink.js"></script></div><div id="toc-aside" class="expanded col l3 hide-on-med-and-down"><div class="toc-widget card"><div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div><div id="toc-content"></div></div></div></div><div id="floating-toc-btn" class="hide-on-med-and-down"><a class="btn-floating btn-large bg-color"><i class="fas fa-list-ul"></i></a></div><script src="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/libs/tocbot/tocbot.min.js"></script><script>$(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });</script></main><footer class="page-footer bg-color"><div class="container row center-align" style="margin-bottom:0!important"><div class="col s12 m8 l8 copy-right">Copyright&nbsp;&copy; <span id="year">2019-2025</span> <span id="year">2019</span> <a href="/about" target="_blank">海星来来</a> |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a> |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a> <span id="translate">|&nbsp;繁/简：</span><a id="translateLink" href="javascript:translatePage();">繁</a><br>&nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span class="white-color">162.2k</span>&nbsp;字 <span id="busuanzi_container_site_pv">|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv" class="white-color"></span>&nbsp;次 </span><span id="busuanzi_container_site_uv">|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv" class="white-color"></span>&nbsp;人</span><br><br></div><div class="col s12 m4 l4 social-link social-statis"><a href="https://github.com/umaru2001" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"><i class="fab fa-github"></i> </a><a href="mailto:donglaistarfish@gmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50"><i class="fas fa-envelope-open"></i> </a><a href="https://www.zhihu.com/people/hao-ba-50-81-68" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/hao-ba-50-81-68" data-position="top" data-delay="50"><i class="fab fa-zhihu1">知</i> </a><a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50"><i class="fas fa-rss"></i></a></div></div></footer><div class="progress-bar"></div><div id="searchModal" class="modal"><div class="modal-content"><div class="search-header"><span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span> <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input"></div><div id="searchResult"></div></div></div><script>$(function(){!function(t,s,i){"use strict";$.ajax({url:t,dataType:"xml",success:function(t){var e=$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get(),n=document.getElementById(s),r=document.getElementById(i);n.addEventListener("input",function(){var f='<ul class="search-result-list">',m=this.value.trim().toLowerCase().split(/[\s\-]+/);r.innerHTML="",this.value.trim().length<=0||(e.forEach(function(t){var n,e,r,s,i,l=!0,a=t.title.trim().toLowerCase(),c=t.content.trim().replace(/<[^>]+>/g,"").toLowerCase(),u=0===(u=t.url).indexOf("/")?t.url:"/"+u,o=-1,h=-1;""!==a&&""!==c&&m.forEach(function(t,e){n=a.indexOf(t),o=c.indexOf(t),n<0&&o<0?l=!1:(o<0&&(o=0),0===e&&(h=o))}),l&&(f+="<li><a href='"+u+"' class='search-result-title'>"+a+"</a>",e=t.content.trim().replace(/<[^>]+>/g,""),0<=h&&(s=h+80,(r=h-20)<0&&(r=0),0===r&&(s=100),s>e.length&&(s=e.length),i=e.substr(r,s),m.forEach(function(t){var e=new RegExp(t,"gi");i=i.replace(e,'<em class="search-keyword">'+t+"</em>")}),f+='<p class="search-result">'+i+"...</p>"),f+="</li>")}),f+="</ul>",r.innerHTML=f)})}})}("/search.xml","searchInput","searchResult")})</script><div id="backTop" class="top-scroll"><a class="btn-floating btn-large waves-effect waves-light" href="#!"><i class="fas fa-arrow-up"></i></a></div><script src="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/libs/materialize/materialize.min.js"></script><script src="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/libs/masonry/masonry.pkgd.min.js"></script><script src="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/libs/aos/aos.js"></script><script src="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/libs/scrollprogress/scrollProgress.min.js"></script><script src="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/libs/lightGallery/js/lightgallery-all.min.js"></script><script src="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/js/matery.js"></script><script src="/live2d-widget/autoload.js"></script><script src="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/libs/others/clicklove.js" async></script><script async src="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/libs/others/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/js/tw_cn.js"></script><script>var defaultEncoding=2,translateDelay=0,cookieDomain="https://blog.pengdonglai.com",msgToTraditionalChinese="繁",msgToSimplifiedChinese="简",translateButtonId="translateLink";translateInitilization()</script><script src="https://cdn.jsdelivr.net/gh/umaru2001/umaru2001.github.io/libs/instantpage/instantpage.js" type="module"></script>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 3,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,d=o();function o(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=o());for(var e,i=0;i<d.length;i++)0<=(e=(e=d[i]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,a,n,o=d[i];e=function(){d=d.filter(function(t){return o!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(o)},(t=o).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,n=t.getAttribute("data-original"),a.onload=function(){t.src=n,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=n},t.src!==n&&(a.src=n)))}()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)}(this);</script></body></html>